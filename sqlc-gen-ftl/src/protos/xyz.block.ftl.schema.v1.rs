// @generated
// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwsiamAuthDatabaseConnector {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Any {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Array {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, boxed, tag="2")]
    pub element: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bool {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bytes {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Changeset {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag="3")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
    #[prost(string, repeated, tag="4")]
    pub to_remove: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="5")]
    pub removing_modules: ::prost::alloc::vec::Vec<Module>,
    #[prost(enumeration="ChangesetState", tag="6")]
    pub state: i32,
    #[prost(string, optional, tag="7")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetCommittedEvent {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetCommittedNotification {
    #[prost(message, optional, tag="1")]
    pub changeset: ::core::option::Option<Changeset>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetCreatedEvent {
    #[prost(message, optional, tag="1")]
    pub changeset: ::core::option::Option<Changeset>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetCreatedNotification {
    #[prost(message, optional, tag="1")]
    pub changeset: ::core::option::Option<Changeset>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetDrainedEvent {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetDrainedNotification {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetFailedEvent {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetFailedNotification {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub error: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetFinalizedEvent {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetFinalizedNotification {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetPreparedEvent {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetPreparedNotification {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetRollingBackEvent {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub error: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangesetRollingBackNotification {
    #[prost(message, optional, tag="1")]
    pub changeset: ::core::option::Option<Changeset>,
    #[prost(string, tag="2")]
    pub error: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub r#type: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsnDatabaseConnector {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub dsn: ::prost::alloc::string::String,
}
/// A Data structure.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Data {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="5")]
    pub type_parameters: ::prost::alloc::vec::Vec<TypeParameter>,
    #[prost(message, repeated, tag="6")]
    pub fields: ::prost::alloc::vec::Vec<Field>,
    #[prost(message, repeated, tag="7")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Database {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<DatabaseRuntime>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="4")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="5")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseConnector {
    #[prost(oneof="database_connector::Value", tags="2, 1")]
    pub value: ::core::option::Option<database_connector::Value>,
}
/// Nested message and enum types in `DatabaseConnector`.
pub mod database_connector {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="2")]
        AwsiamAuthDatabaseConnector(super::AwsiamAuthDatabaseConnector),
        #[prost(message, tag="1")]
        DsnDatabaseConnector(super::DsnDatabaseConnector),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseRuntime {
    #[prost(message, optional, tag="1")]
    pub connections: ::core::option::Option<DatabaseRuntimeConnections>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseRuntimeConnections {
    #[prost(message, optional, tag="1")]
    pub read: ::core::option::Option<DatabaseConnector>,
    #[prost(message, optional, tag="2")]
    pub write: ::core::option::Option<DatabaseConnector>,
}
/// Decl represents user-defined data types in the schema grammar.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Decl {
    #[prost(oneof="decl::Value", tags="6, 1, 3, 4, 7, 9, 5, 2")]
    pub value: ::core::option::Option<decl::Value>,
}
/// Nested message and enum types in `Decl`.
pub mod decl {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="6")]
        Config(super::Config),
        #[prost(message, tag="1")]
        Data(super::Data),
        #[prost(message, tag="3")]
        Database(super::Database),
        #[prost(message, tag="4")]
        Enum(super::Enum),
        #[prost(message, tag="7")]
        Secret(super::Secret),
        #[prost(message, tag="9")]
        Topic(super::Topic),
        #[prost(message, tag="5")]
        TypeAlias(super::TypeAlias),
        #[prost(message, tag="2")]
        Verb(super::Verb),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeploymentCreatedEvent {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub schema: ::core::option::Option<Module>,
    #[prost(string, tag="3")]
    pub changeset: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeploymentRuntimeEvent {
    #[prost(message, optional, tag="1")]
    pub payload: ::core::option::Option<RuntimeElement>,
    #[prost(string, tag="2")]
    pub changeset: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeploymentRuntimeNotification {
    #[prost(message, optional, tag="1")]
    pub payload: ::core::option::Option<RuntimeElement>,
    #[prost(string, tag="2")]
    pub changeset: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Enum {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="6")]
    pub variants: ::prost::alloc::vec::Vec<EnumVariant>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumVariant {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub value: ::core::option::Option<Value>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(oneof="event::Value", tags="5, 3, 6, 9, 7, 4, 8, 1, 2")]
    pub value: ::core::option::Option<event::Value>,
}
/// Nested message and enum types in `Event`.
pub mod event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="5")]
        ChangesetCommittedEvent(super::ChangesetCommittedEvent),
        #[prost(message, tag="3")]
        ChangesetCreatedEvent(super::ChangesetCreatedEvent),
        #[prost(message, tag="6")]
        ChangesetDrainedEvent(super::ChangesetDrainedEvent),
        #[prost(message, tag="9")]
        ChangesetFailedEvent(super::ChangesetFailedEvent),
        #[prost(message, tag="7")]
        ChangesetFinalizedEvent(super::ChangesetFinalizedEvent),
        #[prost(message, tag="4")]
        ChangesetPreparedEvent(super::ChangesetPreparedEvent),
        #[prost(message, tag="8")]
        ChangesetRollingBackEvent(super::ChangesetRollingBackEvent),
        #[prost(message, tag="1")]
        DeploymentCreatedEvent(super::DeploymentCreatedEvent),
        #[prost(message, tag="2")]
        DeploymentRuntimeEvent(super::DeploymentRuntimeEvent),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="3")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="5")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Float {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FullSchemaNotification {
    #[prost(message, optional, tag="1")]
    pub schema: ::core::option::Option<Schema>,
    #[prost(message, repeated, tag="2")]
    pub changesets: ::prost::alloc::vec::Vec<Changeset>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngressPathComponent {
    #[prost(oneof="ingress_path_component::Value", tags="1, 2")]
    pub value: ::core::option::Option<ingress_path_component::Value>,
}
/// Nested message and enum types in `IngressPathComponent`.
pub mod ingress_path_component {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="1")]
        IngressPathLiteral(super::IngressPathLiteral),
        #[prost(message, tag="2")]
        IngressPathParameter(super::IngressPathParameter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngressPathLiteral {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub text: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngressPathParameter {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Int {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntValue {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(int64, tag="2")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Map {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, boxed, tag="2")]
    pub key: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
    #[prost(message, optional, boxed, tag="3")]
    pub value: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
}
/// Metadata represents a metadata Node in the schema grammar.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(oneof="metadata::Value", tags="5, 14, 1, 10, 3, 4, 9, 2, 15, 12, 6, 17, 13, 16, 11, 7, 8")]
    pub value: ::core::option::Option<metadata::Value>,
}
/// Nested message and enum types in `Metadata`.
pub mod metadata {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="5")]
        Alias(super::MetadataAlias),
        #[prost(message, tag="14")]
        Artefact(super::MetadataArtefact),
        #[prost(message, tag="1")]
        Calls(super::MetadataCalls),
        #[prost(message, tag="10")]
        Config(super::MetadataConfig),
        #[prost(message, tag="3")]
        CronJob(super::MetadataCronJob),
        #[prost(message, tag="4")]
        Databases(super::MetadataDatabases),
        #[prost(message, tag="9")]
        Encoding(super::MetadataEncoding),
        #[prost(message, tag="2")]
        Ingress(super::MetadataIngress),
        #[prost(message, tag="15")]
        Partitions(super::MetadataPartitions),
        #[prost(message, tag="12")]
        Publisher(super::MetadataPublisher),
        #[prost(message, tag="6")]
        Retry(super::MetadataRetry),
        #[prost(message, tag="17")]
        SqlColumn(super::MetadataSqlColumn),
        #[prost(message, tag="13")]
        SqlMigration(super::MetadataSqlMigration),
        #[prost(message, tag="16")]
        SqlQuery(super::MetadataSqlQuery),
        #[prost(message, tag="11")]
        Secrets(super::MetadataSecrets),
        #[prost(message, tag="7")]
        Subscriber(super::MetadataSubscriber),
        #[prost(message, tag="8")]
        TypeMap(super::MetadataTypeMap),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataAlias {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(enumeration="AliasKind", tag="2")]
    pub kind: i32,
    #[prost(string, tag="3")]
    pub alias: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataArtefact {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub digest: ::prost::alloc::string::String,
    #[prost(bool, tag="4")]
    pub executable: bool,
}
/// MetadataCalls represents a metadata block with a list of calls.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataCalls {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub calls: ::prost::alloc::vec::Vec<Ref>,
}
/// MetadataConfig represents a metadata block with a list of config items that are used.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataConfig {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub config: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataCronJob {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub cron: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataDatabases {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub calls: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataEncoding {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub lenient: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataIngress {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub method: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub path: ::prost::alloc::vec::Vec<IngressPathComponent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataPartitions {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(int64, tag="2")]
    pub partitions: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataPublisher {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub topics: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataRetry {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(int64, optional, tag="2")]
    pub count: ::core::option::Option<i64>,
    #[prost(string, tag="3")]
    pub min_backoff: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub max_backoff: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub catch: ::core::option::Option<Ref>,
}
/// MetadataSQLColumn designates a database column.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSqlColumn {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub table: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSqlMigration {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub digest: ::prost::alloc::string::String,
}
/// MetadataSQLQuery designates a query verb; a verb generated from a SQL query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSqlQuery {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub command: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub query: ::prost::alloc::string::String,
}
/// MetadataSecrets represents a metadata block with a list of config items that are used.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSecrets {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub secrets: ::prost::alloc::vec::Vec<Ref>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSubscriber {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag="2")]
    pub topic: ::core::option::Option<Ref>,
    #[prost(enumeration="FromOffset", tag="3")]
    pub from_offset: i32,
    #[prost(bool, tag="4")]
    pub dead_letter: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataTypeMap {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub runtime: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub native_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Module {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub builtin: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="6")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
    #[prost(message, repeated, tag="5")]
    pub decls: ::prost::alloc::vec::Vec<Decl>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<ModuleRuntime>,
}
/// ModuleRuntime is runtime configuration for a module that can be dynamically updated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRuntime {
    #[prost(message, optional, tag="1")]
    pub base: ::core::option::Option<ModuleRuntimeBase>,
    #[prost(message, optional, tag="2")]
    pub scaling: ::core::option::Option<ModuleRuntimeScaling>,
    #[prost(message, optional, tag="3")]
    pub deployment: ::core::option::Option<ModuleRuntimeDeployment>,
    #[prost(message, optional, tag="4")]
    pub runner: ::core::option::Option<ModuleRuntimeRunner>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRuntimeBase {
    #[prost(message, optional, tag="1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag="2")]
    pub language: ::prost::alloc::string::String,
    #[prost(string, optional, tag="3")]
    pub os: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub arch: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub image: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRuntimeDeployment {
    #[prost(string, tag="2")]
    pub deployment_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag="3")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="4")]
    pub activated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration="DeploymentState", tag="5")]
    pub state: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRuntimeRunner {
    #[prost(string, tag="1")]
    pub endpoint: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModuleRuntimeScaling {
    #[prost(int32, tag="1")]
    pub min_replicas: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Notification {
    #[prost(oneof="notification::Value", tags="5, 3, 6, 9, 7, 4, 8, 2, 1")]
    pub value: ::core::option::Option<notification::Value>,
}
/// Nested message and enum types in `Notification`.
pub mod notification {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="5")]
        ChangesetCommittedNotification(super::ChangesetCommittedNotification),
        #[prost(message, tag="3")]
        ChangesetCreatedNotification(super::ChangesetCreatedNotification),
        #[prost(message, tag="6")]
        ChangesetDrainedNotification(super::ChangesetDrainedNotification),
        #[prost(message, tag="9")]
        ChangesetFailedNotification(super::ChangesetFailedNotification),
        #[prost(message, tag="7")]
        ChangesetFinalizedNotification(super::ChangesetFinalizedNotification),
        #[prost(message, tag="4")]
        ChangesetPreparedNotification(super::ChangesetPreparedNotification),
        #[prost(message, tag="8")]
        ChangesetRollingBackNotification(super::ChangesetRollingBackNotification),
        #[prost(message, tag="2")]
        DeploymentRuntimeNotification(super::DeploymentRuntimeNotification),
        #[prost(message, tag="1")]
        FullSchemaNotification(super::FullSchemaNotification),
    }
}
/// Optional represents a Type whose value may be optional.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Optional {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, boxed, tag="2")]
    pub r#type: ::core::option::Option<::prost::alloc::boxed::Box<Type>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Position {
    #[prost(string, tag="1")]
    pub filename: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub line: i64,
    #[prost(int64, tag="3")]
    pub column: i64,
}
/// Ref is an untyped reference to a symbol.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ref {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="3")]
    pub module: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub type_parameters: ::prost::alloc::vec::Vec<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Runtime {
    #[prost(oneof="runtime::Value", tags="6, 1, 3, 2, 5, 4")]
    pub value: ::core::option::Option<runtime::Value>,
}
/// Nested message and enum types in `Runtime`.
pub mod runtime {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="6")]
        DatabaseRuntime(super::DatabaseRuntime),
        #[prost(message, tag="1")]
        ModuleRuntimeDeployment(super::ModuleRuntimeDeployment),
        #[prost(message, tag="3")]
        ModuleRuntimeRunner(super::ModuleRuntimeRunner),
        #[prost(message, tag="2")]
        ModuleRuntimeScaling(super::ModuleRuntimeScaling),
        #[prost(message, tag="5")]
        TopicRuntime(super::TopicRuntime),
        #[prost(message, tag="4")]
        VerbRuntime(super::VerbRuntime),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuntimeElement {
    #[prost(message, optional, tag="1")]
    pub element: ::core::option::Option<Runtime>,
    #[prost(string, tag="2")]
    pub deployment: ::prost::alloc::string::String,
    #[prost(string, optional, tag="3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, repeated, tag="2")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
}
/// SchemaState is the schema service state as persisted in Raft
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaState {
    #[prost(message, repeated, tag="1")]
    pub modules: ::prost::alloc::vec::Vec<Module>,
    #[prost(message, repeated, tag="2")]
    pub changesets: ::prost::alloc::vec::Vec<Changeset>,
    #[prost(message, repeated, tag="3")]
    pub changeset_events: ::prost::alloc::vec::Vec<DeploymentRuntimeEvent>,
    #[prost(message, repeated, tag="4")]
    pub deployment_events: ::prost::alloc::vec::Vec<DeploymentRuntimeEvent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Secret {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub r#type: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct String {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringValue {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Time {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Topic {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<TopicRuntime>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub event: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="6")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicRuntime {
    #[prost(string, repeated, tag="1")]
    pub kafka_brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="2")]
    pub topic_id: ::prost::alloc::string::String,
}
/// Type represents a Type Node in the schema grammar.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Type {
    #[prost(oneof="r#type::Value", tags="9, 7, 5, 4, 2, 1, 8, 12, 11, 3, 6, 10")]
    pub value: ::core::option::Option<r#type::Value>,
}
/// Nested message and enum types in `Type`.
pub mod r#type {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="9")]
        Any(super::Any),
        #[prost(message, tag="7")]
        Array(::prost::alloc::boxed::Box<super::Array>),
        #[prost(message, tag="5")]
        Bool(super::Bool),
        #[prost(message, tag="4")]
        Bytes(super::Bytes),
        #[prost(message, tag="2")]
        Float(super::Float),
        #[prost(message, tag="1")]
        Int(super::Int),
        #[prost(message, tag="8")]
        Map(::prost::alloc::boxed::Box<super::Map>),
        #[prost(message, tag="12")]
        Optional(::prost::alloc::boxed::Box<super::Optional>),
        #[prost(message, tag="11")]
        Ref(super::Ref),
        #[prost(message, tag="3")]
        String(super::String),
        #[prost(message, tag="6")]
        Time(super::Time),
        #[prost(message, tag="10")]
        Unit(super::Unit),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeAlias {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="6")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeParameter {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeValue {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag="2")]
    pub value: ::core::option::Option<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unit {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
}
/// Value represents a value Node in the schema grammar.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof="value::Value", tags="2, 1, 3")]
    pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag="2")]
        IntValue(super::IntValue),
        #[prost(message, tag="1")]
        StringValue(super::StringValue),
        #[prost(message, tag="3")]
        TypeValue(super::TypeValue),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Verb {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(string, repeated, tag="2")]
    pub comments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag="3")]
    pub export: bool,
    #[prost(string, tag="4")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub request: ::core::option::Option<Type>,
    #[prost(message, optional, tag="6")]
    pub response: ::core::option::Option<Type>,
    #[prost(message, repeated, tag="7")]
    pub metadata: ::prost::alloc::vec::Vec<Metadata>,
    #[prost(message, optional, tag="31634")]
    pub runtime: ::core::option::Option<VerbRuntime>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbRuntime {
    #[prost(message, optional, tag="1")]
    pub subscription: ::core::option::Option<VerbRuntimeSubscription>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerbRuntimeSubscription {
    #[prost(string, repeated, tag="1")]
    pub kafka_brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// AliasKind is the kind of alias.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AliasKind {
    Unspecified = 0,
    Json = 1,
}
impl AliasKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ALIAS_KIND_UNSPECIFIED",
            Self::Json => "ALIAS_KIND_JSON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALIAS_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "ALIAS_KIND_JSON" => Some(Self::Json),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChangesetState {
    Unspecified = 0,
    Preparing = 1,
    Prepared = 2,
    Committed = 3,
    Drained = 4,
    Finalized = 5,
    RollingBack = 6,
    Failed = 7,
}
impl ChangesetState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CHANGESET_STATE_UNSPECIFIED",
            Self::Preparing => "CHANGESET_STATE_PREPARING",
            Self::Prepared => "CHANGESET_STATE_PREPARED",
            Self::Committed => "CHANGESET_STATE_COMMITTED",
            Self::Drained => "CHANGESET_STATE_DRAINED",
            Self::Finalized => "CHANGESET_STATE_FINALIZED",
            Self::RollingBack => "CHANGESET_STATE_ROLLING_BACK",
            Self::Failed => "CHANGESET_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHANGESET_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "CHANGESET_STATE_PREPARING" => Some(Self::Preparing),
            "CHANGESET_STATE_PREPARED" => Some(Self::Prepared),
            "CHANGESET_STATE_COMMITTED" => Some(Self::Committed),
            "CHANGESET_STATE_DRAINED" => Some(Self::Drained),
            "CHANGESET_STATE_FINALIZED" => Some(Self::Finalized),
            "CHANGESET_STATE_ROLLING_BACK" => Some(Self::RollingBack),
            "CHANGESET_STATE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentState {
    Unspecified = 0,
    Provisioning = 1,
    Ready = 2,
    Canary = 3,
    Canonical = 4,
    Draining = 5,
    DeProvisioning = 6,
    Deleted = 7,
    Failed = 8,
}
impl DeploymentState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DEPLOYMENT_STATE_UNSPECIFIED",
            Self::Provisioning => "DEPLOYMENT_STATE_PROVISIONING",
            Self::Ready => "DEPLOYMENT_STATE_READY",
            Self::Canary => "DEPLOYMENT_STATE_CANARY",
            Self::Canonical => "DEPLOYMENT_STATE_CANONICAL",
            Self::Draining => "DEPLOYMENT_STATE_DRAINING",
            Self::DeProvisioning => "DEPLOYMENT_STATE_DE_PROVISIONING",
            Self::Deleted => "DEPLOYMENT_STATE_DELETED",
            Self::Failed => "DEPLOYMENT_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "DEPLOYMENT_STATE_PROVISIONING" => Some(Self::Provisioning),
            "DEPLOYMENT_STATE_READY" => Some(Self::Ready),
            "DEPLOYMENT_STATE_CANARY" => Some(Self::Canary),
            "DEPLOYMENT_STATE_CANONICAL" => Some(Self::Canonical),
            "DEPLOYMENT_STATE_DRAINING" => Some(Self::Draining),
            "DEPLOYMENT_STATE_DE_PROVISIONING" => Some(Self::DeProvisioning),
            "DEPLOYMENT_STATE_DELETED" => Some(Self::Deleted),
            "DEPLOYMENT_STATE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FromOffset {
    Unspecified = 0,
    Beginning = 1,
    Latest = 2,
}
impl FromOffset {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FROM_OFFSET_UNSPECIFIED",
            Self::Beginning => "FROM_OFFSET_BEGINNING",
            Self::Latest => "FROM_OFFSET_LATEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FROM_OFFSET_UNSPECIFIED" => Some(Self::Unspecified),
            "FROM_OFFSET_BEGINNING" => Some(Self::Beginning),
            "FROM_OFFSET_LATEST" => Some(Self::Latest),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
