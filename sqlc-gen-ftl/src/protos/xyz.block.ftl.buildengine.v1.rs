// @generated
// This file is @generated by prost-build.
/// EngineStarted is published when the engine becomes busy building and deploying modules.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EngineStarted {
}
/// EngineEnded is published when the engine is no longer building or deploying any modules.
/// If there are any remaining errors, they will be included in the ModuleErrors map.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EngineEnded {
    #[prost(message, repeated, tag="1")]
    pub modules: ::prost::alloc::vec::Vec<engine_ended::Module>,
}
/// Nested message and enum types in `EngineEnded`.
pub mod engine_ended {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Module {
        #[prost(string, tag="1")]
        pub module: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub path: ::prost::alloc::string::String,
        #[prost(message, optional, tag="3")]
        pub errors: ::core::option::Option<super::super::super::language::v1::ErrorList>,
    }
}
/// ModuleAdded is published when the engine discovers a module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleAdded {
    #[prost(string, tag="1")]
    pub module: ::prost::alloc::string::String,
}
/// ModuleRemoved is published when the engine discovers a module has been removed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleRemoved {
    #[prost(string, tag="1")]
    pub module: ::prost::alloc::string::String,
}
/// ModuleBuildWaiting is published when a build is waiting for dependencies to build
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleBuildWaiting {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<super::super::language::v1::ModuleConfig>,
}
/// ModuleBuildStarted is published when a build has started for a module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleBuildStarted {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<super::super::language::v1::ModuleConfig>,
    #[prost(bool, tag="2")]
    pub is_auto_rebuild: bool,
}
/// ModuleBuildFailed is published for any build failures.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleBuildFailed {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<super::super::language::v1::ModuleConfig>,
    #[prost(message, optional, tag="2")]
    pub errors: ::core::option::Option<super::super::language::v1::ErrorList>,
    #[prost(bool, tag="3")]
    pub is_auto_rebuild: bool,
}
/// ModuleBuildSuccess is published when all modules have been built successfully built.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleBuildSuccess {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<super::super::language::v1::ModuleConfig>,
    #[prost(bool, tag="2")]
    pub is_auto_rebuild: bool,
}
/// ModuleDeployStarted is published when a deploy has been queued
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDeployWaiting {
    #[prost(string, tag="1")]
    pub module: ::prost::alloc::string::String,
}
/// ModuleDeployStarted is published when a deploy has begun for a module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDeployStarted {
    #[prost(string, tag="1")]
    pub module: ::prost::alloc::string::String,
}
/// ModuleDeployFailed is published for any deploy failures.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDeployFailed {
    #[prost(string, tag="1")]
    pub module: ::prost::alloc::string::String,
    #[prost(message, optional, tag="2")]
    pub errors: ::core::option::Option<super::super::language::v1::ErrorList>,
}
/// ModuleDeploySuccess is published when all modules have been built successfully deployed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDeploySuccess {
    #[prost(string, tag="1")]
    pub module: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReachedEndOfHistory {
}
/// EngineEvent is an event published by the engine as modules get built and deployed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EngineEvent {
    #[prost(message, optional, tag="1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof="engine_event::Event", tags="2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14")]
    pub event: ::core::option::Option<engine_event::Event>,
}
/// Nested message and enum types in `EngineEvent`.
pub mod engine_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag="2")]
        EngineStarted(super::EngineStarted),
        #[prost(message, tag="3")]
        EngineEnded(super::EngineEnded),
        #[prost(message, tag="4")]
        ModuleAdded(super::ModuleAdded),
        #[prost(message, tag="5")]
        ModuleRemoved(super::ModuleRemoved),
        #[prost(message, tag="6")]
        ModuleBuildWaiting(super::ModuleBuildWaiting),
        #[prost(message, tag="7")]
        ModuleBuildStarted(super::ModuleBuildStarted),
        #[prost(message, tag="8")]
        ModuleBuildFailed(super::ModuleBuildFailed),
        #[prost(message, tag="9")]
        ModuleBuildSuccess(super::ModuleBuildSuccess),
        #[prost(message, tag="10")]
        ModuleDeployWaiting(super::ModuleDeployWaiting),
        #[prost(message, tag="11")]
        ModuleDeployStarted(super::ModuleDeployStarted),
        #[prost(message, tag="12")]
        ModuleDeployFailed(super::ModuleDeployFailed),
        #[prost(message, tag="13")]
        ModuleDeploySuccess(super::ModuleDeploySuccess),
        #[prost(message, tag="14")]
        ReachedEndOfHistory(super::ReachedEndOfHistory),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StreamEngineEventsRequest {
    /// If true, cached events will be replayed before streaming new events.
    /// If false, only new events will be streamed.
    #[prost(bool, tag="1")]
    pub replay_history: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamEngineEventsResponse {
    #[prost(message, optional, tag="1")]
    pub event: ::core::option::Option<EngineEvent>,
}
// @@protoc_insertion_point(module)
