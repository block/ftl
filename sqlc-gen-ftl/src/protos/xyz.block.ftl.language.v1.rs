// @generated
// This file is @generated by prost-build.
/// ModuleConfig contains the configuration for a module, found in the module's ftl.toml file.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleConfig {
    /// Name of the module
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Absolute path to the module's directory
    #[prost(string, tag="2")]
    pub dir: ::prost::alloc::string::String,
    /// The language of the module
    #[prost(string, tag="3")]
    pub language: ::prost::alloc::string::String,
    /// Absolute path to the directory containing all of this module's build artifacts for deployments
    #[prost(string, tag="4")]
    pub deploy_dir: ::prost::alloc::string::String,
    /// Build is the command to build the module.
    #[prost(string, optional, tag="5")]
    pub build: ::core::option::Option<::prost::alloc::string::String>,
    /// DevModeBuild is the command to build the module in dev mode.
    #[prost(string, optional, tag="6")]
    pub dev_mode_build: ::core::option::Option<::prost::alloc::string::String>,
    /// Build lock path to prevent concurrent builds
    #[prost(string, tag="7")]
    pub build_lock: ::prost::alloc::string::String,
    /// Patterns to watch for file changes
    #[prost(string, repeated, tag="9")]
    pub watch: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// LanguageConfig contains any metadata specific to a specific language.
    /// These are stored in the ftl.toml file under the same key as the language (eg: "go", "java")
    #[prost(message, optional, tag="10")]
    pub language_config: ::core::option::Option<::prost_types::Struct>,
    /// The root directory containing the SQL files, relative to the module directory.
    #[prost(string, tag="11")]
    pub sql_root_dir: ::prost::alloc::string::String,
    /// The realm of the module
    #[prost(string, tag="12")]
    pub realm: ::prost::alloc::string::String,
}
/// ProjectConfig contains the configuration for a project, found in the ftl-project.toml file.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectConfig {
    #[prost(string, tag="1")]
    pub dir: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag="3")]
    pub no_git: bool,
    #[prost(bool, tag="4")]
    pub hermit: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDependenciesRequest {
    #[prost(message, optional, tag="1")]
    pub module_config: ::core::option::Option<ModuleConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDependenciesResponse {
    #[prost(string, repeated, tag="1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// BuildContext contains contextual information needed to build.
///
/// Plugins must include the build context's id when a build succeeds or fails.
/// For automatic rebuilds, plugins must use the most recent build context they have received.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildContext {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    /// The configuration for the module
    #[prost(message, optional, tag="2")]
    pub module_config: ::core::option::Option<ModuleConfig>,
    /// The FTL schema including all dependencies
    #[prost(message, optional, tag="3")]
    pub schema: ::core::option::Option<super::super::schema::v1::Schema>,
    /// The dependencies for the module
    #[prost(string, repeated, tag="4")]
    pub dependencies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Build environment provides environment variables to be set for the build command
    #[prost(string, repeated, tag="5")]
    pub build_env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag="6")]
    pub os: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub arch: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildContextUpdatedRequest {
    #[prost(message, optional, tag="1")]
    pub build_context: ::core::option::Option<BuildContext>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BuildContextUpdatedResponse {
}
/// Error contains information about an error that occurred during a build.
/// Errors do not always cause a build failure. Use lesser levels to help guide the user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(string, tag="1")]
    pub msg: ::prost::alloc::string::String,
    #[prost(enumeration="error::ErrorLevel", tag="4")]
    pub level: i32,
    #[prost(message, optional, tag="5")]
    pub pos: ::core::option::Option<Position>,
    #[prost(enumeration="error::ErrorType", tag="6")]
    pub r#type: i32,
}
/// Nested message and enum types in `Error`.
pub mod error {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ErrorLevel {
        Unspecified = 0,
        Info = 1,
        Warn = 2,
        Error = 3,
    }
    impl ErrorLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ERROR_LEVEL_UNSPECIFIED",
                Self::Info => "ERROR_LEVEL_INFO",
                Self::Warn => "ERROR_LEVEL_WARN",
                Self::Error => "ERROR_LEVEL_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                "ERROR_LEVEL_INFO" => Some(Self::Info),
                "ERROR_LEVEL_WARN" => Some(Self::Warn),
                "ERROR_LEVEL_ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ErrorType {
        Unspecified = 0,
        Ftl = 1,
        /// Compiler errors are errors that are from the compiler. This is useful to avoid duplicate errors
        /// being shown to the user when combining errors from multiple sources (eg: an IDE showing compiler
        /// errors and FTL errors via LSP).
        Compiler = 2,
    }
    impl ErrorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ERROR_TYPE_UNSPECIFIED",
                Self::Ftl => "ERROR_TYPE_FTL",
                Self::Compiler => "ERROR_TYPE_COMPILER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ERROR_TYPE_FTL" => Some(Self::Ftl),
                "ERROR_TYPE_COMPILER" => Some(Self::Compiler),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Position {
    #[prost(string, tag="1")]
    pub filename: ::prost::alloc::string::String,
    #[prost(int64, tag="2")]
    pub line: i64,
    #[prost(int64, tag="3")]
    pub start_column: i64,
    #[prost(int64, tag="4")]
    pub end_column: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorList {
    #[prost(message, repeated, tag="1")]
    pub errors: ::prost::alloc::vec::Vec<Error>,
}
/// Request to build a module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildRequest {
    #[prost(message, optional, tag="1")]
    pub project_config: ::core::option::Option<ProjectConfig>,
    /// The path to the directory containing all module stubs. Each module stub is in a subdirectory.
    #[prost(string, tag="2")]
    pub stubs_root: ::prost::alloc::string::String,
    /// Indicates whether to watch for file changes and automatically rebuild
    #[prost(bool, tag="3")]
    pub rebuild_automatically: bool,
    #[prost(message, optional, tag="4")]
    pub build_context: ::core::option::Option<BuildContext>,
}
/// AutoRebuildStarted should be sent when the plugin decides to start rebuilding automatically.
///
/// It is not required to send this event, though it helps inform the user that their changes are not yet built.
/// FTL may ignore this event if it does not match FTL's current build context and state.
/// If the plugin decides to cancel the build because another build started, no failure or cancellation event needs
/// to be sent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoRebuildStarted {
    #[prost(string, tag="1")]
    pub context_id: ::prost::alloc::string::String,
}
/// BuildSuccess should be sent when a build succeeds.
///
/// FTL may ignore this event if it does not match FTL's current build context and state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildSuccess {
    /// The id of build context used while building.
    #[prost(string, tag="1")]
    pub context_id: ::prost::alloc::string::String,
    /// Indicates whether the build was automatically started by the plugin, rather than due to a Build rpc call.
    #[prost(bool, tag="2")]
    pub is_automatic_rebuild: bool,
    /// Module schema for the built module
    #[prost(message, optional, tag="3")]
    pub module: ::core::option::Option<super::super::schema::v1::Module>,
    /// Paths for files/directories to be deployed
    #[prost(string, repeated, tag="4")]
    pub deploy: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Name of the docker image to use for the runner
    #[prost(string, tag="5")]
    pub docker_image: ::prost::alloc::string::String,
    /// Errors contains any errors that occurred during the build
    /// No errors can have a level of ERROR, instead a BuildFailure should be sent
    /// Instead this is useful for INFO and WARN level errors.
    #[prost(message, optional, tag="6")]
    pub errors: ::core::option::Option<ErrorList>,
    /// Dev mode endpoint URI. If this is set then rather than trying to deploy the module, FTL will start a runner that
    /// connects to this endpoint.
    #[prost(string, optional, tag="7")]
    pub dev_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    /// Dev mode debug port
    #[prost(int32, optional, tag="8")]
    pub debug_port: ::core::option::Option<i32>,
    /// Dev mode hot reload endpoint, this is used to allow the runner to communicate info back to the running process
    #[prost(string, optional, tag="9")]
    pub dev_hot_reload_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag="10")]
    pub dev_hot_reload_version: ::core::option::Option<i64>,
}
/// BuildFailure should be sent when a build fails.
///
/// FTL may ignore this event if it does not match FTL's current build context and state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildFailure {
    /// The id of build context used while building.
    #[prost(string, tag="1")]
    pub context_id: ::prost::alloc::string::String,
    /// Indicates whether the build was automatically started by the plugin, rather than due to a Build rpc call.
    #[prost(bool, tag="2")]
    pub is_automatic_rebuild: bool,
    /// Errors contains any errors that occurred during the build
    #[prost(message, optional, tag="3")]
    pub errors: ::core::option::Option<ErrorList>,
    /// Indicates the plugin determined that the dependencies in the BuildContext are out of date.
    /// If a Build stream is being kept open for automatic rebuilds, FTL will call GetDependencies, followed by
    /// BuildContextUpdated.
    #[prost(bool, tag="4")]
    pub invalidate_dependencies: bool,
}
/// Every type of message that can be streamed from the language plugin for a build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuildResponse {
    #[prost(oneof="build_response::Event", tags="2, 3, 4")]
    pub event: ::core::option::Option<build_response::Event>,
}
/// Nested message and enum types in `BuildResponse`.
pub mod build_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag="2")]
        AutoRebuildStarted(super::AutoRebuildStarted),
        #[prost(message, tag="3")]
        BuildSuccess(super::BuildSuccess),
        #[prost(message, tag="4")]
        BuildFailure(super::BuildFailure),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateStubsRequest {
    /// The directory path to generate stubs into
    #[prost(string, tag="1")]
    pub dir: ::prost::alloc::string::String,
    /// The schema of the module to generate stubs for
    #[prost(message, optional, tag="2")]
    pub module: ::core::option::Option<super::super::schema::v1::Module>,
    /// The module's configuration to generate stubs for
    #[prost(message, optional, tag="3")]
    pub module_config: ::core::option::Option<ModuleConfig>,
    /// Native module configuration is the configuration for a module that uses the plugin's language, if
    /// the main moduleConfig provided is of a different language. It is provided as a mechanism to derive
    /// language specific information. For example, the language version.
    #[prost(message, optional, tag="4")]
    pub native_module_config: ::core::option::Option<ModuleConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenerateStubsResponse {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncStubReferencesRequest {
    #[prost(message, optional, tag="1")]
    pub module_config: ::core::option::Option<ModuleConfig>,
    /// The path of the directory containing all module stubs. Each module is in a subdirectory
    #[prost(string, tag="2")]
    pub stubs_root: ::prost::alloc::string::String,
    /// The names of all modules that have had stubs generated
    #[prost(string, repeated, tag="3")]
    pub modules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The complete FTL schema
    #[prost(message, optional, tag="4")]
    pub schema: ::core::option::Option<super::super::schema::v1::Schema>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SyncStubReferencesResponse {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNewModuleFlagsRequest {
    #[prost(string, tag="1")]
    pub language: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNewModuleFlagsResponse {
    #[prost(message, repeated, tag="1")]
    pub flags: ::prost::alloc::vec::Vec<get_new_module_flags_response::Flag>,
}
/// Nested message and enum types in `GetNewModuleFlagsResponse`.
pub mod get_new_module_flags_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Flag {
        #[prost(string, tag="1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub help: ::prost::alloc::string::String,
        #[prost(string, optional, tag="3")]
        pub envar: ::core::option::Option<::prost::alloc::string::String>,
        /// short must be a single character
        #[prost(string, optional, tag="4")]
        pub short: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="5")]
        pub placeholder: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="6")]
        pub default: ::core::option::Option<::prost::alloc::string::String>,
    }
}
/// Request to create a new module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewModuleRequest {
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// The root directory for the module, which does not yet exist.
    /// The plugin should create the directory.
    #[prost(string, tag="2")]
    pub dir: ::prost::alloc::string::String,
    /// The project configuration
    #[prost(message, optional, tag="3")]
    pub project_config: ::core::option::Option<ProjectConfig>,
    /// Flags contains any values set for those configured in the GetCreateModuleFlags call
    #[prost(message, optional, tag="4")]
    pub flags: ::core::option::Option<::prost_types::Struct>,
}
/// Response to a create module request.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NewModuleResponse {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModuleConfigDefaultsRequest {
    #[prost(string, tag="1")]
    pub dir: ::prost::alloc::string::String,
}
/// GetModuleConfigDefaultsResponse provides defaults for ModuleConfig.
///
/// The result may be cached by FTL, so defaulting logic should not be changing due to normal module changes.
/// For example, it is valid to return defaults based on which build tool is configured within the module directory,
/// as that is not expected to change during normal operation.
/// It is not recommended to read the module's toml file to determine defaults, as when the toml file is updated,
/// the module defaults will not be recalculated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModuleConfigDefaultsResponse {
    /// Default relative path to the directory containing all build artifacts for deployments
    #[prost(string, tag="1")]
    pub deploy_dir: ::prost::alloc::string::String,
    /// Default build command
    #[prost(string, optional, tag="2")]
    pub build: ::core::option::Option<::prost::alloc::string::String>,
    /// Dev mode build command, if different from the regular build command
    #[prost(string, optional, tag="3")]
    pub dev_mode_build: ::core::option::Option<::prost::alloc::string::String>,
    /// Build lock path to prevent concurrent builds
    #[prost(string, optional, tag="4")]
    pub build_lock: ::core::option::Option<::prost::alloc::string::String>,
    /// Default patterns to watch for file changes, relative to the module directory
    #[prost(string, repeated, tag="6")]
    pub watch: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Default language specific configuration.
    /// These defaults are filled in by looking at each root key only. If the key is not present, the default is used.
    #[prost(message, optional, tag="7")]
    pub language_config: ::core::option::Option<::prost_types::Struct>,
    /// Root directory containing SQL files.
    #[prost(string, tag="8")]
    pub sql_root_dir: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSqlInterfacesRequest {
    #[prost(message, optional, tag="1")]
    pub config: ::core::option::Option<ModuleConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSqlInterfacesResponse {
    #[prost(message, repeated, tag="1")]
    pub interfaces: ::prost::alloc::vec::Vec<get_sql_interfaces_response::Interface>,
}
/// Nested message and enum types in `GetSQLInterfacesResponse`.
pub mod get_sql_interfaces_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Interface {
        #[prost(string, tag="1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub interface: ::prost::alloc::string::String,
    }
}
// @@protoc_insertion_point(module)
