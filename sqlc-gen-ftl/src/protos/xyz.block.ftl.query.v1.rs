// @generated
// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BeginTransactionRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginTransactionResponse {
    #[prost(string, tag="1")]
    pub transaction_id: ::prost::alloc::string::String,
    #[prost(enumeration="TransactionStatus", tag="2")]
    pub status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitTransactionRequest {
    #[prost(string, tag="1")]
    pub transaction_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommitTransactionResponse {
    #[prost(enumeration="TransactionStatus", tag="1")]
    pub status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackTransactionRequest {
    #[prost(string, tag="1")]
    pub transaction_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RollbackTransactionResponse {
    #[prost(enumeration="TransactionStatus", tag="1")]
    pub status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResultColumn {
    /// The name in the FTL-generated type
    #[prost(string, tag="1")]
    pub type_name: ::prost::alloc::string::String,
    /// The database column name
    #[prost(string, tag="2")]
    pub sql_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteQueryRequest {
    #[prost(string, tag="1")]
    pub raw_sql: ::prost::alloc::string::String,
    #[prost(enumeration="CommandType", tag="2")]
    pub command_type: i32,
    /// JSON array of parameter values in order
    #[prost(string, tag="3")]
    pub parameters_json: ::prost::alloc::string::String,
    /// Column names to scan for the result type
    #[prost(message, repeated, tag="6")]
    pub result_columns: ::prost::alloc::vec::Vec<ResultColumn>,
    #[prost(string, optional, tag="4")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Default 100 if not set
    #[prost(int32, optional, tag="5")]
    pub batch_size: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteQueryResponse {
    #[prost(oneof="execute_query_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<execute_query_response::Result>,
}
/// Nested message and enum types in `ExecuteQueryResponse`.
pub mod execute_query_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// For EXEC commands
        #[prost(message, tag="1")]
        ExecResult(super::ExecResult),
        /// For ONE/MANY commands
        #[prost(message, tag="2")]
        RowResults(super::RowResults),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecResult {
    #[prost(int64, tag="1")]
    pub rows_affected: i64,
    /// Only for some databases like MySQL
    #[prost(int64, optional, tag="2")]
    pub last_insert_id: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowResults {
    /// JSON object mapping column names to values
    #[prost(string, tag="1")]
    pub json_rows: ::prost::alloc::string::String,
    /// Indicates if there are more rows to fetch
    #[prost(bool, tag="2")]
    pub has_more: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionStatus {
    Unspecified = 0,
    Success = 1,
    Failed = 2,
}
impl TransactionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TRANSACTION_STATUS_UNSPECIFIED",
            Self::Success => "TRANSACTION_STATUS_SUCCESS",
            Self::Failed => "TRANSACTION_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "TRANSACTION_STATUS_SUCCESS" => Some(Self::Success),
            "TRANSACTION_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommandType {
    Unspecified = 0,
    Exec = 1,
    One = 2,
    Many = 3,
}
impl CommandType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMMAND_TYPE_UNSPECIFIED",
            Self::Exec => "COMMAND_TYPE_EXEC",
            Self::One => "COMMAND_TYPE_ONE",
            Self::Many => "COMMAND_TYPE_MANY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMAND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "COMMAND_TYPE_EXEC" => Some(Self::Exec),
            "COMMAND_TYPE_ONE" => Some(Self::One),
            "COMMAND_TYPE_MANY" => Some(Self::Many),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
