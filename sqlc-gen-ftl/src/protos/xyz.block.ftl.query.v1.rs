// @generated
// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BeginTransactionRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BeginTransactionResponse {
    #[prost(string, tag="1")]
    pub transaction_id: ::prost::alloc::string::String,
    #[prost(enumeration="TransactionStatus", tag="2")]
    pub status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitTransactionRequest {
    #[prost(string, tag="1")]
    pub transaction_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CommitTransactionResponse {
    #[prost(enumeration="TransactionStatus", tag="1")]
    pub status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollbackTransactionRequest {
    #[prost(string, tag="1")]
    pub transaction_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RollbackTransactionResponse {
    #[prost(enumeration="TransactionStatus", tag="1")]
    pub status: i32,
}
/// A value that can be used as a SQL parameter
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlValue {
    #[prost(oneof="sql_value::Value", tags="1, 2, 3, 4, 5, 6, 7")]
    pub value: ::core::option::Option<sql_value::Value>,
}
/// Nested message and enum types in `SQLValue`.
pub mod sql_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag="1")]
        StringValue(::prost::alloc::string::String),
        #[prost(int64, tag="2")]
        IntValue(i64),
        #[prost(double, tag="3")]
        FloatValue(f64),
        #[prost(bool, tag="4")]
        BoolValue(bool),
        #[prost(bytes, tag="5")]
        BytesValue(::prost::bytes::Bytes),
        #[prost(message, tag="6")]
        TimestampValue(::prost_types::Timestamp),
        /// Set to true to represent NULL
        #[prost(bool, tag="7")]
        NullValue(bool),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteQueryRequest {
    #[prost(string, tag="1")]
    pub raw_sql: ::prost::alloc::string::String,
    #[prost(enumeration="CommandType", tag="2")]
    pub command_type: i32,
    /// SQL parameter values in order
    #[prost(message, repeated, tag="3")]
    pub parameters: ::prost::alloc::vec::Vec<SqlValue>,
    /// Column names to scan for the result type
    #[prost(string, repeated, tag="6")]
    pub result_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub transaction_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Default 100 if not set
    #[prost(int32, optional, tag="5")]
    pub batch_size: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteQueryResponse {
    #[prost(oneof="execute_query_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<execute_query_response::Result>,
}
/// Nested message and enum types in `ExecuteQueryResponse`.
pub mod execute_query_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        /// For EXEC commands
        #[prost(message, tag="1")]
        ExecResult(super::ExecResult),
        /// For ONE/MANY commands
        #[prost(message, tag="2")]
        RowResults(super::RowResults),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExecResult {
    #[prost(int64, tag="1")]
    pub rows_affected: i64,
    /// Only for some databases like MySQL
    #[prost(int64, optional, tag="2")]
    pub last_insert_id: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowResults {
    /// Each row is a map of column name to value
    #[prost(map="string, message", tag="1")]
    pub rows: ::std::collections::HashMap<::prost::alloc::string::String, SqlValue>,
    /// Indicates if there are more rows to fetch
    #[prost(bool, tag="2")]
    pub has_more: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionStatus {
    Unspecified = 0,
    Success = 1,
    Failed = 2,
}
impl TransactionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TRANSACTION_STATUS_UNSPECIFIED",
            Self::Success => "TRANSACTION_STATUS_SUCCESS",
            Self::Failed => "TRANSACTION_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "TRANSACTION_STATUS_SUCCESS" => Some(Self::Success),
            "TRANSACTION_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommandType {
    Unspecified = 0,
    Exec = 1,
    One = 2,
    Many = 3,
}
impl CommandType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMMAND_TYPE_UNSPECIFIED",
            Self::Exec => "COMMAND_TYPE_EXEC",
            Self::One => "COMMAND_TYPE_ONE",
            Self::Many => "COMMAND_TYPE_MANY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMAND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "COMMAND_TYPE_EXEC" => Some(Self::Exec),
            "COMMAND_TYPE_ONE" => Some(Self::One),
            "COMMAND_TYPE_MANY" => Some(Self::Many),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
