// Code generated by 'just lsp-generate'. DO NOT EDIT.
package lsp

var hoverMap = map[string]map[string]string{
	"//ftl:cron": {
			"go": "\n# Cron\n\nA cron job is an Empty verb that will be called on a schedule. The syntax is described [here](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/crontab.html).\n\nYou can also use a shorthand syntax for the cron job, supporting seconds (`s`), minutes (`m`), hours (`h`), and specific days of the week (e.g. `Mon`).\n\n## Examples\n\nThe following function will be called hourly:\n\n\n\n```go\n//ftl:cron 0 * * * *\nfunc Hourly(ctx context.Context) error {\n  // ...\n}\n```\n\n\nEvery 12 hours, starting at UTC midnight:\n\n\n```go\n//ftl:cron 12h\nfunc TwiceADay(ctx context.Context) error {\n  // ...\n}\n```\n\n\nEvery Monday at UTC midnight:\n\n\n```go\n//ftl:cron Mon\nfunc Mondays(ctx context.Context) error {\n  // ...\n}\n```\n\n\n",
			"java": "\n# Cron\n\nA cron job is an Empty verb that will be called on a schedule. The syntax is described [here](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/crontab.html).\n\nYou can also use a shorthand syntax for the cron job, supporting seconds (`s`), minutes (`m`), hours (`h`), and specific days of the week (e.g. `Mon`).\n\n## Examples\n\nThe following function will be called hourly:\n\n\n\n```java\nimport xyz.block.ftl.Cron;\n\nclass MyCron {\n    @Cron(\"0 * * * *\")\n    void hourly() {\n        \n    }\n}\n```\n\n\nEvery 12 hours, starting at UTC midnight:\n\n\n```java\nimport xyz.block.ftl.Cron;\n\nclass MyCron {\n    @Cron(\"12h\")\n    void twiceADay() {\n        \n    }\n}\n```\n\n\nEvery Monday at UTC midnight:\n\n\n```java\nimport xyz.block.ftl.Cron;\n\nclass MyCron {\n    @Cron(\"Mon\")\n    void mondays() {\n        \n    }\n}\n```\n\n\n",
			"kotlin": "\n# Cron\n\nA cron job is an Empty verb that will be called on a schedule. The syntax is described [here](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/crontab.html).\n\nYou can also use a shorthand syntax for the cron job, supporting seconds (`s`), minutes (`m`), hours (`h`), and specific days of the week (e.g. `Mon`).\n\n## Examples\n\nThe following function will be called hourly:\n\n\n\n```kotlin\nimport xyz.block.ftl.Cron\n\n@Cron(\"0 * * * *\")\nfun hourly() {\n    \n}\n```\n\n\nEvery 12 hours, starting at UTC midnight:\n\n\n```kotlin\nimport xyz.block.ftl.Cron\n\n@Cron(\"12h\")\nfun twiceADay() {\n    \n}\n```\n\n\nEvery Monday at UTC midnight:\n\n\n```kotlin\nimport xyz.block.ftl.Cron\n\n@Cron(\"Mon\")\nfun mondays() {\n    \n}\n```\n\n\n",
	},
	"//ftl:enum": {
			"go": "## Type enums (sum types)\n\n[Sum types](https://en.wikipedia.org/wiki/Tagged_union) are supported by FTL's type system.\n\n\nSum types aren't directly supported by Go, however they can be approximated with the use of [sealed interfaces](https://blog.chewxy.com/2018/03/18/golang-interfaces/):\n\n```go\n//ftl:enum\ntype Animal interface { animal() }\n\ntype Cat struct {}\nfunc (Cat) animal() {}\n\ntype Dog struct {}\nfunc (Dog) animal() {}\n```\n\n## Value enums\n\nA value enum is an enumerated set of string or integer values.\n\n\n```go\n//ftl:enum\ntype Colour string\n\nconst (\n  Red   Colour = \"red\"\n  Green Colour = \"green\"\n  Blue  Colour = \"blue\"\n)\n```\n\n\n",
			"java": "## Type enums (sum types)\n\n[Sum types](https://en.wikipedia.org/wiki/Tagged_union) are supported by FTL's type system.\n\n\n> TODO\n\n## Value enums\n\nA value enum is an enumerated set of string or integer values.\n\n\n```java\n@Enum\npublic enum Colour {\n  Red(\"red\"),\n  Green(\"green\"),\n  Blue(\"blue\");\n\n  private final String value;\n\n  Colour(String value) {\n    this.value = value;\n  }\n}\n```\n\n\n",
			"kotlin": "## Type enums (sum types)\n\n[Sum types](https://en.wikipedia.org/wiki/Tagged_union) are supported by FTL's type system.\n\n\nSum types aren't directly supported by Kotlin, however they can be approximated with the use of [sealed interfaces](https://kotlinlang.org/docs/sealed-classes.html):\n\n```kotlin\n@Enum\nsealed interface Animal\n\n@EnumHolder\nclass Cat() : Animal\n\n@EnumHolder\nclass Dog() : Animal\n```\n\n## Value enums\n\nA value enum is an enumerated set of string or integer values.\n\n\n```kotlin\n@Enum\npublic enum class Colour(\n  public final val `value`: String,\n) {\n  Red(\"red\"),\n  Green(\"green\"),\n  Blue(\"blue\"),\n  ;\n}\n```\n\n\n",
	},
	"//ftl:ingress": {
			"go": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\n```go\ntype GetRequestPathParams struct {\n\tUserID string `json:\"userId\"`\n}\n\ntype GetRequestQueryParams struct {\n\tPostID string `json:\"postId\"`\n}\n\ntype GetResponse struct {\n\tMessage string `json:\"msg\"`\n}\n\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, GetRequestPathParams, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\nBecause the example above only has a single path parameter it can be simplified by just using a scalar such as `string` or `int64` as the path parameter type:\n\n```go\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, int64, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\n:::info\n\nThe `req` and `resp` types of HTTP `ingress` [verbs](../reference/verbs) must be `builtin.HttpRequest` and `builtin.HttpResponse` respectively. These types provide the necessary fields for HTTP `ingress` (`headers`, `statusCode`, etc.)\n\n:::\n\nKey points:\n\n- `ingress` verbs will be automatically exported by default.\n\n### Field mapping\n\nThe `HttpRequest` request object takes 3 type parameters, the body, the path parameters and the query parameters.\n\nGiven the following request verb:\n\n```go\ntype PostBody struct{\n\tTitle string               `json:\"title\"`\n\tContent string             `json:\"content\"`\n\tTag ftl.Option[string]     `json:\"tag\"`\n}\ntype PostPathParams struct {\n\tUserID string             `json:\"userId\"`\n\tPostID string             `json:\"postId\"`\n}\n\ntype PostQueryParams struct {\n\tPublish boolean `json:\"publish\"`\n}\n\n//ftl:ingress http PUT /users/{userId}/posts/{postId}\nfunc Get(ctx context.Context, req builtin.HttpRequest[PostBody, PostPathParams, PostQueryParams]) (builtin.HttpResponse[GetResponse, string], error) {\n\treturn builtin.HttpResponse[GetResponse, string]{\n\t\tHeaders: map[string][]string{\"Get\": {\"Header from FTL\"}},\n\t\tBody: ftl.Some(GetResponse{\n\t\t\tMessage: fmt.Sprintf(\"UserID: %s, PostID: %s, Tag: %s\", req.pathParameters.UserID, req.pathParameters.PostID, req.Body.Tag.Default(\"none\")),\n\t\t}),\n\t}, nil\n}\n```\n\nThe rules for how each element is mapped are slightly different, as they have a different structure:\n\n- The body is mapped directly to the body of the request, generally as a JSON object. Scalars are also supported, as well as []byte to get the raw body. If they type is `any` then it will be assumed to be JSON and mapped to the appropriate types based on the JSON structure.\n- The path parameters can be mapped directly to an object with field names corresponding to the name of the path parameter. If there is only a single path parameter it can be injected directly as a scalar. They can also be injected as a `map[string]string`.\n- The path parameters can also be mapped directly to an object with field names corresponding to the name of the path parameter. They can also be injected directly as a `map[string]string`, or `map[string][]string` for multiple values.\n\n### Optional fields\n\nOptional fields are represented by the `ftl.Option` type. The `Option` type is a wrapper around the actual type and can be `Some` or `None`. In the example above, the `Tag` field is optional.\n\n```sh\ncurl -i http://localhost:8891/users/123/posts/456\n```\n\nBecause the `tag` query parameter is not provided, the response will be:\n\n```json\n{\n  \"msg\": \"UserID: 123, PostID: 456, Tag: none\"\n}\n```\n\n### Casing\n\nField names use lowerCamelCase by default. You can override this by using the `json` tag.\n\n### SumTypes\n\nGiven the following request verb:\n\n```go\n//ftl:enum export\ntype SumType interface {\n\ttag()\n}\n\ntype A string\n\nfunc (A) tag() {}\n\ntype B []string\n\nfunc (B) tag() {}\n\n//ftl:ingress http POST /typeenum\nfunc TypeEnum(ctx context.Context, req builtin.HttpRequest[SumType, ftl.Unit, ftl.Unit]) (builtin.HttpResponse[SumType, string], error) {\n\treturn builtin.HttpResponse[SumType, string]{Body: ftl.Some(req.Body)}, nil\n}\n```\n\nThe following curl request will map the `SumType` name and value to the `req.Body`:\n\n```sh\ncurl -X POST \"http://localhost:8891/typeenum\" \\\n     -H \"Content-Type: application/json\" \\\n     --data '{\"name\": \"A\", \"value\": \"sample\"}'\n```\n\nThe response will be:\n\n```json\n{\n  \"name\": \"A\",\n  \"value\": \"sample\"\n}\n```\n\n### Encoding query params as JSON\n\nComplex query params can also be encoded as JSON using the `@json` query parameter. For example:\n\n> `{\"tag\":\"ftl\"}` url-encoded is `%7B%22tag%22%3A%22ftl%22%7D`\n\n```bash\ncurl -i http://localhost:8891/users/123/posts/456?@json=%7B%22tag%22%3A%22ftl%22%7D\n```\n\n\n",
			"java": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nJVM Languages use the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Java. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```java\nimport java.util.List;\n\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\n\nimport jakarta.ws.rs.QueryParam; // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath; // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    public String get(@RestPath String userId, @QueryParam(\"postId\") String post) {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
			"kotlin": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nKotlin uses the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Kotlin. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```kotlin\nimport java.util.List\n\nimport jakarta.ws.rs.DELETE\nimport jakarta.ws.rs.GET\nimport jakarta.ws.rs.POST\nimport jakarta.ws.rs.PUT\nimport jakarta.ws.rs.Path\n\nimport jakarta.ws.rs.QueryParam // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    fun get(@RestPath userId: String,@QueryParam(\"postId\") post: String) : String {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
	},
	"//ftl:retry": {
			"go": "\n# Retries\n\nSome FTL features allow specifying a retry policy via a language-specific directive. Retries back off exponentially until the maximum is reached.\n\n\n\nThe directive has the following syntax:\n\n```go\n//ftl:retry [<attempts=10>] <min-backoff> [<max-backoff=1hr>] [catch <catchVerb>]\n```\n\nFor example, the following function will retry up to 10 times, with a delay of 5s, 10s, 20s, 40s, 60s, 60s, etc.\n\n```go\n//ftl:retry 10 5s 1m\nfunc Process(ctx context.Context, in Invoice) error {\n  // ...\n}\n```\n\n### PubSub Subscribers\n\nSubscribers can have a retry policy. For example:\n\n```go\n//ftl:retry 5 1s catch recoverPaymentProcessing\nfunc ProcessPayment(ctx context.Context, payment Payment) error {\n...\n}\n```\n\n### Catching\n\nAfter all retries have failed, a catch verb can be used to safely recover.\n\nThese catch verbs have a request type of `builtin.CatchRequest<Req>` and no response type. If a catch verb returns an error, it will be retried until it succeeds so it is important to handle errors carefully.\n\n```go\n//ftl:retry 5 1s catch recoverPaymentProcessing\nfunc ProcessPayment(ctx context.Context, payment Payment) error {\n...\n}\n\n//ftl:verb\nfunc RecoverPaymentProcessing(ctx context.Context, request builtin.CatchRequest[Payment]) error {\n// safely handle final failure of the payment\n}\n```\n\n\n",
			"java": "\n# Retries\n\nSome FTL features allow specifying a retry policy via a language-specific directive. Retries back off exponentially until the maximum is reached.\n\n\n\nThe directive has the following syntax:\n\n```java\n@Retry(attempts = 10, minBackoff = \"5s\", maxBackoff = \"1h\", catchVerb = \"<catchVerb>\", catchModule = \"<catchModule>\")\n```\n\nFor example, the following function will retry up to 10 times, with a delay of 5s, 10s, 20s, 40s, 60s, 60s, etc.\n\n```java\n@Retry(count = 10, minBackoff = \"5s\", maxBackoff = \"1m\")\npublic void process(Invoice in) {\n    // ... \n}\n```\n\n### PubSub Subscribers\n\nSubscribers can have a retry policy. For example:\n\n```java\n@Subscription(topic = \"example\", name = \"exampleSubscription\")\n@SubscriptionOptions(from = FromOffset.LATEST)\n@Retry(count = 5, minBackoff = \"1s\", catchVerb = \"recoverPaymentProcessing\")\npublic void processPayment(Payment payment) {\n    // ... \n}\n```\n\n### Catching\n\nAfter all retries have failed, a catch verb can be used to safely recover.\n\nThese catch verbs have a request type of `CatchRequest<Req>` and no response type. If a catch verb returns an error, it will be retried until it succeeds so it is important to handle errors carefully.\n\n```java\n@Retry(count = 5, minBackoff = \"1s\", catchVerb = \"recoverPaymentProcessing\")\npublic void processPayment(Payment payment) {\n    // ... \n}\n\n@Verb\npublic void recoverPaymentProcessing(CatchRequest<Payment> req) {\n    // safely handle final failure of the payment\n}\n```\n\n\n",
			"kotlin": "\n# Retries\n\nSome FTL features allow specifying a retry policy via a language-specific directive. Retries back off exponentially until the maximum is reached.\n\n\n\nThe directive has the following syntax:\n\n```kotlin\n@Retry(attempts = 10, minBackoff = \"5s\", maxBackoff = \"1h\", catchVerb = \"<catchVerb>\", catchModule = \"<catchModule>\")\n```\n\nFor example, the following function will retry up to 10 times, with a delay of 5s, 10s, 20s, 40s, 60s, 60s, etc.\n\n```kotlin\n@Retry(count = 10, minBackoff = \"5s\", maxBackoff = \"1m\")\nfun process(inv: Invoice) {\n    // ... \n}\n```\n\n### PubSub Subscribers\n\nSubscribers can have a retry policy. For example:\n\n```kotlin\n@Subscription(topic = \"example\", name = \"exampleSubscription\")\n@SubscriptionOptions(from = FromOffset.LATEST)\n@Retry(count = 5, minBackoff = \"1s\", catchVerb = \"recoverPaymentProcessing\")\nfun processPayment(payment: Payment) {\n    // ... \n}\n```\n\n### Catching\n\nAfter all retries have failed, a catch verb can be used to safely recover.\n\nThese catch verbs have a request type of `CatchRequest<Req>` and no response type. If a catch verb returns an error, it will be retried until it succeeds so it is important to handle errors carefully.\n\n```kotlin\n@Retry(count = 5, minBackoff = \"1s\", catchVerb = \"recoverPaymentProcessing\")\nfun processPayment(payment: Payment) {\n    // ... \n}\n\n@Verb\nfun recoverPaymentProcessing(req: CatchRequest<Payment>) {\n    // safely handle final failure of the payment\n}\n```\n\n\n",
	},
	"//ftl:subscribe": {
			"go": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```go\npackage payments\n\nimport (\n  \"github.com/block/ftl/go-runtime/ftl\"\n)\n\n// Define an event type\ntype Invoice struct {\n  InvoiceNo string\n}\n\n//ftl:topic partitions=1\ntype Invoices = ftl.TopicHandle[Invoice, ftl.SinglePartitionMap[Invoice]]\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```go\npackage payments\n\nimport (\n  \"github.com/block/ftl/go-runtime/ftl\"\n)\n\n// Define an event type\ntype Invoice struct {\n  InvoiceNo string\n}\n\ntype PartitionMapper struct{}\n\nvar _ ftl.TopicPartitionMap[PubSubEvent] = PartitionMapper{}\n\nfunc (PartitionMapper) PartitionKey(event PubSubEvent) string {\n\treturn event.Time.String()\n}\n\n//ftl:topic partitions=10\ntype Invoices = ftl.TopicHandle[Invoice, PartitionMapper]\n```\n\nNote that the name of the topic as represented in the FTL schema is the lower camel case version of the type name.\n\nThe `Invoices` type is a handle to the topic. It is a generic type that takes two arguments: the event type and the partition map type. The partition map type is used to map events to partitions.\n\nThen define a Sink to consume from the topic:\n\n```go\n// Configure initial event consumption with either from=beginning or from=latest\n//\n//ftl:subscribe payments.invoices from=beginning\nfunc SendInvoiceEmail(ctx context.Context, in Invoice) error {\n  // ...\n}\n```\n\nEvents can be published to a topic by injecting the topic type into a verb:\n\n```go\n//ftl:verb\nfunc PublishInvoice(ctx context.Context, topic Invoices) error {\n   topic.Publish(ctx, Invoice{...})\n   // ...\n}\n```\n\n\n",
			"java": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```java\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper;\nimport xyz.block.ftl.Topic;\nimport xyz.block.ftl.WriteableTopic;\n\n// Define the event type for the topic\nrecord Invoice(String invoiceNo) {\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 1)\ninterface InvoicesTopic extends WriteableTopic<Invoice, SinglePartitionMapper> {\n}\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```java\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.Topic;\nimport xyz.block.ftl.TopicPartitionMapper;\nimport xyz.block.ftl.WriteableTopic;\n\n// Define the event type for the topic\nrecord Invoice(String invoiceNo) {\n}\n\n// PartitionMapper maps each to a partition in the topic\nclass PartitionMapper implements TopicPartitionMapper<Invoice> {\n    public String getPartitionKey(Invoice invoice) {\n        return invoice.invoiceNo();\n    }\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 8)\ninterface InvoicesTopic extends WriteableTopic<Invoice, PartitionMapper> {\n}\n```\n\nEvents can be published to a topic by injecting it into an `@Verb` method:\n\n```java\n@Verb\nvoid publishInvoice(InvoiceRequest request, InvoicesTopic topic) throws Exception {\n    topic.publish(new Invoice(request.invoiceNo()));\n}\n```\n\nTo subscribe to a topic use the `@Subscription` annotation, referencing the topic class and providing a method to consume the event:\n\n```java\n// if subscribing from another module, import the event and topic\nimport ftl.othermodule.Invoice;\nimport ftl.othermodule.InvoicesTopic;\n\nimport xyz.block.ftl.FromOffset;\nimport xyz.block.ftl.Subscription;\n\nclass Subscriber {\n    @Subscription(topic = InvoicesTopic.class, from = FromOffset.LATEST)\n    public void consumeInvoice(Invoice event) {\n        // ...\n    }\n}\n```\n\nIf you are subscribing to a topic from another module, FTL will generate a topic class for you so you can subscribe to it. This generated\ntopic cannot be published to, only subscribed to:\n\n```java\n@Topic(name=\"invoices\", module=\"publisher\")\ninterface InvoicesTopic extends ConsumableTopic<Invoice> {}\n```\n\n\n",
			"kotlin": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```kotlin\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper\nimport xyz.block.ftl.Topic\nimport xyz.block.ftl.WriteableTopic\n\n// Define the event type for the topic\ndata class Invoice(val invoiceNo: String)\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 1)\ninternal interface InvoicesTopic : WriteableTopic<Invoice, SinglePartitionMapper>\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```kotlin\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper\nimport xyz.block.ftl.Topic\nimport xyz.block.ftl.TopicPartitionMapper\nimport xyz.block.ftl.WriteableTopic\n\n// Define the event type for the topic\ndata class Invoice(val invoiceNo: String)\n\n// PartitionMapper maps each to a partition in the topic\nclass PartitionMapper : TopicPartitionMapper<Invoice> {\n    override fun getPartitionKey(invoice: Invoice): String {\n        return invoice.invoiceNo\n    }\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 8)\ninternal interface InvoicesTopic : WriteableTopic<Invoice, PartitionMapper>\n```\n\nEvents can be published to a topic by injecting it into an `@Verb` method:\n\n```kotlin\n@Verb\nfun publishInvoice(request: InvoiceRequest, topic: InvoicesTopic) {\n    topic.publish(Invoice(request.invoiceNo))\n}\n```\n\nTo subscribe to a topic use the `@Subscription` annotation, referencing the topic class and providing a method to consume the event:\n\n```kotlin\n// if subscribing from another module, import the event and topic\nimport ftl.publisher.Invoice\nimport ftl.publisher.InvoicesTopic\n\nimport xyz.block.ftl.FromOffset\nimport xyz.block.ftl.Subscription\n\n@Subscription(topic = InvoicesTopic::class, from = FromOffset.LATEST)\nfun consumeInvoice(event: Invoice) {\n    // ...\n}\n```\n\nIf you are subscribing to a topic from another module, FTL will generate a topic class for you so you can subscribe to it. This generated\ntopic cannot be published to, only subscribed to:\n\n```kotlin\n@Topic(name=\"invoices\", module=\"publisher\")\ninternal interface InvoicesTopic : ConsumableTopic<Invoice>\n```\n\n\n",
	},
	"//ftl:topic": {
			"go": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```go\npackage payments\n\nimport (\n  \"github.com/block/ftl/go-runtime/ftl\"\n)\n\n// Define an event type\ntype Invoice struct {\n  InvoiceNo string\n}\n\n//ftl:topic partitions=1\ntype Invoices = ftl.TopicHandle[Invoice, ftl.SinglePartitionMap[Invoice]]\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```go\npackage payments\n\nimport (\n  \"github.com/block/ftl/go-runtime/ftl\"\n)\n\n// Define an event type\ntype Invoice struct {\n  InvoiceNo string\n}\n\ntype PartitionMapper struct{}\n\nvar _ ftl.TopicPartitionMap[PubSubEvent] = PartitionMapper{}\n\nfunc (PartitionMapper) PartitionKey(event PubSubEvent) string {\n\treturn event.Time.String()\n}\n\n//ftl:topic partitions=10\ntype Invoices = ftl.TopicHandle[Invoice, PartitionMapper]\n```\n\nNote that the name of the topic as represented in the FTL schema is the lower camel case version of the type name.\n\nThe `Invoices` type is a handle to the topic. It is a generic type that takes two arguments: the event type and the partition map type. The partition map type is used to map events to partitions.\n\nThen define a Sink to consume from the topic:\n\n```go\n// Configure initial event consumption with either from=beginning or from=latest\n//\n//ftl:subscribe payments.invoices from=beginning\nfunc SendInvoiceEmail(ctx context.Context, in Invoice) error {\n  // ...\n}\n```\n\nEvents can be published to a topic by injecting the topic type into a verb:\n\n```go\n//ftl:verb\nfunc PublishInvoice(ctx context.Context, topic Invoices) error {\n   topic.Publish(ctx, Invoice{...})\n   // ...\n}\n```\n\n\n",
			"java": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```java\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper;\nimport xyz.block.ftl.Topic;\nimport xyz.block.ftl.WriteableTopic;\n\n// Define the event type for the topic\nrecord Invoice(String invoiceNo) {\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 1)\ninterface InvoicesTopic extends WriteableTopic<Invoice, SinglePartitionMapper> {\n}\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```java\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.Topic;\nimport xyz.block.ftl.TopicPartitionMapper;\nimport xyz.block.ftl.WriteableTopic;\n\n// Define the event type for the topic\nrecord Invoice(String invoiceNo) {\n}\n\n// PartitionMapper maps each to a partition in the topic\nclass PartitionMapper implements TopicPartitionMapper<Invoice> {\n    public String getPartitionKey(Invoice invoice) {\n        return invoice.invoiceNo();\n    }\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 8)\ninterface InvoicesTopic extends WriteableTopic<Invoice, PartitionMapper> {\n}\n```\n\nEvents can be published to a topic by injecting it into an `@Verb` method:\n\n```java\n@Verb\nvoid publishInvoice(InvoiceRequest request, InvoicesTopic topic) throws Exception {\n    topic.publish(new Invoice(request.invoiceNo()));\n}\n```\n\nTo subscribe to a topic use the `@Subscription` annotation, referencing the topic class and providing a method to consume the event:\n\n```java\n// if subscribing from another module, import the event and topic\nimport ftl.othermodule.Invoice;\nimport ftl.othermodule.InvoicesTopic;\n\nimport xyz.block.ftl.FromOffset;\nimport xyz.block.ftl.Subscription;\n\nclass Subscriber {\n    @Subscription(topic = InvoicesTopic.class, from = FromOffset.LATEST)\n    public void consumeInvoice(Invoice event) {\n        // ...\n    }\n}\n```\n\nIf you are subscribing to a topic from another module, FTL will generate a topic class for you so you can subscribe to it. This generated\ntopic cannot be published to, only subscribed to:\n\n```java\n@Topic(name=\"invoices\", module=\"publisher\")\ninterface InvoicesTopic extends ConsumableTopic<Invoice> {}\n```\n\n\n",
			"kotlin": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```kotlin\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper\nimport xyz.block.ftl.Topic\nimport xyz.block.ftl.WriteableTopic\n\n// Define the event type for the topic\ndata class Invoice(val invoiceNo: String)\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 1)\ninternal interface InvoicesTopic : WriteableTopic<Invoice, SinglePartitionMapper>\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```kotlin\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper\nimport xyz.block.ftl.Topic\nimport xyz.block.ftl.TopicPartitionMapper\nimport xyz.block.ftl.WriteableTopic\n\n// Define the event type for the topic\ndata class Invoice(val invoiceNo: String)\n\n// PartitionMapper maps each to a partition in the topic\nclass PartitionMapper : TopicPartitionMapper<Invoice> {\n    override fun getPartitionKey(invoice: Invoice): String {\n        return invoice.invoiceNo\n    }\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 8)\ninternal interface InvoicesTopic : WriteableTopic<Invoice, PartitionMapper>\n```\n\nEvents can be published to a topic by injecting it into an `@Verb` method:\n\n```kotlin\n@Verb\nfun publishInvoice(request: InvoiceRequest, topic: InvoicesTopic) {\n    topic.publish(Invoice(request.invoiceNo))\n}\n```\n\nTo subscribe to a topic use the `@Subscription` annotation, referencing the topic class and providing a method to consume the event:\n\n```kotlin\n// if subscribing from another module, import the event and topic\nimport ftl.publisher.Invoice\nimport ftl.publisher.InvoicesTopic\n\nimport xyz.block.ftl.FromOffset\nimport xyz.block.ftl.Subscription\n\n@Subscription(topic = InvoicesTopic::class, from = FromOffset.LATEST)\nfun consumeInvoice(event: Invoice) {\n    // ...\n}\n```\n\nIf you are subscribing to a topic from another module, FTL will generate a topic class for you so you can subscribe to it. This generated\ntopic cannot be published to, only subscribed to:\n\n```kotlin\n@Topic(name=\"invoices\", module=\"publisher\")\ninternal interface InvoicesTopic : ConsumableTopic<Invoice>\n```\n\n\n",
	},
	"//ftl:typealias": {
			"go": "## Type aliases\n\nA type alias is an alternate name for an existing type. It can be declared like so:\n\n\n```go\n//ftl:typealias\ntype UserID string\n```\n\n\nType aliases are useful for making code more readable and type-safe by giving meaningful names to types that represent specific concepts in your domain.\n\n",
			"java": "## Type aliases\n\nA type alias is an alternate name for an existing type. It can be declared like so:\n\n\n```java\n// Java does not support type aliases directly\n// Use a wrapper class instead\npublic class UserID {\n    private final String value;\n\n    public UserID(String value) {\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n}\n```\n\n\nType aliases are useful for making code more readable and type-safe by giving meaningful names to types that represent specific concepts in your domain.\n\n",
			"kotlin": "## Type aliases\n\nA type alias is an alternate name for an existing type. It can be declared like so:\n\n\n```kotlin\ntypealias UserID = String\n```\n\n\nType aliases are useful for making code more readable and type-safe by giving meaningful names to types that represent specific concepts in your domain.\n\n",
	},
	"//ftl:verb": {
			"go": "\n# Verbs\n\n## Defining Verbs\n\n\n\nTo declare a Verb, write a normal Go function with the following signature, annotated with the Go [comment directive](https://tip.golang.org/doc/comment#syntax) `//ftl:verb`:\n\n```go\n//ftl:verb\nfunc F(context.Context, In) (Out, error) { }\n```\n\neg.\n\n```go\ntype EchoRequest struct {}\n\ntype EchoResponse struct {}\n\n//ftl:verb\nfunc Echo(ctx context.Context, in EchoRequest) (EchoResponse, error) {\n  // ...\n}\n```\n\n\nBy default verbs are only visible to other verbs in the same module (see [visibility](./visibility) for more information).\n\n## Calling Verbs\n\n\nTo call a verb, import the module's verb client (`{ModuleName}.{VerbName}Client`), add it to your verb's signature, then invoke it as a function. eg.\n\n```go\n//ftl:verb\nfunc Echo(ctx context.Context, in EchoRequest, tc time.TimeClient) (EchoResponse, error) {\n    out, err := tc(ctx, TimeRequest{...})\n}\n```\n\nVerb clients are generated by FTL. If the callee verb belongs to the same module as the caller, you must build the\nmodule first (with callee verb defined) in order to generate its client for use by the caller. Local verb clients are\navailable in the generated `types.ftl.go` file as `{VerbName}Client`.\n\n\n",
			"java": "\n# Verbs\n\n## Defining Verbs\n\n\n\nTo declare a Verb, write a normal Java method with the following signature, annotated with the `@Verb` annotation:\n\n```java\n@Verb\npublic Output f(Input input) { }\n```\n\neg.\n\n```java\nimport xyz.block.ftl.Verb;\n\nclass EchoRequest {}\n\nclass EchoResponse {}\n\npublic class EchoClass {\n    @Verb\n    public EchoResponse echo(EchoRequest request) {\n        // ...\n    }\n}\n```\n\n\nBy default verbs are only visible to other verbs in the same module (see [visibility](./visibility) for more information).\n\n## Calling Verbs\n\n\nTo call a verb, import the module's verb client, add it to your verb's signature, then call it. eg.\n\n```java\nimport ftl.time.TimeClient;\nimport xyz.block.ftl.Verb;\n\npublic class EchoClass {\n    @Verb\n    public EchoResponse echo(EchoRequest request, TimeClient time) {\n        TimeResponse response = time.call();\n        // ...\n    }\n}\n```\n\nVerb clients are generated by FTL. If the callee verb belongs to the same module as the caller, you must manually define your\nown client:\n\n```java\n@VerbClient(name=\"time\")\npublic interface TimeClient {\n    TimeResponse call();\n}\n```\n\n\n",
			"kotlin": "\n# Verbs\n\n## Defining Verbs\n\n\n\nTo declare a Verb, write a normal Kotlin function with the following signature, annotated with the Kotlin [annotation](https://kotlinlang.org/docs/annotations.html) `@Verb`:\n\n```kotlin\n@Verb\nfun F(In): Out { }\n```\n\neg.\n\n```kotlin\ndata class EchoRequest\ndata class EchoResponse\n\n@Verb\nfun echo(request: EchoRequest): EchoResponse {\n  // ...\n}\n```\n\n\nBy default verbs are only visible to other verbs in the same module (see [visibility](./visibility) for more information).\n\n## Calling Verbs\n\n\nTo call a verb, import the module's verb client, add it to your verb's signature, then `call()` it. eg.\n\n```kotlin\nimport ftl.time.TimeClient\nimport xyz.block.ftl.Verb\n\n@Verb\nfun echo(req: EchoRequest, time: TimeClient): EchoResponse {\n  val response = time.call()\n  // ...\n}\n\nval response = time.call()\n```\n\nVerb clients are generated by FTL. If the callee verb belongs to the same module as the caller, you must manually define your\nown client:\n\n```kotlin\n@VerbClient(name=\"time\")\ninterface TimeClient {\n    fun call(): TimeResponse\n}\n```\n\n\n",
	},
	"@Config": {
			"go": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nTo declare a configuration value use the following syntax:\n\n```go\n// Simple string configuration\ntype ApiUrl = ftl.Config[string]\n\n// Type-safe configuration\ntype DefaultUser = ftl.Config[Username]\n```\n\nNote that the name of the configuration value as represented in the FTL schema is the lower camel case version of the type name (e.g., `ApiUrl` becomes `apiUrl`).\n\nConfiguration values can be injected into FTL methods, such as //ftl:verb, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```go\n//ftl:verb\nfunc Hello(ctx context.Context, req Request, defaultUser DefaultUser) error {\n    username := defaultUser.Get(ctx)\n    // ...\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nDeclare a secret with the following:\n\n```go\n// Simple string secret\ntype ApiToken = ftl.Secret[string]\n\n// Type-safe secret\ntype ApiKey = ftl.Secret[Credentials]\n```\n\nLike configuration values, the name of the secret as represented in the FTL schema is the lower camel case version of the type name (e.g., `ApiToken` becomes `apiToken`).\n\nSecrets can be injected into FTL methods, such as //ftl:verb, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```go\n//ftl:verb\nfunc CallApi(ctx context.Context, req Request, apiKey ApiKey) error {\n    credentials := apiKey.Get(ctx)\n    // ...\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
			"java": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nConfiguration values can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```java\n@Export\n@Verb\nHelloResponse hello(HelloRequest helloRequest, @Config(\"defaultUser\") String defaultUser)  {\n    return new HelloResponse(\"Hello, \" + defaultUser);\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nSecrets can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```java\n@Export\n@Verb\nHelloResponse hello(HelloRequest helloRequest, @Secret(\"apiKey\") String apiKey)  {\n    return new HelloResponse(\"Hello, \" + api.call(apiKey));\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
			"kotlin": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nConfiguration values can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```kotlin\n@Export\n@Verb\nfun hello(helloRequest: HelloRequest, @Config(\"defaultUser\") defaultUser: String): HelloResponse {\n    return HelloResponse(\"Hello, $defaultUser\")\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nSecrets can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```kotlin\n@Export\n@Verb\nfun hello(helloRequest: HelloRequest, @Secret(\"apiKey\") apiKey: String): HelloResponse {\n    return HelloResponse(\"Hello, ${api.call(apiKey)}\")\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
	},
	"@Cron": {
			"go": "\n# Cron\n\nA cron job is an Empty verb that will be called on a schedule. The syntax is described [here](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/crontab.html).\n\nYou can also use a shorthand syntax for the cron job, supporting seconds (`s`), minutes (`m`), hours (`h`), and specific days of the week (e.g. `Mon`).\n\n## Examples\n\nThe following function will be called hourly:\n\n\n\n```go\n//ftl:cron 0 * * * *\nfunc Hourly(ctx context.Context) error {\n  // ...\n}\n```\n\n\nEvery 12 hours, starting at UTC midnight:\n\n\n```go\n//ftl:cron 12h\nfunc TwiceADay(ctx context.Context) error {\n  // ...\n}\n```\n\n\nEvery Monday at UTC midnight:\n\n\n```go\n//ftl:cron Mon\nfunc Mondays(ctx context.Context) error {\n  // ...\n}\n```\n\n\n",
			"java": "\n# Cron\n\nA cron job is an Empty verb that will be called on a schedule. The syntax is described [here](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/crontab.html).\n\nYou can also use a shorthand syntax for the cron job, supporting seconds (`s`), minutes (`m`), hours (`h`), and specific days of the week (e.g. `Mon`).\n\n## Examples\n\nThe following function will be called hourly:\n\n\n\n```java\nimport xyz.block.ftl.Cron;\n\nclass MyCron {\n    @Cron(\"0 * * * *\")\n    void hourly() {\n        \n    }\n}\n```\n\n\nEvery 12 hours, starting at UTC midnight:\n\n\n```java\nimport xyz.block.ftl.Cron;\n\nclass MyCron {\n    @Cron(\"12h\")\n    void twiceADay() {\n        \n    }\n}\n```\n\n\nEvery Monday at UTC midnight:\n\n\n```java\nimport xyz.block.ftl.Cron;\n\nclass MyCron {\n    @Cron(\"Mon\")\n    void mondays() {\n        \n    }\n}\n```\n\n\n",
			"kotlin": "\n# Cron\n\nA cron job is an Empty verb that will be called on a schedule. The syntax is described [here](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/crontab.html).\n\nYou can also use a shorthand syntax for the cron job, supporting seconds (`s`), minutes (`m`), hours (`h`), and specific days of the week (e.g. `Mon`).\n\n## Examples\n\nThe following function will be called hourly:\n\n\n\n```kotlin\nimport xyz.block.ftl.Cron\n\n@Cron(\"0 * * * *\")\nfun hourly() {\n    \n}\n```\n\n\nEvery 12 hours, starting at UTC midnight:\n\n\n```kotlin\nimport xyz.block.ftl.Cron\n\n@Cron(\"12h\")\nfun twiceADay() {\n    \n}\n```\n\n\nEvery Monday at UTC midnight:\n\n\n```kotlin\nimport xyz.block.ftl.Cron\n\n@Cron(\"Mon\")\nfun mondays() {\n    \n}\n```\n\n\n",
	},
	"@DELETE": {
			"go": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\n```go\ntype GetRequestPathParams struct {\n\tUserID string `json:\"userId\"`\n}\n\ntype GetRequestQueryParams struct {\n\tPostID string `json:\"postId\"`\n}\n\ntype GetResponse struct {\n\tMessage string `json:\"msg\"`\n}\n\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, GetRequestPathParams, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\nBecause the example above only has a single path parameter it can be simplified by just using a scalar such as `string` or `int64` as the path parameter type:\n\n```go\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, int64, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\n:::info\n\nThe `req` and `resp` types of HTTP `ingress` [verbs](../reference/verbs) must be `builtin.HttpRequest` and `builtin.HttpResponse` respectively. These types provide the necessary fields for HTTP `ingress` (`headers`, `statusCode`, etc.)\n\n:::\n\nKey points:\n\n- `ingress` verbs will be automatically exported by default.\n\n### Field mapping\n\nThe `HttpRequest` request object takes 3 type parameters, the body, the path parameters and the query parameters.\n\nGiven the following request verb:\n\n```go\ntype PostBody struct{\n\tTitle string               `json:\"title\"`\n\tContent string             `json:\"content\"`\n\tTag ftl.Option[string]     `json:\"tag\"`\n}\ntype PostPathParams struct {\n\tUserID string             `json:\"userId\"`\n\tPostID string             `json:\"postId\"`\n}\n\ntype PostQueryParams struct {\n\tPublish boolean `json:\"publish\"`\n}\n\n//ftl:ingress http PUT /users/{userId}/posts/{postId}\nfunc Get(ctx context.Context, req builtin.HttpRequest[PostBody, PostPathParams, PostQueryParams]) (builtin.HttpResponse[GetResponse, string], error) {\n\treturn builtin.HttpResponse[GetResponse, string]{\n\t\tHeaders: map[string][]string{\"Get\": {\"Header from FTL\"}},\n\t\tBody: ftl.Some(GetResponse{\n\t\t\tMessage: fmt.Sprintf(\"UserID: %s, PostID: %s, Tag: %s\", req.pathParameters.UserID, req.pathParameters.PostID, req.Body.Tag.Default(\"none\")),\n\t\t}),\n\t}, nil\n}\n```\n\nThe rules for how each element is mapped are slightly different, as they have a different structure:\n\n- The body is mapped directly to the body of the request, generally as a JSON object. Scalars are also supported, as well as []byte to get the raw body. If they type is `any` then it will be assumed to be JSON and mapped to the appropriate types based on the JSON structure.\n- The path parameters can be mapped directly to an object with field names corresponding to the name of the path parameter. If there is only a single path parameter it can be injected directly as a scalar. They can also be injected as a `map[string]string`.\n- The path parameters can also be mapped directly to an object with field names corresponding to the name of the path parameter. They can also be injected directly as a `map[string]string`, or `map[string][]string` for multiple values.\n\n### Optional fields\n\nOptional fields are represented by the `ftl.Option` type. The `Option` type is a wrapper around the actual type and can be `Some` or `None`. In the example above, the `Tag` field is optional.\n\n```sh\ncurl -i http://localhost:8891/users/123/posts/456\n```\n\nBecause the `tag` query parameter is not provided, the response will be:\n\n```json\n{\n  \"msg\": \"UserID: 123, PostID: 456, Tag: none\"\n}\n```\n\n### Casing\n\nField names use lowerCamelCase by default. You can override this by using the `json` tag.\n\n### SumTypes\n\nGiven the following request verb:\n\n```go\n//ftl:enum export\ntype SumType interface {\n\ttag()\n}\n\ntype A string\n\nfunc (A) tag() {}\n\ntype B []string\n\nfunc (B) tag() {}\n\n//ftl:ingress http POST /typeenum\nfunc TypeEnum(ctx context.Context, req builtin.HttpRequest[SumType, ftl.Unit, ftl.Unit]) (builtin.HttpResponse[SumType, string], error) {\n\treturn builtin.HttpResponse[SumType, string]{Body: ftl.Some(req.Body)}, nil\n}\n```\n\nThe following curl request will map the `SumType` name and value to the `req.Body`:\n\n```sh\ncurl -X POST \"http://localhost:8891/typeenum\" \\\n     -H \"Content-Type: application/json\" \\\n     --data '{\"name\": \"A\", \"value\": \"sample\"}'\n```\n\nThe response will be:\n\n```json\n{\n  \"name\": \"A\",\n  \"value\": \"sample\"\n}\n```\n\n### Encoding query params as JSON\n\nComplex query params can also be encoded as JSON using the `@json` query parameter. For example:\n\n> `{\"tag\":\"ftl\"}` url-encoded is `%7B%22tag%22%3A%22ftl%22%7D`\n\n```bash\ncurl -i http://localhost:8891/users/123/posts/456?@json=%7B%22tag%22%3A%22ftl%22%7D\n```\n\n\n",
			"java": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nJVM Languages use the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Java. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```java\nimport java.util.List;\n\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\n\nimport jakarta.ws.rs.QueryParam; // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath; // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    public String get(@RestPath String userId, @QueryParam(\"postId\") String post) {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
			"kotlin": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nKotlin uses the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Kotlin. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```kotlin\nimport java.util.List\n\nimport jakarta.ws.rs.DELETE\nimport jakarta.ws.rs.GET\nimport jakarta.ws.rs.POST\nimport jakarta.ws.rs.PUT\nimport jakarta.ws.rs.Path\n\nimport jakarta.ws.rs.QueryParam // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    fun get(@RestPath userId: String,@QueryParam(\"postId\") post: String) : String {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
	},
	"@Enum": {
			"go": "## Type enums (sum types)\n\n[Sum types](https://en.wikipedia.org/wiki/Tagged_union) are supported by FTL's type system.\n\n\nSum types aren't directly supported by Go, however they can be approximated with the use of [sealed interfaces](https://blog.chewxy.com/2018/03/18/golang-interfaces/):\n\n```go\n//ftl:enum\ntype Animal interface { animal() }\n\ntype Cat struct {}\nfunc (Cat) animal() {}\n\ntype Dog struct {}\nfunc (Dog) animal() {}\n```\n\n## Value enums\n\nA value enum is an enumerated set of string or integer values.\n\n\n```go\n//ftl:enum\ntype Colour string\n\nconst (\n  Red   Colour = \"red\"\n  Green Colour = \"green\"\n  Blue  Colour = \"blue\"\n)\n```\n\n\n",
			"java": "## Type enums (sum types)\n\n[Sum types](https://en.wikipedia.org/wiki/Tagged_union) are supported by FTL's type system.\n\n\n> TODO\n\n## Value enums\n\nA value enum is an enumerated set of string or integer values.\n\n\n```java\n@Enum\npublic enum Colour {\n  Red(\"red\"),\n  Green(\"green\"),\n  Blue(\"blue\");\n\n  private final String value;\n\n  Colour(String value) {\n    this.value = value;\n  }\n}\n```\n\n\n",
			"kotlin": "## Type enums (sum types)\n\n[Sum types](https://en.wikipedia.org/wiki/Tagged_union) are supported by FTL's type system.\n\n\nSum types aren't directly supported by Kotlin, however they can be approximated with the use of [sealed interfaces](https://kotlinlang.org/docs/sealed-classes.html):\n\n```kotlin\n@Enum\nsealed interface Animal\n\n@EnumHolder\nclass Cat() : Animal\n\n@EnumHolder\nclass Dog() : Animal\n```\n\n## Value enums\n\nA value enum is an enumerated set of string or integer values.\n\n\n```kotlin\n@Enum\npublic enum class Colour(\n  public final val `value`: String,\n) {\n  Red(\"red\"),\n  Green(\"green\"),\n  Blue(\"blue\"),\n  ;\n}\n```\n\n\n",
	},
	"@Export": {
			"go": "\n# Visibility\n\nBy default all declarations in FTL are visible only to the module they're declared in. The implicit visibility of types is that of the first verb or other declaration that references it.\n\n## Exporting declarations\n\nExporting a declaration makes it accessible to other modules. Some declarations that are entirely local to a module, such as secrets/config, cannot be exported.\n\nTypes that are transitively referenced by an exported declaration will be automatically exported unless they were already defined but unexported. In this case, an error will be raised and the type must be explicitly exported.\n\n\n\nThe following table describes the go directives used to export the corresponding declaration:\n\n| Symbol        | Export syntax            |\n| ------------- | ------------------------ |\n| Verb          | `//ftl:verb export`      |\n| Data          | `//ftl:data export`      |\n| Enum/Sum type | `//ftl:enum export`      |\n| Typealias     | `//ftl:typealias export` |\n| Topic         | `//ftl:export` [^1]      |\n\n```go\n//ftl:verb export\nfunc Verb(ctx context.Context, in In) (Out, error)\n\n//ftl:typealias export\ntype UserID string\n```\n\n[^1]: By default, topics do not require any annotations as the declaration itself is sufficient.\n\n\n",
			"java": "\n# Visibility\n\nBy default all declarations in FTL are visible only to the module they're declared in. The implicit visibility of types is that of the first verb or other declaration that references it.\n\n## Exporting declarations\n\nExporting a declaration makes it accessible to other modules. Some declarations that are entirely local to a module, such as secrets/config, cannot be exported.\n\nTypes that are transitively referenced by an exported declaration will be automatically exported unless they were already defined but unexported. In this case, an error will be raised and the type must be explicitly exported.\n\n\n\nFor Java the `@Export` annotation can be used to export a declaration:\n\n```java\n@Verb\n@Export\nTimeResponse time()  {\n    // ...\n}\n```\n\n\n",
			"kotlin": "\n# Visibility\n\nBy default all declarations in FTL are visible only to the module they're declared in. The implicit visibility of types is that of the first verb or other declaration that references it.\n\n## Exporting declarations\n\nExporting a declaration makes it accessible to other modules. Some declarations that are entirely local to a module, such as secrets/config, cannot be exported.\n\nTypes that are transitively referenced by an exported declaration will be automatically exported unless they were already defined but unexported. In this case, an error will be raised and the type must be explicitly exported.\n\n\n\nFor Kotlin the `@Export` annotation can be used to export a declaration:\n\n```kotlin\n@Verb\n@Export\nfun time(): TimeResponse {\n    // ...\n}\n```\n\n\n",
	},
	"@GET": {
			"go": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\n```go\ntype GetRequestPathParams struct {\n\tUserID string `json:\"userId\"`\n}\n\ntype GetRequestQueryParams struct {\n\tPostID string `json:\"postId\"`\n}\n\ntype GetResponse struct {\n\tMessage string `json:\"msg\"`\n}\n\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, GetRequestPathParams, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\nBecause the example above only has a single path parameter it can be simplified by just using a scalar such as `string` or `int64` as the path parameter type:\n\n```go\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, int64, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\n:::info\n\nThe `req` and `resp` types of HTTP `ingress` [verbs](../reference/verbs) must be `builtin.HttpRequest` and `builtin.HttpResponse` respectively. These types provide the necessary fields for HTTP `ingress` (`headers`, `statusCode`, etc.)\n\n:::\n\nKey points:\n\n- `ingress` verbs will be automatically exported by default.\n\n### Field mapping\n\nThe `HttpRequest` request object takes 3 type parameters, the body, the path parameters and the query parameters.\n\nGiven the following request verb:\n\n```go\ntype PostBody struct{\n\tTitle string               `json:\"title\"`\n\tContent string             `json:\"content\"`\n\tTag ftl.Option[string]     `json:\"tag\"`\n}\ntype PostPathParams struct {\n\tUserID string             `json:\"userId\"`\n\tPostID string             `json:\"postId\"`\n}\n\ntype PostQueryParams struct {\n\tPublish boolean `json:\"publish\"`\n}\n\n//ftl:ingress http PUT /users/{userId}/posts/{postId}\nfunc Get(ctx context.Context, req builtin.HttpRequest[PostBody, PostPathParams, PostQueryParams]) (builtin.HttpResponse[GetResponse, string], error) {\n\treturn builtin.HttpResponse[GetResponse, string]{\n\t\tHeaders: map[string][]string{\"Get\": {\"Header from FTL\"}},\n\t\tBody: ftl.Some(GetResponse{\n\t\t\tMessage: fmt.Sprintf(\"UserID: %s, PostID: %s, Tag: %s\", req.pathParameters.UserID, req.pathParameters.PostID, req.Body.Tag.Default(\"none\")),\n\t\t}),\n\t}, nil\n}\n```\n\nThe rules for how each element is mapped are slightly different, as they have a different structure:\n\n- The body is mapped directly to the body of the request, generally as a JSON object. Scalars are also supported, as well as []byte to get the raw body. If they type is `any` then it will be assumed to be JSON and mapped to the appropriate types based on the JSON structure.\n- The path parameters can be mapped directly to an object with field names corresponding to the name of the path parameter. If there is only a single path parameter it can be injected directly as a scalar. They can also be injected as a `map[string]string`.\n- The path parameters can also be mapped directly to an object with field names corresponding to the name of the path parameter. They can also be injected directly as a `map[string]string`, or `map[string][]string` for multiple values.\n\n### Optional fields\n\nOptional fields are represented by the `ftl.Option` type. The `Option` type is a wrapper around the actual type and can be `Some` or `None`. In the example above, the `Tag` field is optional.\n\n```sh\ncurl -i http://localhost:8891/users/123/posts/456\n```\n\nBecause the `tag` query parameter is not provided, the response will be:\n\n```json\n{\n  \"msg\": \"UserID: 123, PostID: 456, Tag: none\"\n}\n```\n\n### Casing\n\nField names use lowerCamelCase by default. You can override this by using the `json` tag.\n\n### SumTypes\n\nGiven the following request verb:\n\n```go\n//ftl:enum export\ntype SumType interface {\n\ttag()\n}\n\ntype A string\n\nfunc (A) tag() {}\n\ntype B []string\n\nfunc (B) tag() {}\n\n//ftl:ingress http POST /typeenum\nfunc TypeEnum(ctx context.Context, req builtin.HttpRequest[SumType, ftl.Unit, ftl.Unit]) (builtin.HttpResponse[SumType, string], error) {\n\treturn builtin.HttpResponse[SumType, string]{Body: ftl.Some(req.Body)}, nil\n}\n```\n\nThe following curl request will map the `SumType` name and value to the `req.Body`:\n\n```sh\ncurl -X POST \"http://localhost:8891/typeenum\" \\\n     -H \"Content-Type: application/json\" \\\n     --data '{\"name\": \"A\", \"value\": \"sample\"}'\n```\n\nThe response will be:\n\n```json\n{\n  \"name\": \"A\",\n  \"value\": \"sample\"\n}\n```\n\n### Encoding query params as JSON\n\nComplex query params can also be encoded as JSON using the `@json` query parameter. For example:\n\n> `{\"tag\":\"ftl\"}` url-encoded is `%7B%22tag%22%3A%22ftl%22%7D`\n\n```bash\ncurl -i http://localhost:8891/users/123/posts/456?@json=%7B%22tag%22%3A%22ftl%22%7D\n```\n\n\n",
			"java": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nJVM Languages use the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Java. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```java\nimport java.util.List;\n\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\n\nimport jakarta.ws.rs.QueryParam; // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath; // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    public String get(@RestPath String userId, @QueryParam(\"postId\") String post) {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
			"kotlin": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nKotlin uses the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Kotlin. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```kotlin\nimport java.util.List\n\nimport jakarta.ws.rs.DELETE\nimport jakarta.ws.rs.GET\nimport jakarta.ws.rs.POST\nimport jakarta.ws.rs.PUT\nimport jakarta.ws.rs.Path\n\nimport jakarta.ws.rs.QueryParam // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    fun get(@RestPath userId: String,@QueryParam(\"postId\") post: String) : String {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
	},
	"@POST": {
			"go": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\n```go\ntype GetRequestPathParams struct {\n\tUserID string `json:\"userId\"`\n}\n\ntype GetRequestQueryParams struct {\n\tPostID string `json:\"postId\"`\n}\n\ntype GetResponse struct {\n\tMessage string `json:\"msg\"`\n}\n\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, GetRequestPathParams, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\nBecause the example above only has a single path parameter it can be simplified by just using a scalar such as `string` or `int64` as the path parameter type:\n\n```go\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, int64, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\n:::info\n\nThe `req` and `resp` types of HTTP `ingress` [verbs](../reference/verbs) must be `builtin.HttpRequest` and `builtin.HttpResponse` respectively. These types provide the necessary fields for HTTP `ingress` (`headers`, `statusCode`, etc.)\n\n:::\n\nKey points:\n\n- `ingress` verbs will be automatically exported by default.\n\n### Field mapping\n\nThe `HttpRequest` request object takes 3 type parameters, the body, the path parameters and the query parameters.\n\nGiven the following request verb:\n\n```go\ntype PostBody struct{\n\tTitle string               `json:\"title\"`\n\tContent string             `json:\"content\"`\n\tTag ftl.Option[string]     `json:\"tag\"`\n}\ntype PostPathParams struct {\n\tUserID string             `json:\"userId\"`\n\tPostID string             `json:\"postId\"`\n}\n\ntype PostQueryParams struct {\n\tPublish boolean `json:\"publish\"`\n}\n\n//ftl:ingress http PUT /users/{userId}/posts/{postId}\nfunc Get(ctx context.Context, req builtin.HttpRequest[PostBody, PostPathParams, PostQueryParams]) (builtin.HttpResponse[GetResponse, string], error) {\n\treturn builtin.HttpResponse[GetResponse, string]{\n\t\tHeaders: map[string][]string{\"Get\": {\"Header from FTL\"}},\n\t\tBody: ftl.Some(GetResponse{\n\t\t\tMessage: fmt.Sprintf(\"UserID: %s, PostID: %s, Tag: %s\", req.pathParameters.UserID, req.pathParameters.PostID, req.Body.Tag.Default(\"none\")),\n\t\t}),\n\t}, nil\n}\n```\n\nThe rules for how each element is mapped are slightly different, as they have a different structure:\n\n- The body is mapped directly to the body of the request, generally as a JSON object. Scalars are also supported, as well as []byte to get the raw body. If they type is `any` then it will be assumed to be JSON and mapped to the appropriate types based on the JSON structure.\n- The path parameters can be mapped directly to an object with field names corresponding to the name of the path parameter. If there is only a single path parameter it can be injected directly as a scalar. They can also be injected as a `map[string]string`.\n- The path parameters can also be mapped directly to an object with field names corresponding to the name of the path parameter. They can also be injected directly as a `map[string]string`, or `map[string][]string` for multiple values.\n\n### Optional fields\n\nOptional fields are represented by the `ftl.Option` type. The `Option` type is a wrapper around the actual type and can be `Some` or `None`. In the example above, the `Tag` field is optional.\n\n```sh\ncurl -i http://localhost:8891/users/123/posts/456\n```\n\nBecause the `tag` query parameter is not provided, the response will be:\n\n```json\n{\n  \"msg\": \"UserID: 123, PostID: 456, Tag: none\"\n}\n```\n\n### Casing\n\nField names use lowerCamelCase by default. You can override this by using the `json` tag.\n\n### SumTypes\n\nGiven the following request verb:\n\n```go\n//ftl:enum export\ntype SumType interface {\n\ttag()\n}\n\ntype A string\n\nfunc (A) tag() {}\n\ntype B []string\n\nfunc (B) tag() {}\n\n//ftl:ingress http POST /typeenum\nfunc TypeEnum(ctx context.Context, req builtin.HttpRequest[SumType, ftl.Unit, ftl.Unit]) (builtin.HttpResponse[SumType, string], error) {\n\treturn builtin.HttpResponse[SumType, string]{Body: ftl.Some(req.Body)}, nil\n}\n```\n\nThe following curl request will map the `SumType` name and value to the `req.Body`:\n\n```sh\ncurl -X POST \"http://localhost:8891/typeenum\" \\\n     -H \"Content-Type: application/json\" \\\n     --data '{\"name\": \"A\", \"value\": \"sample\"}'\n```\n\nThe response will be:\n\n```json\n{\n  \"name\": \"A\",\n  \"value\": \"sample\"\n}\n```\n\n### Encoding query params as JSON\n\nComplex query params can also be encoded as JSON using the `@json` query parameter. For example:\n\n> `{\"tag\":\"ftl\"}` url-encoded is `%7B%22tag%22%3A%22ftl%22%7D`\n\n```bash\ncurl -i http://localhost:8891/users/123/posts/456?@json=%7B%22tag%22%3A%22ftl%22%7D\n```\n\n\n",
			"java": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nJVM Languages use the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Java. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```java\nimport java.util.List;\n\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\n\nimport jakarta.ws.rs.QueryParam; // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath; // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    public String get(@RestPath String userId, @QueryParam(\"postId\") String post) {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
			"kotlin": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nKotlin uses the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Kotlin. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```kotlin\nimport java.util.List\n\nimport jakarta.ws.rs.DELETE\nimport jakarta.ws.rs.GET\nimport jakarta.ws.rs.POST\nimport jakarta.ws.rs.PUT\nimport jakarta.ws.rs.Path\n\nimport jakarta.ws.rs.QueryParam // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    fun get(@RestPath userId: String,@QueryParam(\"postId\") post: String) : String {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
	},
	"@PUT": {
			"go": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\n```go\ntype GetRequestPathParams struct {\n\tUserID string `json:\"userId\"`\n}\n\ntype GetRequestQueryParams struct {\n\tPostID string `json:\"postId\"`\n}\n\ntype GetResponse struct {\n\tMessage string `json:\"msg\"`\n}\n\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, GetRequestPathParams, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\nBecause the example above only has a single path parameter it can be simplified by just using a scalar such as `string` or `int64` as the path parameter type:\n\n```go\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, int64, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\n:::info\n\nThe `req` and `resp` types of HTTP `ingress` [verbs](../reference/verbs) must be `builtin.HttpRequest` and `builtin.HttpResponse` respectively. These types provide the necessary fields for HTTP `ingress` (`headers`, `statusCode`, etc.)\n\n:::\n\nKey points:\n\n- `ingress` verbs will be automatically exported by default.\n\n### Field mapping\n\nThe `HttpRequest` request object takes 3 type parameters, the body, the path parameters and the query parameters.\n\nGiven the following request verb:\n\n```go\ntype PostBody struct{\n\tTitle string               `json:\"title\"`\n\tContent string             `json:\"content\"`\n\tTag ftl.Option[string]     `json:\"tag\"`\n}\ntype PostPathParams struct {\n\tUserID string             `json:\"userId\"`\n\tPostID string             `json:\"postId\"`\n}\n\ntype PostQueryParams struct {\n\tPublish boolean `json:\"publish\"`\n}\n\n//ftl:ingress http PUT /users/{userId}/posts/{postId}\nfunc Get(ctx context.Context, req builtin.HttpRequest[PostBody, PostPathParams, PostQueryParams]) (builtin.HttpResponse[GetResponse, string], error) {\n\treturn builtin.HttpResponse[GetResponse, string]{\n\t\tHeaders: map[string][]string{\"Get\": {\"Header from FTL\"}},\n\t\tBody: ftl.Some(GetResponse{\n\t\t\tMessage: fmt.Sprintf(\"UserID: %s, PostID: %s, Tag: %s\", req.pathParameters.UserID, req.pathParameters.PostID, req.Body.Tag.Default(\"none\")),\n\t\t}),\n\t}, nil\n}\n```\n\nThe rules for how each element is mapped are slightly different, as they have a different structure:\n\n- The body is mapped directly to the body of the request, generally as a JSON object. Scalars are also supported, as well as []byte to get the raw body. If they type is `any` then it will be assumed to be JSON and mapped to the appropriate types based on the JSON structure.\n- The path parameters can be mapped directly to an object with field names corresponding to the name of the path parameter. If there is only a single path parameter it can be injected directly as a scalar. They can also be injected as a `map[string]string`.\n- The path parameters can also be mapped directly to an object with field names corresponding to the name of the path parameter. They can also be injected directly as a `map[string]string`, or `map[string][]string` for multiple values.\n\n### Optional fields\n\nOptional fields are represented by the `ftl.Option` type. The `Option` type is a wrapper around the actual type and can be `Some` or `None`. In the example above, the `Tag` field is optional.\n\n```sh\ncurl -i http://localhost:8891/users/123/posts/456\n```\n\nBecause the `tag` query parameter is not provided, the response will be:\n\n```json\n{\n  \"msg\": \"UserID: 123, PostID: 456, Tag: none\"\n}\n```\n\n### Casing\n\nField names use lowerCamelCase by default. You can override this by using the `json` tag.\n\n### SumTypes\n\nGiven the following request verb:\n\n```go\n//ftl:enum export\ntype SumType interface {\n\ttag()\n}\n\ntype A string\n\nfunc (A) tag() {}\n\ntype B []string\n\nfunc (B) tag() {}\n\n//ftl:ingress http POST /typeenum\nfunc TypeEnum(ctx context.Context, req builtin.HttpRequest[SumType, ftl.Unit, ftl.Unit]) (builtin.HttpResponse[SumType, string], error) {\n\treturn builtin.HttpResponse[SumType, string]{Body: ftl.Some(req.Body)}, nil\n}\n```\n\nThe following curl request will map the `SumType` name and value to the `req.Body`:\n\n```sh\ncurl -X POST \"http://localhost:8891/typeenum\" \\\n     -H \"Content-Type: application/json\" \\\n     --data '{\"name\": \"A\", \"value\": \"sample\"}'\n```\n\nThe response will be:\n\n```json\n{\n  \"name\": \"A\",\n  \"value\": \"sample\"\n}\n```\n\n### Encoding query params as JSON\n\nComplex query params can also be encoded as JSON using the `@json` query parameter. For example:\n\n> `{\"tag\":\"ftl\"}` url-encoded is `%7B%22tag%22%3A%22ftl%22%7D`\n\n```bash\ncurl -i http://localhost:8891/users/123/posts/456?@json=%7B%22tag%22%3A%22ftl%22%7D\n```\n\n\n",
			"java": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nJVM Languages use the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Java. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```java\nimport java.util.List;\n\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\n\nimport jakarta.ws.rs.QueryParam; // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath; // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    public String get(@RestPath String userId, @QueryParam(\"postId\") String post) {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
			"kotlin": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nKotlin uses the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Kotlin. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```kotlin\nimport java.util.List\n\nimport jakarta.ws.rs.DELETE\nimport jakarta.ws.rs.GET\nimport jakarta.ws.rs.POST\nimport jakarta.ws.rs.PUT\nimport jakarta.ws.rs.Path\n\nimport jakarta.ws.rs.QueryParam // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    fun get(@RestPath userId: String,@QueryParam(\"postId\") post: String) : String {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
	},
	"@Path": {
			"go": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\n```go\ntype GetRequestPathParams struct {\n\tUserID string `json:\"userId\"`\n}\n\ntype GetRequestQueryParams struct {\n\tPostID string `json:\"postId\"`\n}\n\ntype GetResponse struct {\n\tMessage string `json:\"msg\"`\n}\n\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, GetRequestPathParams, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\nBecause the example above only has a single path parameter it can be simplified by just using a scalar such as `string` or `int64` as the path parameter type:\n\n```go\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, int64, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\n:::info\n\nThe `req` and `resp` types of HTTP `ingress` [verbs](../reference/verbs) must be `builtin.HttpRequest` and `builtin.HttpResponse` respectively. These types provide the necessary fields for HTTP `ingress` (`headers`, `statusCode`, etc.)\n\n:::\n\nKey points:\n\n- `ingress` verbs will be automatically exported by default.\n\n### Field mapping\n\nThe `HttpRequest` request object takes 3 type parameters, the body, the path parameters and the query parameters.\n\nGiven the following request verb:\n\n```go\ntype PostBody struct{\n\tTitle string               `json:\"title\"`\n\tContent string             `json:\"content\"`\n\tTag ftl.Option[string]     `json:\"tag\"`\n}\ntype PostPathParams struct {\n\tUserID string             `json:\"userId\"`\n\tPostID string             `json:\"postId\"`\n}\n\ntype PostQueryParams struct {\n\tPublish boolean `json:\"publish\"`\n}\n\n//ftl:ingress http PUT /users/{userId}/posts/{postId}\nfunc Get(ctx context.Context, req builtin.HttpRequest[PostBody, PostPathParams, PostQueryParams]) (builtin.HttpResponse[GetResponse, string], error) {\n\treturn builtin.HttpResponse[GetResponse, string]{\n\t\tHeaders: map[string][]string{\"Get\": {\"Header from FTL\"}},\n\t\tBody: ftl.Some(GetResponse{\n\t\t\tMessage: fmt.Sprintf(\"UserID: %s, PostID: %s, Tag: %s\", req.pathParameters.UserID, req.pathParameters.PostID, req.Body.Tag.Default(\"none\")),\n\t\t}),\n\t}, nil\n}\n```\n\nThe rules for how each element is mapped are slightly different, as they have a different structure:\n\n- The body is mapped directly to the body of the request, generally as a JSON object. Scalars are also supported, as well as []byte to get the raw body. If they type is `any` then it will be assumed to be JSON and mapped to the appropriate types based on the JSON structure.\n- The path parameters can be mapped directly to an object with field names corresponding to the name of the path parameter. If there is only a single path parameter it can be injected directly as a scalar. They can also be injected as a `map[string]string`.\n- The path parameters can also be mapped directly to an object with field names corresponding to the name of the path parameter. They can also be injected directly as a `map[string]string`, or `map[string][]string` for multiple values.\n\n### Optional fields\n\nOptional fields are represented by the `ftl.Option` type. The `Option` type is a wrapper around the actual type and can be `Some` or `None`. In the example above, the `Tag` field is optional.\n\n```sh\ncurl -i http://localhost:8891/users/123/posts/456\n```\n\nBecause the `tag` query parameter is not provided, the response will be:\n\n```json\n{\n  \"msg\": \"UserID: 123, PostID: 456, Tag: none\"\n}\n```\n\n### Casing\n\nField names use lowerCamelCase by default. You can override this by using the `json` tag.\n\n### SumTypes\n\nGiven the following request verb:\n\n```go\n//ftl:enum export\ntype SumType interface {\n\ttag()\n}\n\ntype A string\n\nfunc (A) tag() {}\n\ntype B []string\n\nfunc (B) tag() {}\n\n//ftl:ingress http POST /typeenum\nfunc TypeEnum(ctx context.Context, req builtin.HttpRequest[SumType, ftl.Unit, ftl.Unit]) (builtin.HttpResponse[SumType, string], error) {\n\treturn builtin.HttpResponse[SumType, string]{Body: ftl.Some(req.Body)}, nil\n}\n```\n\nThe following curl request will map the `SumType` name and value to the `req.Body`:\n\n```sh\ncurl -X POST \"http://localhost:8891/typeenum\" \\\n     -H \"Content-Type: application/json\" \\\n     --data '{\"name\": \"A\", \"value\": \"sample\"}'\n```\n\nThe response will be:\n\n```json\n{\n  \"name\": \"A\",\n  \"value\": \"sample\"\n}\n```\n\n### Encoding query params as JSON\n\nComplex query params can also be encoded as JSON using the `@json` query parameter. For example:\n\n> `{\"tag\":\"ftl\"}` url-encoded is `%7B%22tag%22%3A%22ftl%22%7D`\n\n```bash\ncurl -i http://localhost:8891/users/123/posts/456?@json=%7B%22tag%22%3A%22ftl%22%7D\n```\n\n\n",
			"java": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nJVM Languages use the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Java. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```java\nimport java.util.List;\n\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\n\nimport jakarta.ws.rs.QueryParam; // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath; // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    public String get(@RestPath String userId, @QueryParam(\"postId\") String post) {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
			"kotlin": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nKotlin uses the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Kotlin. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```kotlin\nimport java.util.List\n\nimport jakarta.ws.rs.DELETE\nimport jakarta.ws.rs.GET\nimport jakarta.ws.rs.POST\nimport jakarta.ws.rs.PUT\nimport jakarta.ws.rs.Path\n\nimport jakarta.ws.rs.QueryParam // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    fun get(@RestPath userId: String,@QueryParam(\"postId\") post: String) : String {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
	},
	"@QueryParam": {
			"go": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\n```go\ntype GetRequestPathParams struct {\n\tUserID string `json:\"userId\"`\n}\n\ntype GetRequestQueryParams struct {\n\tPostID string `json:\"postId\"`\n}\n\ntype GetResponse struct {\n\tMessage string `json:\"msg\"`\n}\n\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, GetRequestPathParams, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\nBecause the example above only has a single path parameter it can be simplified by just using a scalar such as `string` or `int64` as the path parameter type:\n\n```go\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, int64, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\n:::info\n\nThe `req` and `resp` types of HTTP `ingress` [verbs](../reference/verbs) must be `builtin.HttpRequest` and `builtin.HttpResponse` respectively. These types provide the necessary fields for HTTP `ingress` (`headers`, `statusCode`, etc.)\n\n:::\n\nKey points:\n\n- `ingress` verbs will be automatically exported by default.\n\n### Field mapping\n\nThe `HttpRequest` request object takes 3 type parameters, the body, the path parameters and the query parameters.\n\nGiven the following request verb:\n\n```go\ntype PostBody struct{\n\tTitle string               `json:\"title\"`\n\tContent string             `json:\"content\"`\n\tTag ftl.Option[string]     `json:\"tag\"`\n}\ntype PostPathParams struct {\n\tUserID string             `json:\"userId\"`\n\tPostID string             `json:\"postId\"`\n}\n\ntype PostQueryParams struct {\n\tPublish boolean `json:\"publish\"`\n}\n\n//ftl:ingress http PUT /users/{userId}/posts/{postId}\nfunc Get(ctx context.Context, req builtin.HttpRequest[PostBody, PostPathParams, PostQueryParams]) (builtin.HttpResponse[GetResponse, string], error) {\n\treturn builtin.HttpResponse[GetResponse, string]{\n\t\tHeaders: map[string][]string{\"Get\": {\"Header from FTL\"}},\n\t\tBody: ftl.Some(GetResponse{\n\t\t\tMessage: fmt.Sprintf(\"UserID: %s, PostID: %s, Tag: %s\", req.pathParameters.UserID, req.pathParameters.PostID, req.Body.Tag.Default(\"none\")),\n\t\t}),\n\t}, nil\n}\n```\n\nThe rules for how each element is mapped are slightly different, as they have a different structure:\n\n- The body is mapped directly to the body of the request, generally as a JSON object. Scalars are also supported, as well as []byte to get the raw body. If they type is `any` then it will be assumed to be JSON and mapped to the appropriate types based on the JSON structure.\n- The path parameters can be mapped directly to an object with field names corresponding to the name of the path parameter. If there is only a single path parameter it can be injected directly as a scalar. They can also be injected as a `map[string]string`.\n- The path parameters can also be mapped directly to an object with field names corresponding to the name of the path parameter. They can also be injected directly as a `map[string]string`, or `map[string][]string` for multiple values.\n\n### Optional fields\n\nOptional fields are represented by the `ftl.Option` type. The `Option` type is a wrapper around the actual type and can be `Some` or `None`. In the example above, the `Tag` field is optional.\n\n```sh\ncurl -i http://localhost:8891/users/123/posts/456\n```\n\nBecause the `tag` query parameter is not provided, the response will be:\n\n```json\n{\n  \"msg\": \"UserID: 123, PostID: 456, Tag: none\"\n}\n```\n\n### Casing\n\nField names use lowerCamelCase by default. You can override this by using the `json` tag.\n\n### SumTypes\n\nGiven the following request verb:\n\n```go\n//ftl:enum export\ntype SumType interface {\n\ttag()\n}\n\ntype A string\n\nfunc (A) tag() {}\n\ntype B []string\n\nfunc (B) tag() {}\n\n//ftl:ingress http POST /typeenum\nfunc TypeEnum(ctx context.Context, req builtin.HttpRequest[SumType, ftl.Unit, ftl.Unit]) (builtin.HttpResponse[SumType, string], error) {\n\treturn builtin.HttpResponse[SumType, string]{Body: ftl.Some(req.Body)}, nil\n}\n```\n\nThe following curl request will map the `SumType` name and value to the `req.Body`:\n\n```sh\ncurl -X POST \"http://localhost:8891/typeenum\" \\\n     -H \"Content-Type: application/json\" \\\n     --data '{\"name\": \"A\", \"value\": \"sample\"}'\n```\n\nThe response will be:\n\n```json\n{\n  \"name\": \"A\",\n  \"value\": \"sample\"\n}\n```\n\n### Encoding query params as JSON\n\nComplex query params can also be encoded as JSON using the `@json` query parameter. For example:\n\n> `{\"tag\":\"ftl\"}` url-encoded is `%7B%22tag%22%3A%22ftl%22%7D`\n\n```bash\ncurl -i http://localhost:8891/users/123/posts/456?@json=%7B%22tag%22%3A%22ftl%22%7D\n```\n\n\n",
			"java": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nJVM Languages use the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Java. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```java\nimport java.util.List;\n\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\n\nimport jakarta.ws.rs.QueryParam; // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath; // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    public String get(@RestPath String userId, @QueryParam(\"postId\") String post) {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
			"kotlin": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nKotlin uses the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Kotlin. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```kotlin\nimport java.util.List\n\nimport jakarta.ws.rs.DELETE\nimport jakarta.ws.rs.GET\nimport jakarta.ws.rs.POST\nimport jakarta.ws.rs.PUT\nimport jakarta.ws.rs.Path\n\nimport jakarta.ws.rs.QueryParam // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    fun get(@RestPath userId: String,@QueryParam(\"postId\") post: String) : String {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
	},
	"@RestPath": {
			"go": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\n```go\ntype GetRequestPathParams struct {\n\tUserID string `json:\"userId\"`\n}\n\ntype GetRequestQueryParams struct {\n\tPostID string `json:\"postId\"`\n}\n\ntype GetResponse struct {\n\tMessage string `json:\"msg\"`\n}\n\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, GetRequestPathParams, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\nBecause the example above only has a single path parameter it can be simplified by just using a scalar such as `string` or `int64` as the path parameter type:\n\n```go\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, int64, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\n:::info\n\nThe `req` and `resp` types of HTTP `ingress` [verbs](../reference/verbs) must be `builtin.HttpRequest` and `builtin.HttpResponse` respectively. These types provide the necessary fields for HTTP `ingress` (`headers`, `statusCode`, etc.)\n\n:::\n\nKey points:\n\n- `ingress` verbs will be automatically exported by default.\n\n### Field mapping\n\nThe `HttpRequest` request object takes 3 type parameters, the body, the path parameters and the query parameters.\n\nGiven the following request verb:\n\n```go\ntype PostBody struct{\n\tTitle string               `json:\"title\"`\n\tContent string             `json:\"content\"`\n\tTag ftl.Option[string]     `json:\"tag\"`\n}\ntype PostPathParams struct {\n\tUserID string             `json:\"userId\"`\n\tPostID string             `json:\"postId\"`\n}\n\ntype PostQueryParams struct {\n\tPublish boolean `json:\"publish\"`\n}\n\n//ftl:ingress http PUT /users/{userId}/posts/{postId}\nfunc Get(ctx context.Context, req builtin.HttpRequest[PostBody, PostPathParams, PostQueryParams]) (builtin.HttpResponse[GetResponse, string], error) {\n\treturn builtin.HttpResponse[GetResponse, string]{\n\t\tHeaders: map[string][]string{\"Get\": {\"Header from FTL\"}},\n\t\tBody: ftl.Some(GetResponse{\n\t\t\tMessage: fmt.Sprintf(\"UserID: %s, PostID: %s, Tag: %s\", req.pathParameters.UserID, req.pathParameters.PostID, req.Body.Tag.Default(\"none\")),\n\t\t}),\n\t}, nil\n}\n```\n\nThe rules for how each element is mapped are slightly different, as they have a different structure:\n\n- The body is mapped directly to the body of the request, generally as a JSON object. Scalars are also supported, as well as []byte to get the raw body. If they type is `any` then it will be assumed to be JSON and mapped to the appropriate types based on the JSON structure.\n- The path parameters can be mapped directly to an object with field names corresponding to the name of the path parameter. If there is only a single path parameter it can be injected directly as a scalar. They can also be injected as a `map[string]string`.\n- The path parameters can also be mapped directly to an object with field names corresponding to the name of the path parameter. They can also be injected directly as a `map[string]string`, or `map[string][]string` for multiple values.\n\n### Optional fields\n\nOptional fields are represented by the `ftl.Option` type. The `Option` type is a wrapper around the actual type and can be `Some` or `None`. In the example above, the `Tag` field is optional.\n\n```sh\ncurl -i http://localhost:8891/users/123/posts/456\n```\n\nBecause the `tag` query parameter is not provided, the response will be:\n\n```json\n{\n  \"msg\": \"UserID: 123, PostID: 456, Tag: none\"\n}\n```\n\n### Casing\n\nField names use lowerCamelCase by default. You can override this by using the `json` tag.\n\n### SumTypes\n\nGiven the following request verb:\n\n```go\n//ftl:enum export\ntype SumType interface {\n\ttag()\n}\n\ntype A string\n\nfunc (A) tag() {}\n\ntype B []string\n\nfunc (B) tag() {}\n\n//ftl:ingress http POST /typeenum\nfunc TypeEnum(ctx context.Context, req builtin.HttpRequest[SumType, ftl.Unit, ftl.Unit]) (builtin.HttpResponse[SumType, string], error) {\n\treturn builtin.HttpResponse[SumType, string]{Body: ftl.Some(req.Body)}, nil\n}\n```\n\nThe following curl request will map the `SumType` name and value to the `req.Body`:\n\n```sh\ncurl -X POST \"http://localhost:8891/typeenum\" \\\n     -H \"Content-Type: application/json\" \\\n     --data '{\"name\": \"A\", \"value\": \"sample\"}'\n```\n\nThe response will be:\n\n```json\n{\n  \"name\": \"A\",\n  \"value\": \"sample\"\n}\n```\n\n### Encoding query params as JSON\n\nComplex query params can also be encoded as JSON using the `@json` query parameter. For example:\n\n> `{\"tag\":\"ftl\"}` url-encoded is `%7B%22tag%22%3A%22ftl%22%7D`\n\n```bash\ncurl -i http://localhost:8891/users/123/posts/456?@json=%7B%22tag%22%3A%22ftl%22%7D\n```\n\n\n",
			"java": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nJVM Languages use the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Java. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```java\nimport java.util.List;\n\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\n\nimport jakarta.ws.rs.QueryParam; // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath; // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    public String get(@RestPath String userId, @QueryParam(\"postId\") String post) {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
			"kotlin": "\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\n\n\nKotlin uses the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Kotlin. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\n```kotlin\nimport java.util.List\n\nimport jakarta.ws.rs.DELETE\nimport jakarta.ws.rs.GET\nimport jakarta.ws.rs.POST\nimport jakarta.ws.rs.PUT\nimport jakarta.ws.rs.Path\n\nimport jakarta.ws.rs.QueryParam // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath // Quarkus annotation to get the path parameter\n\n@Path(\"/\")\npublic class TestHTTP {\n\n    @GET\n    @Path(\"/http/users/{userId}/posts\")\n    fun get(@RestPath userId: String,@QueryParam(\"postId\") post: String) : String {\n        //...\n    }\n\n}\n```\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n\n",
	},
	"@Retry": {
			"go": "\n# Retries\n\nSome FTL features allow specifying a retry policy via a language-specific directive. Retries back off exponentially until the maximum is reached.\n\n\n\nThe directive has the following syntax:\n\n```go\n//ftl:retry [<attempts=10>] <min-backoff> [<max-backoff=1hr>] [catch <catchVerb>]\n```\n\nFor example, the following function will retry up to 10 times, with a delay of 5s, 10s, 20s, 40s, 60s, 60s, etc.\n\n```go\n//ftl:retry 10 5s 1m\nfunc Process(ctx context.Context, in Invoice) error {\n  // ...\n}\n```\n\n### PubSub Subscribers\n\nSubscribers can have a retry policy. For example:\n\n```go\n//ftl:retry 5 1s catch recoverPaymentProcessing\nfunc ProcessPayment(ctx context.Context, payment Payment) error {\n...\n}\n```\n\n### Catching\n\nAfter all retries have failed, a catch verb can be used to safely recover.\n\nThese catch verbs have a request type of `builtin.CatchRequest<Req>` and no response type. If a catch verb returns an error, it will be retried until it succeeds so it is important to handle errors carefully.\n\n```go\n//ftl:retry 5 1s catch recoverPaymentProcessing\nfunc ProcessPayment(ctx context.Context, payment Payment) error {\n...\n}\n\n//ftl:verb\nfunc RecoverPaymentProcessing(ctx context.Context, request builtin.CatchRequest[Payment]) error {\n// safely handle final failure of the payment\n}\n```\n\n\n",
			"java": "\n# Retries\n\nSome FTL features allow specifying a retry policy via a language-specific directive. Retries back off exponentially until the maximum is reached.\n\n\n\nThe directive has the following syntax:\n\n```java\n@Retry(attempts = 10, minBackoff = \"5s\", maxBackoff = \"1h\", catchVerb = \"<catchVerb>\", catchModule = \"<catchModule>\")\n```\n\nFor example, the following function will retry up to 10 times, with a delay of 5s, 10s, 20s, 40s, 60s, 60s, etc.\n\n```java\n@Retry(count = 10, minBackoff = \"5s\", maxBackoff = \"1m\")\npublic void process(Invoice in) {\n    // ... \n}\n```\n\n### PubSub Subscribers\n\nSubscribers can have a retry policy. For example:\n\n```java\n@Subscription(topic = \"example\", name = \"exampleSubscription\")\n@SubscriptionOptions(from = FromOffset.LATEST)\n@Retry(count = 5, minBackoff = \"1s\", catchVerb = \"recoverPaymentProcessing\")\npublic void processPayment(Payment payment) {\n    // ... \n}\n```\n\n### Catching\n\nAfter all retries have failed, a catch verb can be used to safely recover.\n\nThese catch verbs have a request type of `CatchRequest<Req>` and no response type. If a catch verb returns an error, it will be retried until it succeeds so it is important to handle errors carefully.\n\n```java\n@Retry(count = 5, minBackoff = \"1s\", catchVerb = \"recoverPaymentProcessing\")\npublic void processPayment(Payment payment) {\n    // ... \n}\n\n@Verb\npublic void recoverPaymentProcessing(CatchRequest<Payment> req) {\n    // safely handle final failure of the payment\n}\n```\n\n\n",
			"kotlin": "\n# Retries\n\nSome FTL features allow specifying a retry policy via a language-specific directive. Retries back off exponentially until the maximum is reached.\n\n\n\nThe directive has the following syntax:\n\n```kotlin\n@Retry(attempts = 10, minBackoff = \"5s\", maxBackoff = \"1h\", catchVerb = \"<catchVerb>\", catchModule = \"<catchModule>\")\n```\n\nFor example, the following function will retry up to 10 times, with a delay of 5s, 10s, 20s, 40s, 60s, 60s, etc.\n\n```kotlin\n@Retry(count = 10, minBackoff = \"5s\", maxBackoff = \"1m\")\nfun process(inv: Invoice) {\n    // ... \n}\n```\n\n### PubSub Subscribers\n\nSubscribers can have a retry policy. For example:\n\n```kotlin\n@Subscription(topic = \"example\", name = \"exampleSubscription\")\n@SubscriptionOptions(from = FromOffset.LATEST)\n@Retry(count = 5, minBackoff = \"1s\", catchVerb = \"recoverPaymentProcessing\")\nfun processPayment(payment: Payment) {\n    // ... \n}\n```\n\n### Catching\n\nAfter all retries have failed, a catch verb can be used to safely recover.\n\nThese catch verbs have a request type of `CatchRequest<Req>` and no response type. If a catch verb returns an error, it will be retried until it succeeds so it is important to handle errors carefully.\n\n```kotlin\n@Retry(count = 5, minBackoff = \"1s\", catchVerb = \"recoverPaymentProcessing\")\nfun processPayment(payment: Payment) {\n    // ... \n}\n\n@Verb\nfun recoverPaymentProcessing(req: CatchRequest<Payment>) {\n    // safely handle final failure of the payment\n}\n```\n\n\n",
	},
	"@SQLDatasource": {
			"go": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nYour database is automatically declared by following a specific directory structure for your SQL files. No additional configuration is needed - just create the directory structure and FTL will handle the rest.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Go projects, SQL files must be located in:\n```\ndb/\n  ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n  │   └── mydb/        # database name\n  │       ├── schema/  # contains migration files\n  │       └── queries/ # contains query files\n```\n\nThe presence of a `schema` directory under your database name automatically declares the database in FTL.\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\nOnce you've declared a database, FTL automatically generates a database handle that provides direct access to the underlying connection. You can use this to execute raw SQL queries (where `MydbHandle` is the generated handle type for the `mydb` datasource):\n\n```go\n//ftl:verb export\nfunc Query(ctx context.Context, db MydbHandle) ([]string, error) {\n\trows, err := db.QueryContext(ctx, \"SELECT data FROM requests\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\tvar items []string\n\tfor rows.Next() {\n\t\tvar i string\n\t\tif err := rows.Scan(&i); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\titems = append(items, i)\n\t}\n\tif err := rows.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn items, nil\n}\n```\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\n```go\n//ftl:verb export\nfunc GetEmail(ctx context.Context, id int, query GetUserClient) (string, error) {\n\tresult, err := query(ctx, GetUserQuery{ID: id})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result.Email, nil\n}\n```\n\n\n",
			"java": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nTo declare a datasource in Java you must use the `@SQLDatasource` annotation. This annotations is used to define\nthe database name and type.\n\n```java\n@SQLDatasource(name = \"testdb\", type = SQLDatabaseType.POSTGRESQL)\n```\n\nYou must also include the appropriate depdencies in your `pom.xml` for the database you are using:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-postgresql</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-mysql</artifactId>\n</dependency>\n```\n\nYou can also use [Hibernate directly](https://quarkus.io/guides/hibernate-orm) or using [Panache](https://quarkus.io/guides/hibernate-orm-panache).\n\nThis will require adding one of the following dependencies:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm-panache</artifactId>\n</dependency>\n```\n\nNote that this will likely change significantly in future once JVM supports SQL verbs.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Java projects, SQL files must be located in:\n```\nsrc/main/resources/\n  └── db/\n      ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n      │   └── mydb/        # database name\n      │       ├── schema/  # contains migration files\n      │       └── queries/ # contains query files\n```\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\t\n\tTBD\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\t\n\tTBD\n\n\n",
			"kotlin": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nTo declare a datasource in Kotlin you must use the `@SQLDatasource` annotation. This annotations is used to define\nthe database name and type.\n\n```kotlin\n@SQLDatasource(name = \"testdb\", type = SQLDatabaseType.POSTGRESQL)\n```\n\nYou must also include the appropriate depdencies in your `pom.xml` for the database you are using:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-postgresql</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-mysql</artifactId>\n</dependency>\n```\n\nYou can also use [Hibernate directly](https://quarkus.io/guides/hibernate-orm) or using [Panache](https://quarkus.io/guides/hibernate-orm-panache).\n\nThis will require adding one of the following dependencies:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm-panache</artifactId>\n</dependency>\n```\n\nNote that this will likely change significantly in future once FTL has SQL Verbs.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Kotlin projects, SQL files must be located in:\n```\nsrc/main/resources/\n  └── db/\n      ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n      │   └── mydb/        # database name\n      │       ├── schema/  # contains migration files\n      │       └── queries/ # contains query files\n```\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\n\tTBD\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\n\tTBD\n\n\n",
	},
	"@Secret": {
			"go": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nTo declare a configuration value use the following syntax:\n\n```go\n// Simple string configuration\ntype ApiUrl = ftl.Config[string]\n\n// Type-safe configuration\ntype DefaultUser = ftl.Config[Username]\n```\n\nNote that the name of the configuration value as represented in the FTL schema is the lower camel case version of the type name (e.g., `ApiUrl` becomes `apiUrl`).\n\nConfiguration values can be injected into FTL methods, such as //ftl:verb, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```go\n//ftl:verb\nfunc Hello(ctx context.Context, req Request, defaultUser DefaultUser) error {\n    username := defaultUser.Get(ctx)\n    // ...\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nDeclare a secret with the following:\n\n```go\n// Simple string secret\ntype ApiToken = ftl.Secret[string]\n\n// Type-safe secret\ntype ApiKey = ftl.Secret[Credentials]\n```\n\nLike configuration values, the name of the secret as represented in the FTL schema is the lower camel case version of the type name (e.g., `ApiToken` becomes `apiToken`).\n\nSecrets can be injected into FTL methods, such as //ftl:verb, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```go\n//ftl:verb\nfunc CallApi(ctx context.Context, req Request, apiKey ApiKey) error {\n    credentials := apiKey.Get(ctx)\n    // ...\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
			"java": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nConfiguration values can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```java\n@Export\n@Verb\nHelloResponse hello(HelloRequest helloRequest, @Config(\"defaultUser\") String defaultUser)  {\n    return new HelloResponse(\"Hello, \" + defaultUser);\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nSecrets can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```java\n@Export\n@Verb\nHelloResponse hello(HelloRequest helloRequest, @Secret(\"apiKey\") String apiKey)  {\n    return new HelloResponse(\"Hello, \" + api.call(apiKey));\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
			"kotlin": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nConfiguration values can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```kotlin\n@Export\n@Verb\nfun hello(helloRequest: HelloRequest, @Config(\"defaultUser\") defaultUser: String): HelloResponse {\n    return HelloResponse(\"Hello, $defaultUser\")\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nSecrets can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```kotlin\n@Export\n@Verb\nfun hello(helloRequest: HelloRequest, @Secret(\"apiKey\") apiKey: String): HelloResponse {\n    return HelloResponse(\"Hello, ${api.call(apiKey)}\")\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
	},
	"@Subscription": {
			"go": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```go\npackage payments\n\nimport (\n  \"github.com/block/ftl/go-runtime/ftl\"\n)\n\n// Define an event type\ntype Invoice struct {\n  InvoiceNo string\n}\n\n//ftl:topic partitions=1\ntype Invoices = ftl.TopicHandle[Invoice, ftl.SinglePartitionMap[Invoice]]\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```go\npackage payments\n\nimport (\n  \"github.com/block/ftl/go-runtime/ftl\"\n)\n\n// Define an event type\ntype Invoice struct {\n  InvoiceNo string\n}\n\ntype PartitionMapper struct{}\n\nvar _ ftl.TopicPartitionMap[PubSubEvent] = PartitionMapper{}\n\nfunc (PartitionMapper) PartitionKey(event PubSubEvent) string {\n\treturn event.Time.String()\n}\n\n//ftl:topic partitions=10\ntype Invoices = ftl.TopicHandle[Invoice, PartitionMapper]\n```\n\nNote that the name of the topic as represented in the FTL schema is the lower camel case version of the type name.\n\nThe `Invoices` type is a handle to the topic. It is a generic type that takes two arguments: the event type and the partition map type. The partition map type is used to map events to partitions.\n\nThen define a Sink to consume from the topic:\n\n```go\n// Configure initial event consumption with either from=beginning or from=latest\n//\n//ftl:subscribe payments.invoices from=beginning\nfunc SendInvoiceEmail(ctx context.Context, in Invoice) error {\n  // ...\n}\n```\n\nEvents can be published to a topic by injecting the topic type into a verb:\n\n```go\n//ftl:verb\nfunc PublishInvoice(ctx context.Context, topic Invoices) error {\n   topic.Publish(ctx, Invoice{...})\n   // ...\n}\n```\n\n\n",
			"java": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```java\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper;\nimport xyz.block.ftl.Topic;\nimport xyz.block.ftl.WriteableTopic;\n\n// Define the event type for the topic\nrecord Invoice(String invoiceNo) {\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 1)\ninterface InvoicesTopic extends WriteableTopic<Invoice, SinglePartitionMapper> {\n}\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```java\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.Topic;\nimport xyz.block.ftl.TopicPartitionMapper;\nimport xyz.block.ftl.WriteableTopic;\n\n// Define the event type for the topic\nrecord Invoice(String invoiceNo) {\n}\n\n// PartitionMapper maps each to a partition in the topic\nclass PartitionMapper implements TopicPartitionMapper<Invoice> {\n    public String getPartitionKey(Invoice invoice) {\n        return invoice.invoiceNo();\n    }\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 8)\ninterface InvoicesTopic extends WriteableTopic<Invoice, PartitionMapper> {\n}\n```\n\nEvents can be published to a topic by injecting it into an `@Verb` method:\n\n```java\n@Verb\nvoid publishInvoice(InvoiceRequest request, InvoicesTopic topic) throws Exception {\n    topic.publish(new Invoice(request.invoiceNo()));\n}\n```\n\nTo subscribe to a topic use the `@Subscription` annotation, referencing the topic class and providing a method to consume the event:\n\n```java\n// if subscribing from another module, import the event and topic\nimport ftl.othermodule.Invoice;\nimport ftl.othermodule.InvoicesTopic;\n\nimport xyz.block.ftl.FromOffset;\nimport xyz.block.ftl.Subscription;\n\nclass Subscriber {\n    @Subscription(topic = InvoicesTopic.class, from = FromOffset.LATEST)\n    public void consumeInvoice(Invoice event) {\n        // ...\n    }\n}\n```\n\nIf you are subscribing to a topic from another module, FTL will generate a topic class for you so you can subscribe to it. This generated\ntopic cannot be published to, only subscribed to:\n\n```java\n@Topic(name=\"invoices\", module=\"publisher\")\ninterface InvoicesTopic extends ConsumableTopic<Invoice> {}\n```\n\n\n",
			"kotlin": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```kotlin\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper\nimport xyz.block.ftl.Topic\nimport xyz.block.ftl.WriteableTopic\n\n// Define the event type for the topic\ndata class Invoice(val invoiceNo: String)\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 1)\ninternal interface InvoicesTopic : WriteableTopic<Invoice, SinglePartitionMapper>\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```kotlin\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper\nimport xyz.block.ftl.Topic\nimport xyz.block.ftl.TopicPartitionMapper\nimport xyz.block.ftl.WriteableTopic\n\n// Define the event type for the topic\ndata class Invoice(val invoiceNo: String)\n\n// PartitionMapper maps each to a partition in the topic\nclass PartitionMapper : TopicPartitionMapper<Invoice> {\n    override fun getPartitionKey(invoice: Invoice): String {\n        return invoice.invoiceNo\n    }\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 8)\ninternal interface InvoicesTopic : WriteableTopic<Invoice, PartitionMapper>\n```\n\nEvents can be published to a topic by injecting it into an `@Verb` method:\n\n```kotlin\n@Verb\nfun publishInvoice(request: InvoiceRequest, topic: InvoicesTopic) {\n    topic.publish(Invoice(request.invoiceNo))\n}\n```\n\nTo subscribe to a topic use the `@Subscription` annotation, referencing the topic class and providing a method to consume the event:\n\n```kotlin\n// if subscribing from another module, import the event and topic\nimport ftl.publisher.Invoice\nimport ftl.publisher.InvoicesTopic\n\nimport xyz.block.ftl.FromOffset\nimport xyz.block.ftl.Subscription\n\n@Subscription(topic = InvoicesTopic::class, from = FromOffset.LATEST)\nfun consumeInvoice(event: Invoice) {\n    // ...\n}\n```\n\nIf you are subscribing to a topic from another module, FTL will generate a topic class for you so you can subscribe to it. This generated\ntopic cannot be published to, only subscribed to:\n\n```kotlin\n@Topic(name=\"invoices\", module=\"publisher\")\ninternal interface InvoicesTopic : ConsumableTopic<Invoice>\n```\n\n\n",
	},
	"@Topic": {
			"go": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```go\npackage payments\n\nimport (\n  \"github.com/block/ftl/go-runtime/ftl\"\n)\n\n// Define an event type\ntype Invoice struct {\n  InvoiceNo string\n}\n\n//ftl:topic partitions=1\ntype Invoices = ftl.TopicHandle[Invoice, ftl.SinglePartitionMap[Invoice]]\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```go\npackage payments\n\nimport (\n  \"github.com/block/ftl/go-runtime/ftl\"\n)\n\n// Define an event type\ntype Invoice struct {\n  InvoiceNo string\n}\n\ntype PartitionMapper struct{}\n\nvar _ ftl.TopicPartitionMap[PubSubEvent] = PartitionMapper{}\n\nfunc (PartitionMapper) PartitionKey(event PubSubEvent) string {\n\treturn event.Time.String()\n}\n\n//ftl:topic partitions=10\ntype Invoices = ftl.TopicHandle[Invoice, PartitionMapper]\n```\n\nNote that the name of the topic as represented in the FTL schema is the lower camel case version of the type name.\n\nThe `Invoices` type is a handle to the topic. It is a generic type that takes two arguments: the event type and the partition map type. The partition map type is used to map events to partitions.\n\nThen define a Sink to consume from the topic:\n\n```go\n// Configure initial event consumption with either from=beginning or from=latest\n//\n//ftl:subscribe payments.invoices from=beginning\nfunc SendInvoiceEmail(ctx context.Context, in Invoice) error {\n  // ...\n}\n```\n\nEvents can be published to a topic by injecting the topic type into a verb:\n\n```go\n//ftl:verb\nfunc PublishInvoice(ctx context.Context, topic Invoices) error {\n   topic.Publish(ctx, Invoice{...})\n   // ...\n}\n```\n\n\n",
			"java": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```java\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper;\nimport xyz.block.ftl.Topic;\nimport xyz.block.ftl.WriteableTopic;\n\n// Define the event type for the topic\nrecord Invoice(String invoiceNo) {\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 1)\ninterface InvoicesTopic extends WriteableTopic<Invoice, SinglePartitionMapper> {\n}\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```java\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.Topic;\nimport xyz.block.ftl.TopicPartitionMapper;\nimport xyz.block.ftl.WriteableTopic;\n\n// Define the event type for the topic\nrecord Invoice(String invoiceNo) {\n}\n\n// PartitionMapper maps each to a partition in the topic\nclass PartitionMapper implements TopicPartitionMapper<Invoice> {\n    public String getPartitionKey(Invoice invoice) {\n        return invoice.invoiceNo();\n    }\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 8)\ninterface InvoicesTopic extends WriteableTopic<Invoice, PartitionMapper> {\n}\n```\n\nEvents can be published to a topic by injecting it into an `@Verb` method:\n\n```java\n@Verb\nvoid publishInvoice(InvoiceRequest request, InvoicesTopic topic) throws Exception {\n    topic.publish(new Invoice(request.invoiceNo()));\n}\n```\n\nTo subscribe to a topic use the `@Subscription` annotation, referencing the topic class and providing a method to consume the event:\n\n```java\n// if subscribing from another module, import the event and topic\nimport ftl.othermodule.Invoice;\nimport ftl.othermodule.InvoicesTopic;\n\nimport xyz.block.ftl.FromOffset;\nimport xyz.block.ftl.Subscription;\n\nclass Subscriber {\n    @Subscription(topic = InvoicesTopic.class, from = FromOffset.LATEST)\n    public void consumeInvoice(Invoice event) {\n        // ...\n    }\n}\n```\n\nIf you are subscribing to a topic from another module, FTL will generate a topic class for you so you can subscribe to it. This generated\ntopic cannot be published to, only subscribed to:\n\n```java\n@Topic(name=\"invoices\", module=\"publisher\")\ninterface InvoicesTopic extends ConsumableTopic<Invoice> {}\n```\n\n\n",
			"kotlin": "\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\n\n\nFirst, declare a new topic:\n\n```kotlin\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper\nimport xyz.block.ftl.Topic\nimport xyz.block.ftl.WriteableTopic\n\n// Define the event type for the topic\ndata class Invoice(val invoiceNo: String)\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 1)\ninternal interface InvoicesTopic : WriteableTopic<Invoice, SinglePartitionMapper>\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```kotlin\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper\nimport xyz.block.ftl.Topic\nimport xyz.block.ftl.TopicPartitionMapper\nimport xyz.block.ftl.WriteableTopic\n\n// Define the event type for the topic\ndata class Invoice(val invoiceNo: String)\n\n// PartitionMapper maps each to a partition in the topic\nclass PartitionMapper : TopicPartitionMapper<Invoice> {\n    override fun getPartitionKey(invoice: Invoice): String {\n        return invoice.invoiceNo\n    }\n}\n\n// Add @Export if you want other modules to be able to consum from this topic\n@Topic(name = \"invoices\", partitions = 8)\ninternal interface InvoicesTopic : WriteableTopic<Invoice, PartitionMapper>\n```\n\nEvents can be published to a topic by injecting it into an `@Verb` method:\n\n```kotlin\n@Verb\nfun publishInvoice(request: InvoiceRequest, topic: InvoicesTopic) {\n    topic.publish(Invoice(request.invoiceNo))\n}\n```\n\nTo subscribe to a topic use the `@Subscription` annotation, referencing the topic class and providing a method to consume the event:\n\n```kotlin\n// if subscribing from another module, import the event and topic\nimport ftl.publisher.Invoice\nimport ftl.publisher.InvoicesTopic\n\nimport xyz.block.ftl.FromOffset\nimport xyz.block.ftl.Subscription\n\n@Subscription(topic = InvoicesTopic::class, from = FromOffset.LATEST)\nfun consumeInvoice(event: Invoice) {\n    // ...\n}\n```\n\nIf you are subscribing to a topic from another module, FTL will generate a topic class for you so you can subscribe to it. This generated\ntopic cannot be published to, only subscribed to:\n\n```kotlin\n@Topic(name=\"invoices\", module=\"publisher\")\ninternal interface InvoicesTopic : ConsumableTopic<Invoice>\n```\n\n\n",
	},
	"@TypeAlias": {
			"go": "## Type aliases\n\nA type alias is an alternate name for an existing type. It can be declared like so:\n\n\n```go\n//ftl:typealias\ntype UserID string\n```\n\n\nType aliases are useful for making code more readable and type-safe by giving meaningful names to types that represent specific concepts in your domain.\n\n",
			"java": "## Type aliases\n\nA type alias is an alternate name for an existing type. It can be declared like so:\n\n\n```java\n// Java does not support type aliases directly\n// Use a wrapper class instead\npublic class UserID {\n    private final String value;\n\n    public UserID(String value) {\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value;\n    }\n}\n```\n\n\nType aliases are useful for making code more readable and type-safe by giving meaningful names to types that represent specific concepts in your domain.\n\n",
			"kotlin": "## Type aliases\n\nA type alias is an alternate name for an existing type. It can be declared like so:\n\n\n```kotlin\ntypealias UserID = String\n```\n\n\nType aliases are useful for making code more readable and type-safe by giving meaningful names to types that represent specific concepts in your domain.\n\n",
	},
	"@Verb": {
			"go": "\n# Verbs\n\n## Defining Verbs\n\n\n\nTo declare a Verb, write a normal Go function with the following signature, annotated with the Go [comment directive](https://tip.golang.org/doc/comment#syntax) `//ftl:verb`:\n\n```go\n//ftl:verb\nfunc F(context.Context, In) (Out, error) { }\n```\n\neg.\n\n```go\ntype EchoRequest struct {}\n\ntype EchoResponse struct {}\n\n//ftl:verb\nfunc Echo(ctx context.Context, in EchoRequest) (EchoResponse, error) {\n  // ...\n}\n```\n\n\nBy default verbs are only visible to other verbs in the same module (see [visibility](./visibility) for more information).\n\n## Calling Verbs\n\n\nTo call a verb, import the module's verb client (`{ModuleName}.{VerbName}Client`), add it to your verb's signature, then invoke it as a function. eg.\n\n```go\n//ftl:verb\nfunc Echo(ctx context.Context, in EchoRequest, tc time.TimeClient) (EchoResponse, error) {\n    out, err := tc(ctx, TimeRequest{...})\n}\n```\n\nVerb clients are generated by FTL. If the callee verb belongs to the same module as the caller, you must build the\nmodule first (with callee verb defined) in order to generate its client for use by the caller. Local verb clients are\navailable in the generated `types.ftl.go` file as `{VerbName}Client`.\n\n\n",
			"java": "\n# Verbs\n\n## Defining Verbs\n\n\n\nTo declare a Verb, write a normal Java method with the following signature, annotated with the `@Verb` annotation:\n\n```java\n@Verb\npublic Output f(Input input) { }\n```\n\neg.\n\n```java\nimport xyz.block.ftl.Verb;\n\nclass EchoRequest {}\n\nclass EchoResponse {}\n\npublic class EchoClass {\n    @Verb\n    public EchoResponse echo(EchoRequest request) {\n        // ...\n    }\n}\n```\n\n\nBy default verbs are only visible to other verbs in the same module (see [visibility](./visibility) for more information).\n\n## Calling Verbs\n\n\nTo call a verb, import the module's verb client, add it to your verb's signature, then call it. eg.\n\n```java\nimport ftl.time.TimeClient;\nimport xyz.block.ftl.Verb;\n\npublic class EchoClass {\n    @Verb\n    public EchoResponse echo(EchoRequest request, TimeClient time) {\n        TimeResponse response = time.call();\n        // ...\n    }\n}\n```\n\nVerb clients are generated by FTL. If the callee verb belongs to the same module as the caller, you must manually define your\nown client:\n\n```java\n@VerbClient(name=\"time\")\npublic interface TimeClient {\n    TimeResponse call();\n}\n```\n\n\n",
			"kotlin": "\n# Verbs\n\n## Defining Verbs\n\n\n\nTo declare a Verb, write a normal Kotlin function with the following signature, annotated with the Kotlin [annotation](https://kotlinlang.org/docs/annotations.html) `@Verb`:\n\n```kotlin\n@Verb\nfun F(In): Out { }\n```\n\neg.\n\n```kotlin\ndata class EchoRequest\ndata class EchoResponse\n\n@Verb\nfun echo(request: EchoRequest): EchoResponse {\n  // ...\n}\n```\n\n\nBy default verbs are only visible to other verbs in the same module (see [visibility](./visibility) for more information).\n\n## Calling Verbs\n\n\nTo call a verb, import the module's verb client, add it to your verb's signature, then `call()` it. eg.\n\n```kotlin\nimport ftl.time.TimeClient\nimport xyz.block.ftl.Verb\n\n@Verb\nfun echo(req: EchoRequest, time: TimeClient): EchoResponse {\n  val response = time.call()\n  // ...\n}\n\nval response = time.call()\n```\n\nVerb clients are generated by FTL. If the callee verb belongs to the same module as the caller, you must manually define your\nown client:\n\n```kotlin\n@VerbClient(name=\"time\")\ninterface TimeClient {\n    fun call(): TimeResponse\n}\n```\n\n\n",
	},
	"export": {
			"go": "\n# Visibility\n\nBy default all declarations in FTL are visible only to the module they're declared in. The implicit visibility of types is that of the first verb or other declaration that references it.\n\n## Exporting declarations\n\nExporting a declaration makes it accessible to other modules. Some declarations that are entirely local to a module, such as secrets/config, cannot be exported.\n\nTypes that are transitively referenced by an exported declaration will be automatically exported unless they were already defined but unexported. In this case, an error will be raised and the type must be explicitly exported.\n\n\n\nThe following table describes the go directives used to export the corresponding declaration:\n\n| Symbol        | Export syntax            |\n| ------------- | ------------------------ |\n| Verb          | `//ftl:verb export`      |\n| Data          | `//ftl:data export`      |\n| Enum/Sum type | `//ftl:enum export`      |\n| Typealias     | `//ftl:typealias export` |\n| Topic         | `//ftl:export` [^1]      |\n\n```go\n//ftl:verb export\nfunc Verb(ctx context.Context, in In) (Out, error)\n\n//ftl:typealias export\ntype UserID string\n```\n\n[^1]: By default, topics do not require any annotations as the declaration itself is sufficient.\n\n\n",
			"java": "\n# Visibility\n\nBy default all declarations in FTL are visible only to the module they're declared in. The implicit visibility of types is that of the first verb or other declaration that references it.\n\n## Exporting declarations\n\nExporting a declaration makes it accessible to other modules. Some declarations that are entirely local to a module, such as secrets/config, cannot be exported.\n\nTypes that are transitively referenced by an exported declaration will be automatically exported unless they were already defined but unexported. In this case, an error will be raised and the type must be explicitly exported.\n\n\n\nFor Java the `@Export` annotation can be used to export a declaration:\n\n```java\n@Verb\n@Export\nTimeResponse time()  {\n    // ...\n}\n```\n\n\n",
			"kotlin": "\n# Visibility\n\nBy default all declarations in FTL are visible only to the module they're declared in. The implicit visibility of types is that of the first verb or other declaration that references it.\n\n## Exporting declarations\n\nExporting a declaration makes it accessible to other modules. Some declarations that are entirely local to a module, such as secrets/config, cannot be exported.\n\nTypes that are transitively referenced by an exported declaration will be automatically exported unless they were already defined but unexported. In this case, an error will be raised and the type must be explicitly exported.\n\n\n\nFor Kotlin the `@Export` annotation can be used to export a declaration:\n\n```kotlin\n@Verb\n@Export\nfun time(): TimeResponse {\n    // ...\n}\n```\n\n\n",
	},
	"ftl.Config": {
			"go": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nTo declare a configuration value use the following syntax:\n\n```go\n// Simple string configuration\ntype ApiUrl = ftl.Config[string]\n\n// Type-safe configuration\ntype DefaultUser = ftl.Config[Username]\n```\n\nNote that the name of the configuration value as represented in the FTL schema is the lower camel case version of the type name (e.g., `ApiUrl` becomes `apiUrl`).\n\nConfiguration values can be injected into FTL methods, such as //ftl:verb, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```go\n//ftl:verb\nfunc Hello(ctx context.Context, req Request, defaultUser DefaultUser) error {\n    username := defaultUser.Get(ctx)\n    // ...\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nDeclare a secret with the following:\n\n```go\n// Simple string secret\ntype ApiToken = ftl.Secret[string]\n\n// Type-safe secret\ntype ApiKey = ftl.Secret[Credentials]\n```\n\nLike configuration values, the name of the secret as represented in the FTL schema is the lower camel case version of the type name (e.g., `ApiToken` becomes `apiToken`).\n\nSecrets can be injected into FTL methods, such as //ftl:verb, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```go\n//ftl:verb\nfunc CallApi(ctx context.Context, req Request, apiKey ApiKey) error {\n    credentials := apiKey.Get(ctx)\n    // ...\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
			"java": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nConfiguration values can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```java\n@Export\n@Verb\nHelloResponse hello(HelloRequest helloRequest, @Config(\"defaultUser\") String defaultUser)  {\n    return new HelloResponse(\"Hello, \" + defaultUser);\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nSecrets can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```java\n@Export\n@Verb\nHelloResponse hello(HelloRequest helloRequest, @Secret(\"apiKey\") String apiKey)  {\n    return new HelloResponse(\"Hello, \" + api.call(apiKey));\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
			"kotlin": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nConfiguration values can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```kotlin\n@Export\n@Verb\nfun hello(helloRequest: HelloRequest, @Config(\"defaultUser\") defaultUser: String): HelloResponse {\n    return HelloResponse(\"Hello, $defaultUser\")\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nSecrets can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```kotlin\n@Export\n@Verb\nfun hello(helloRequest: HelloRequest, @Secret(\"apiKey\") apiKey: String): HelloResponse {\n    return HelloResponse(\"Hello, ${api.call(apiKey)}\")\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
	},
	"ftl.DatabaseHandle": {
			"go": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nYour database is automatically declared by following a specific directory structure for your SQL files. No additional configuration is needed - just create the directory structure and FTL will handle the rest.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Go projects, SQL files must be located in:\n```\ndb/\n  ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n  │   └── mydb/        # database name\n  │       ├── schema/  # contains migration files\n  │       └── queries/ # contains query files\n```\n\nThe presence of a `schema` directory under your database name automatically declares the database in FTL.\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\nOnce you've declared a database, FTL automatically generates a database handle that provides direct access to the underlying connection. You can use this to execute raw SQL queries (where `MydbHandle` is the generated handle type for the `mydb` datasource):\n\n```go\n//ftl:verb export\nfunc Query(ctx context.Context, db MydbHandle) ([]string, error) {\n\trows, err := db.QueryContext(ctx, \"SELECT data FROM requests\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\tvar items []string\n\tfor rows.Next() {\n\t\tvar i string\n\t\tif err := rows.Scan(&i); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\titems = append(items, i)\n\t}\n\tif err := rows.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn items, nil\n}\n```\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\n```go\n//ftl:verb export\nfunc GetEmail(ctx context.Context, id int, query GetUserClient) (string, error) {\n\tresult, err := query(ctx, GetUserQuery{ID: id})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result.Email, nil\n}\n```\n\n\n",
			"java": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nTo declare a datasource in Java you must use the `@SQLDatasource` annotation. This annotations is used to define\nthe database name and type.\n\n```java\n@SQLDatasource(name = \"testdb\", type = SQLDatabaseType.POSTGRESQL)\n```\n\nYou must also include the appropriate depdencies in your `pom.xml` for the database you are using:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-postgresql</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-mysql</artifactId>\n</dependency>\n```\n\nYou can also use [Hibernate directly](https://quarkus.io/guides/hibernate-orm) or using [Panache](https://quarkus.io/guides/hibernate-orm-panache).\n\nThis will require adding one of the following dependencies:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm-panache</artifactId>\n</dependency>\n```\n\nNote that this will likely change significantly in future once JVM supports SQL verbs.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Java projects, SQL files must be located in:\n```\nsrc/main/resources/\n  └── db/\n      ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n      │   └── mydb/        # database name\n      │       ├── schema/  # contains migration files\n      │       └── queries/ # contains query files\n```\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\t\n\tTBD\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\t\n\tTBD\n\n\n",
			"kotlin": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nTo declare a datasource in Kotlin you must use the `@SQLDatasource` annotation. This annotations is used to define\nthe database name and type.\n\n```kotlin\n@SQLDatasource(name = \"testdb\", type = SQLDatabaseType.POSTGRESQL)\n```\n\nYou must also include the appropriate depdencies in your `pom.xml` for the database you are using:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-postgresql</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-mysql</artifactId>\n</dependency>\n```\n\nYou can also use [Hibernate directly](https://quarkus.io/guides/hibernate-orm) or using [Panache](https://quarkus.io/guides/hibernate-orm-panache).\n\nThis will require adding one of the following dependencies:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm-panache</artifactId>\n</dependency>\n```\n\nNote that this will likely change significantly in future once FTL has SQL Verbs.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Kotlin projects, SQL files must be located in:\n```\nsrc/main/resources/\n  └── db/\n      ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n      │   └── mydb/        # database name\n      │       ├── schema/  # contains migration files\n      │       └── queries/ # contains query files\n```\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\n\tTBD\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\n\tTBD\n\n\n",
	},
	"ftl.DefaultMySQLDatabaseConfig": {
			"go": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nYour database is automatically declared by following a specific directory structure for your SQL files. No additional configuration is needed - just create the directory structure and FTL will handle the rest.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Go projects, SQL files must be located in:\n```\ndb/\n  ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n  │   └── mydb/        # database name\n  │       ├── schema/  # contains migration files\n  │       └── queries/ # contains query files\n```\n\nThe presence of a `schema` directory under your database name automatically declares the database in FTL.\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\nOnce you've declared a database, FTL automatically generates a database handle that provides direct access to the underlying connection. You can use this to execute raw SQL queries (where `MydbHandle` is the generated handle type for the `mydb` datasource):\n\n```go\n//ftl:verb export\nfunc Query(ctx context.Context, db MydbHandle) ([]string, error) {\n\trows, err := db.QueryContext(ctx, \"SELECT data FROM requests\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\tvar items []string\n\tfor rows.Next() {\n\t\tvar i string\n\t\tif err := rows.Scan(&i); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\titems = append(items, i)\n\t}\n\tif err := rows.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn items, nil\n}\n```\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\n```go\n//ftl:verb export\nfunc GetEmail(ctx context.Context, id int, query GetUserClient) (string, error) {\n\tresult, err := query(ctx, GetUserQuery{ID: id})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result.Email, nil\n}\n```\n\n\n",
			"java": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nTo declare a datasource in Java you must use the `@SQLDatasource` annotation. This annotations is used to define\nthe database name and type.\n\n```java\n@SQLDatasource(name = \"testdb\", type = SQLDatabaseType.POSTGRESQL)\n```\n\nYou must also include the appropriate depdencies in your `pom.xml` for the database you are using:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-postgresql</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-mysql</artifactId>\n</dependency>\n```\n\nYou can also use [Hibernate directly](https://quarkus.io/guides/hibernate-orm) or using [Panache](https://quarkus.io/guides/hibernate-orm-panache).\n\nThis will require adding one of the following dependencies:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm-panache</artifactId>\n</dependency>\n```\n\nNote that this will likely change significantly in future once JVM supports SQL verbs.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Java projects, SQL files must be located in:\n```\nsrc/main/resources/\n  └── db/\n      ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n      │   └── mydb/        # database name\n      │       ├── schema/  # contains migration files\n      │       └── queries/ # contains query files\n```\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\t\n\tTBD\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\t\n\tTBD\n\n\n",
			"kotlin": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nTo declare a datasource in Kotlin you must use the `@SQLDatasource` annotation. This annotations is used to define\nthe database name and type.\n\n```kotlin\n@SQLDatasource(name = \"testdb\", type = SQLDatabaseType.POSTGRESQL)\n```\n\nYou must also include the appropriate depdencies in your `pom.xml` for the database you are using:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-postgresql</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-mysql</artifactId>\n</dependency>\n```\n\nYou can also use [Hibernate directly](https://quarkus.io/guides/hibernate-orm) or using [Panache](https://quarkus.io/guides/hibernate-orm-panache).\n\nThis will require adding one of the following dependencies:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm-panache</artifactId>\n</dependency>\n```\n\nNote that this will likely change significantly in future once FTL has SQL Verbs.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Kotlin projects, SQL files must be located in:\n```\nsrc/main/resources/\n  └── db/\n      ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n      │   └── mydb/        # database name\n      │       ├── schema/  # contains migration files\n      │       └── queries/ # contains query files\n```\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\n\tTBD\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\n\tTBD\n\n\n",
	},
	"ftl.PostgresDatabaseConfig": {
			"go": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nYour database is automatically declared by following a specific directory structure for your SQL files. No additional configuration is needed - just create the directory structure and FTL will handle the rest.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Go projects, SQL files must be located in:\n```\ndb/\n  ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n  │   └── mydb/        # database name\n  │       ├── schema/  # contains migration files\n  │       └── queries/ # contains query files\n```\n\nThe presence of a `schema` directory under your database name automatically declares the database in FTL.\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\nOnce you've declared a database, FTL automatically generates a database handle that provides direct access to the underlying connection. You can use this to execute raw SQL queries (where `MydbHandle` is the generated handle type for the `mydb` datasource):\n\n```go\n//ftl:verb export\nfunc Query(ctx context.Context, db MydbHandle) ([]string, error) {\n\trows, err := db.QueryContext(ctx, \"SELECT data FROM requests\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\tvar items []string\n\tfor rows.Next() {\n\t\tvar i string\n\t\tif err := rows.Scan(&i); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\titems = append(items, i)\n\t}\n\tif err := rows.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn items, nil\n}\n```\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\n```go\n//ftl:verb export\nfunc GetEmail(ctx context.Context, id int, query GetUserClient) (string, error) {\n\tresult, err := query(ctx, GetUserQuery{ID: id})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result.Email, nil\n}\n```\n\n\n",
			"java": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nTo declare a datasource in Java you must use the `@SQLDatasource` annotation. This annotations is used to define\nthe database name and type.\n\n```java\n@SQLDatasource(name = \"testdb\", type = SQLDatabaseType.POSTGRESQL)\n```\n\nYou must also include the appropriate depdencies in your `pom.xml` for the database you are using:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-postgresql</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-mysql</artifactId>\n</dependency>\n```\n\nYou can also use [Hibernate directly](https://quarkus.io/guides/hibernate-orm) or using [Panache](https://quarkus.io/guides/hibernate-orm-panache).\n\nThis will require adding one of the following dependencies:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm-panache</artifactId>\n</dependency>\n```\n\nNote that this will likely change significantly in future once JVM supports SQL verbs.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Java projects, SQL files must be located in:\n```\nsrc/main/resources/\n  └── db/\n      ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n      │   └── mydb/        # database name\n      │       ├── schema/  # contains migration files\n      │       └── queries/ # contains query files\n```\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\t\n\tTBD\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\t\n\tTBD\n\n\n",
			"kotlin": "\n# Databases\n\nFTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.\n\nThe process for declaring a database differs by language.\n\n\n\nTo declare a datasource in Kotlin you must use the `@SQLDatasource` annotation. This annotations is used to define\nthe database name and type.\n\n```kotlin\n@SQLDatasource(name = \"testdb\", type = SQLDatabaseType.POSTGRESQL)\n```\n\nYou must also include the appropriate depdencies in your `pom.xml` for the database you are using:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-postgresql</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-jdbc-mysql</artifactId>\n</dependency>\n```\n\nYou can also use [Hibernate directly](https://quarkus.io/guides/hibernate-orm) or using [Panache](https://quarkus.io/guides/hibernate-orm-panache).\n\nThis will require adding one of the following dependencies:\n\n```xml\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.quarkus</groupId>\n    <artifactId>quarkus-hibernate-orm-panache</artifactId>\n</dependency>\n```\n\nNote that this will likely change significantly in future once FTL has SQL Verbs.\n\n\n## SQL File Structure\n\nIn order to be discoverable by FTL, the SQL files in your project must follow a specific directory structure. FTL supports two database engines, declared via the directory hierarchy as either `mysql` or `postgres`:\n\n\nFor Kotlin projects, SQL files must be located in:\n```\nsrc/main/resources/\n  └── db/\n      ├── mysql/           # must be exactly \"mysql\" or \"postgres\"\n      │   └── mydb/        # database name\n      │       ├── schema/  # contains migration files\n      │       └── queries/ # contains query files\n```\n\n\n### Schema Directory\n\nThe `schema` directory contains all your database migration `.sql` files. These files are used to create and modify your database schema.\n\n### Queries Directory\n\nThe `queries` directory contains `.sql` files with any SQL queries you would like generated as FTL verbs for use in your module. These queries must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/). FTL will automatically lift these queries into the module schema and provide a type-safe client to execute each query.\n\nFind more information in the [Using Generated Query Clients](#using-generated-query-clients) section below.\n\n## Provisioning\n\nFTL includes support for automatically provisioning databases. The actual backing implementation is\nextensible, and presently we include support for both local development provisioning using docker,\nand cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container\nwill automatically be spun up for each datasource that has been defined, and FTL will automatically\nhandle configuration. The same applies when deploying to an AWS cluster with cloud formations\nprovisioning setup.\n\n## Migrations\n\nFTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). \n\nTo create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required\ndirectory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.\n\nThe module name can be omitted if the current working directory only contains a single module.\n\nE.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.\n\nWhen the modules are provisioned FTL will automatically run these migrations for you. \n\n## Connecting with your DB\n\nThere are two supported ways to interact with your database in FTL: using the generated database handle to perform raw queries, or using generated query clients.\n\n### Using the Generated Database Handle\n\n\n\tTBD\n\n\n### Using Generated Query Clients\n\nFor better type safety and maintainability, FTL can automatically generate type-safe query clients from SQL files in your `queries` directory. Your SQL files must be annotated with [SQLC annotation syntax](https://docs.sqlc.dev/) to specify the type of query and its parameters. For example:\n\n```sql\n-- name: GetUser :one\nSELECT id, name, email\nFROM users\nWHERE id = $1;\n\n-- name: ListUsers :many\nSELECT id, name, email\nFROM users\nORDER BY name;\n\n-- name: CreateUser :exec\nINSERT INTO users (name, email)\nVALUES ($1, $2);\n```\n\nThese queries will be automatically converted into FTL verbs with corresponding generated clients that you can inject into your verbs just like any other verb client. For example:\n\n\n\tTBD\n\n\n",
	},
	"ftl.Secret": {
			"go": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nTo declare a configuration value use the following syntax:\n\n```go\n// Simple string configuration\ntype ApiUrl = ftl.Config[string]\n\n// Type-safe configuration\ntype DefaultUser = ftl.Config[Username]\n```\n\nNote that the name of the configuration value as represented in the FTL schema is the lower camel case version of the type name (e.g., `ApiUrl` becomes `apiUrl`).\n\nConfiguration values can be injected into FTL methods, such as //ftl:verb, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```go\n//ftl:verb\nfunc Hello(ctx context.Context, req Request, defaultUser DefaultUser) error {\n    username := defaultUser.Get(ctx)\n    // ...\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nDeclare a secret with the following:\n\n```go\n// Simple string secret\ntype ApiToken = ftl.Secret[string]\n\n// Type-safe secret\ntype ApiKey = ftl.Secret[Credentials]\n```\n\nLike configuration values, the name of the secret as represented in the FTL schema is the lower camel case version of the type name (e.g., `ApiToken` becomes `apiToken`).\n\nSecrets can be injected into FTL methods, such as //ftl:verb, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```go\n//ftl:verb\nfunc CallApi(ctx context.Context, req Request, apiKey ApiKey) error {\n    credentials := apiKey.Get(ctx)\n    // ...\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
			"java": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nConfiguration values can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```java\n@Export\n@Verb\nHelloResponse hello(HelloRequest helloRequest, @Config(\"defaultUser\") String defaultUser)  {\n    return new HelloResponse(\"Hello, \" + defaultUser);\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nSecrets can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```java\n@Export\n@Verb\nHelloResponse hello(HelloRequest helloRequest, @Secret(\"apiKey\") String apiKey)  {\n    return new HelloResponse(\"Hello, \" + api.call(apiKey));\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
			"kotlin": "\n# Secrets and Configuration\n\n## Configuration\n\nConfiguration values are named, typed values. They are managed by the `ftl config` command-line.\n\n\n\nConfiguration values can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a configuration value, use the following syntax:\n\n```kotlin\n@Export\n@Verb\nfun hello(helloRequest: HelloRequest, @Config(\"defaultUser\") defaultUser: String): HelloResponse {\n    return HelloResponse(\"Hello, $defaultUser\")\n}\n```\n\n\n## Secrets\n\nSecrets are encrypted, named, typed values. They are managed by the `ftl secret` command-line.\n\n\nSecrets can be injected into FTL methods, such as `@Verb`, HTTP ingress, Cron etc. To inject a secret value, use the following syntax:\n\n```kotlin\n@Export\n@Verb\nfun hello(helloRequest: HelloRequest, @Secret(\"apiKey\") apiKey: String): HelloResponse {\n    return HelloResponse(\"Hello, ${api.call(apiKey)}\")\n}\n```\n\n\n## Transforming secrets/configuration\n\nOften, raw secret/configuration values aren't directly useful. For example, raw credentials might be used to create an API client. For those situations `ftl.Map()` can be used to transform a configuration or secret value into another type:\n\n```go\nvar client = ftl.Map(ftl.Secret[Credentials](\"credentials\"),\n                     func(ctx context.Context, creds Credentials) (*api.Client, error) {\n    return api.NewClient(creds)\n})\n```\n\nThis is not currently supported in Kotlin or Java. \n\n",
	},
}
