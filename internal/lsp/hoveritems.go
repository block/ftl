// Code generated by 'just lsp-generate'. DO NOT EDIT.
package lsp

var hoverMap = map[string]string{
	"//ftl:cron": "## Cron\n# Cron\n\nA cron job is an Empty verb that will be called on a schedule. The syntax is described [here](https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/crontab.html).\n\nYou can also use a shorthand syntax for the cron job, supporting seconds (`s`), minutes (`m`), hours (`h`), and specific days of the week (e.g. `Mon`).\n\n## Examples\n\nThe following function will be called hourly:\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"go\" label=\"Go\" default>\n\n```go\n//ftl:cron 0 * * * *\nfunc Hourly(ctx context.Context) error {\n  // ...\n}\n```\n\n  </TabItem>\n  <TabItem value=\"kotlin\" label=\"Kotlin\">\n\nimport xyz.block.ftl.Cron\n\n  </TabItem>\n  <TabItem value=\"java\" label=\"Java\">\n\nimport xyz.block.ftl.Cron;\n\n  </TabItem>\n</Tabs>\n\nEvery 12 hours, starting at UTC midnight:\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"go\" label=\"Go\" default>\n\n```go\n//ftl:cron 12h\nfunc TwiceADay(ctx context.Context) error {\n  // ...\n}\n```\n\n  </TabItem>\n  <TabItem value=\"kotlin\" label=\"Kotlin\">\n\nimport xyz.block.ftl.Cron\n\n  </TabItem>\n  <TabItem value=\"java\" label=\"Java\">\n\nimport xyz.block.ftl.Cron;\n\n  </TabItem>\n</Tabs>\n\nEvery Monday at UTC midnight:\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"go\" label=\"Go\" default>\n\n```go\n//ftl:cron Mon\nfunc Mondays(ctx context.Context) error {\n  // ...\n}\n```\n\n  </TabItem>\n  <TabItem value=\"kotlin\" label=\"Kotlin\">\n\nimport xyz.block.ftl.Cron\n\n  </TabItem>\n  <TabItem value=\"java\" label=\"Java\">\n\nimport xyz.block.ftl.Cron;\n\n  </TabItem>\n</Tabs> \n",
	"//ftl:enum": "## Type enums (sum types)\n\n[Sum types](https://en.wikipedia.org/wiki/Tagged_union) are supported by FTL's type system.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"go\" label=\"Go\" default>\n\nSum types aren't directly supported by Go, however they can be approximated with the use of [sealed interfaces](https://blog.chewxy.com/2018/03/18/golang-interfaces/):\n\n```go\n//ftl:enum\ntype Animal interface { animal() }\n\ntype Cat struct {}\nfunc (Cat) animal() {}\n\ntype Dog struct {}\nfunc (Dog) animal() {}\n```\n\n  </TabItem>\n  <TabItem value=\"kotlin\" label=\"Kotlin\">\n\nSum types aren't directly supported by Kotlin, however they can be approximated with the use of [sealed interfaces](https://kotlinlang.org/docs/sealed-classes.html):\n\n\n  </TabItem>\n  <TabItem value=\"java\" label=\"Java\">\n\n> TODO\n\n  </TabItem>\n</Tabs>\n## Value enums\n\nA value enum is an enumerated set of string or integer values.\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"go\" label=\"Go\" default>\n\n```go\n//ftl:enum\ntype Colour string\n\nconst (\n  Red   Colour = \"red\"\n  Green Colour = \"green\"\n  Blue  Colour = \"blue\"\n)\n```\n\n  </TabItem>\n  <TabItem value=\"kotlin\" label=\"Kotlin\">\n\n\n  </TabItem>\n  <TabItem value=\"java\" label=\"Java\">\n\n\n  </TabItem>\n</Tabs>\n",
	"//ftl:ingress": "## HTTP Ingress\n# HTTP Ingress\n\nVerbs annotated with `ftl:ingress` will be exposed via HTTP (`http` is the default ingress type). These endpoints will then be available on one of our default `ingress` ports (local development defaults to `http://localhost:8891`).\n\nThe following will be available at `http://localhost:8891/http/users/123/posts?postId=456`.\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs groupId=\"languages\">\n<TabItem value=\"go\" label=\"Go\" default>\n\n```go\ntype GetRequestPathParams struct {\n\tUserID string `json:\"userId\"`\n}\n\ntype GetRequestQueryParams struct {\n\tPostID string `json:\"postId\"`\n}\n\ntype GetResponse struct {\n\tMessage string `json:\"msg\"`\n}\n\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, GetRequestPathParams, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\nBecause the example above only has a single path parameter it can be simplified by just using a scalar such as `string` or `int64` as the path parameter type:\n\n```go\n//ftl:ingress GET /http/users/{userId}/posts\nfunc Get(ctx context.Context, req builtin.HttpRequest[ftl.Unit, int64, GetRequestQueryParams]) (builtin.HttpResponse[GetResponse, ErrorResponse], error) {\n  // ...\n}\n```\n\n:::info\n\nThe `req` and `resp` types of HTTP `ingress` [verbs](../reference/verbs) must be `builtin.HttpRequest` and `builtin.HttpResponse` respectively. These types provide the necessary fields for HTTP `ingress` (`headers`, `statusCode`, etc.)\n\n:::\n\nKey points:\n\n- `ingress` verbs will be automatically exported by default.\n\n### Field mapping\n\nThe `HttpRequest` request object takes 3 type parameters, the body, the path parameters and the query parameters.\n\nGiven the following request verb:\n\n```go\ntype PostBody struct{\n\tTitle string               `json:\"title\"`\n\tContent string             `json:\"content\"`\n\tTag ftl.Option[string]     `json:\"tag\"`\n}\ntype PostPathParams struct {\n\tUserID string             `json:\"userId\"`\n\tPostID string             `json:\"postId\"`\n}\n\ntype PostQueryParams struct {\n\tPublish boolean `json:\"publish\"`\n}\n\n//ftl:ingress http PUT /users/{userId}/posts/{postId}\nfunc Get(ctx context.Context, req builtin.HttpRequest[PostBody, PostPathParams, PostQueryParams]) (builtin.HttpResponse[GetResponse, string], error) {\n\treturn builtin.HttpResponse[GetResponse, string]{\n\t\tHeaders: map[string][]string{\"Get\": {\"Header from FTL\"}},\n\t\tBody: ftl.Some(GetResponse{\n\t\t\tMessage: fmt.Sprintf(\"UserID: %s, PostID: %s, Tag: %s\", req.pathParameters.UserID, req.pathParameters.PostID, req.Body.Tag.Default(\"none\")),\n\t\t}),\n\t}, nil\n}\n```\n\nThe rules for how each element is mapped are slightly different, as they have a different structure:\n\n- The body is mapped directly to the body of the request, generally as a JSON object. Scalars are also supported, as well as []byte to get the raw body. If they type is `any` then it will be assumed to be JSON and mapped to the appropriate types based on the JSON structure.\n- The path parameters can be mapped directly to an object with field names corresponding to the name of the path parameter. If there is only a single path parameter it can be injected directly as a scalar. They can also be injected as a `map[string]string`.\n- The path parameters can also be mapped directly to an object with field names corresponding to the name of the path parameter. They can also be injected directly as a `map[string]string`, or `map[string][]string` for multiple values.\n\n### Optional fields\n\nOptional fields are represented by the `ftl.Option` type. The `Option` type is a wrapper around the actual type and can be `Some` or `None`. In the example above, the `Tag` field is optional.\n\n\nBecause the `tag` query parameter is not provided, the response will be:\n\n\n### Casing\n\nField names use lowerCamelCase by default. You can override this by using the `json` tag.\n\n### SumTypes\n\nGiven the following request verb:\n\n```go\n//ftl:enum export\ntype SumType interface {\n\ttag()\n}\n\ntype A string\n\nfunc (A) tag() {}\n\ntype B []string\n\nfunc (B) tag() {}\n\n//ftl:ingress http POST /typeenum\nfunc TypeEnum(ctx context.Context, req builtin.HttpRequest[SumType, ftl.Unit, ftl.Unit]) (builtin.HttpResponse[SumType, string], error) {\n\treturn builtin.HttpResponse[SumType, string]{Body: ftl.Some(req.Body)}, nil\n}\n```\n\nThe following curl request will map the `SumType` name and value to the `req.Body`:\n\n\nThe response will be:\n\n\n### Encoding query params as JSON\n\nComplex query params can also be encoded as JSON using the `@json` query parameter. For example:\n\n> `{\"tag\":\"ftl\"}` url-encoded is `%7B%22tag%22%3A%22ftl%22%7D`\n\n\n</TabItem>\n<TabItem value=\"kotlin\" label=\"Kotlin\">\n\nKotlin uses the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Kotlin. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\nimport java.util.List\nimport jakarta.ws.rs.DELETE\nimport jakarta.ws.rs.GET\nimport jakarta.ws.rs.POST\nimport jakarta.ws.rs.PUT\nimport jakarta.ws.rs.Path\nimport jakarta.ws.rs.QueryParam // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath // Quarkus annotation to get the path parameter\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n</TabItem>\n<TabItem value=\"java\" label=\"Java\">\n\nJVM Languages use the `JAX-RS` annotations to define HTTP endpoints. The following example shows how to define an HTTP endpoint in Java. As the underling implementation is based on [Quarkus](https://quarkus.io)\nit is also possible to use the [Quarkus extensions to the JAX-RS annotations](https://quarkus.io/guides/rest#accessing-request-parameters).\n\nIn general the difference between the Quarkus annotation and the standard JAX-RS ones is that the Quarkus parameters infer the parameter name from the method parameter name, while the JAX-RS ones require the parameter name to be explicitly defined.\n\nimport java.util.List;\nimport jakarta.ws.rs.DELETE;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.PUT;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.QueryParam; // JAX-RS annotation to get the query parameter\nimport org.jboss.resteasy.reactive.RestPath; // Quarkus annotation to get the path parameter\n\nUnder the hood these HTTP invocations are being mapped to verbs that take a `builtin.HttpRequest` and return a `builtin.HttpResponse`. This is not exposed directly to the user, but is instead mapped directly to `JAX-RS` annotations.\n\n</TabItem>\n</Tabs>\n",
	"//ftl:retry": "## Retries\n# Retries\n\nSome FTL features allow specifying a retry policy via a language-specific directive. Retries back off exponentially until the maximum is reached.\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs groupId=\"languages\">\n<TabItem value=\"go\" label=\"Go\" default>\n\nThe directive has the following syntax:\n\n```go\n//ftl:retry [<attempts=10>] <min-backoff> [<max-backoff=1hr>] [catch <catchVerb>]\n```\n\nFor example, the following function will retry up to 10 times, with a delay of 5s, 10s, 20s, 40s, 60s, 60s, etc.\n\n```go\n//ftl:retry 10 5s 1m\nfunc Process(ctx context.Context, in Invoice) error {\n  // ...\n}\n```\n\n### PubSub Subscribers\n\nSubscribers can have a retry policy. For example:\n\n```go\n//ftl:retry 5 1s catch recoverPaymentProcessing\nfunc ProcessPayment(ctx context.Context, payment Payment) error {\n...\n}\n```\n\n### Catching\n\nAfter all retries have failed, a catch verb can be used to safely recover.\n\nThese catch verbs have a request type of `builtin.CatchRequest<Req>` and no response type. If a catch verb returns an error, it will be retried until it succeeds so it is important to handle errors carefully.\n\n```go\n//ftl:retry 5 1s catch recoverPaymentProcessing\nfunc ProcessPayment(ctx context.Context, payment Payment) error {\n...\n}\n\n//ftl:verb\nfunc RecoverPaymentProcessing(ctx context.Context, request builtin.CatchRequest[Payment]) error {\n// safely handle final failure of the payment\n}\n```\n\n</TabItem>\n<TabItem value=\"kotlin\" label=\"Kotlin\">\n\nThe directive has the following syntax:\n\n\nFor example, the following function will retry up to 10 times, with a delay of 5s, 10s, 20s, 40s, 60s, 60s, etc.\n\n\n### PubSub Subscribers\n\nSubscribers can have a retry policy. For example:\n\n\n### Catching\n\nAfter all retries have failed, a catch verb can be used to safely recover.\n\nThese catch verbs have a request type of `CatchRequest<Req>` and no response type. If a catch verb returns an error, it will be retried until it succeeds so it is important to handle errors carefully.\n\n\n</TabItem>\n<TabItem value=\"java\" label=\"Java\">\n\nThe directive has the following syntax:\n\n\nFor example, the following function will retry up to 10 times, with a delay of 5s, 10s, 20s, 40s, 60s, 60s, etc.\n\n\n### PubSub Subscribers\n\nSubscribers can have a retry policy. For example:\n\n\n### Catching\n\nAfter all retries have failed, a catch verb can be used to safely recover.\n\nThese catch verbs have a request type of `CatchRequest<Req>` and no response type. If a catch verb returns an error, it will be retried until it succeeds so it is important to handle errors carefully.\n\n\n</TabItem>\n</Tabs> \n",
	"//ftl:subscribe": "## PubSub\n# PubSub\n\nFTL has first-class support for PubSub, modelled on the concepts of topics (where events are sent) and subscribers (a verb which consumes events). Subscribers are, as you would expect, sinks. Each subscriber is a cursor over the topic it is associated with. Each topic may have multiple subscriptions. Each published event has an at least once delivery guarantee for each subscription.\n\nA topic can be exported to allow other modules to subscribe to it. Subscriptions are always private to their module.\n\nWhen a subscription is first created in an environment, it can start consuming from the beginning of the topic or only consume events published afterwards.\n\nTopics allow configuring the number of partitions and how each event should be mapped to a partition, allowing for greater throughput. Subscriptions will consume in order within each partition. There are cases where a small amount of progress on a subscription will be lost, so subscriptions should be able to handle receiving some events that have already been consumed.\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs groupId=\"languages\">\n<TabItem value=\"go\" label=\"Go\" default>\n\nFirst, declare a new topic:\n\n```go\npackage payments\n\nimport (\n  \"github.com/block/ftl/go-runtime/ftl\"\n)\n\n// Define an event type\ntype Invoice struct {\n  InvoiceNo string\n}\n\n//ftl:topic partitions=1\ntype Invoices = ftl.TopicHandle[Invoice, ftl.SinglePartitionMap[Invoice]]\n```\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\n```go\npackage payments\n\nimport (\n  \"github.com/block/ftl/go-runtime/ftl\"\n)\n\n// Define an event type\ntype Invoice struct {\n  InvoiceNo string\n}\n\ntype PartitionMapper struct{}\n\nvar _ ftl.TopicPartitionMap[PubSubEvent] = PartitionMapper{}\n\nfunc (PartitionMapper) PartitionKey(event PubSubEvent) string {\n\treturn event.Time.String()\n}\n\n//ftl:topic partitions=10\ntype Invoices = ftl.TopicHandle[Invoice, PartitionMapper]\n```\n\nNote that the name of the topic as represented in the FTL schema is the lower camel case version of the type name.\n\nThe `Invoices` type is a handle to the topic. It is a generic type that takes two arguments: the event type and the partition map type. The partition map type is used to map events to partitions.\n\nThen define a Sink to consume from the topic:\n\n```go\n// Configure initial event consumption with either from=beginning or from=latest\n//\n//ftl:subscribe payments.invoices from=beginning\nfunc SendInvoiceEmail(ctx context.Context, in Invoice) error {\n  // ...\n}\n```\n\nEvents can be published to a topic by injecting the topic type into a verb:\n\n```go\n//ftl:verb\nfunc PublishInvoice(ctx context.Context, topic Invoices) error {\n   topic.Publish(ctx, Invoice{...})\n   // ...\n}\n```\n\n</TabItem>\n<TabItem value=\"kotlin\" label=\"Kotlin\">\n\nFirst, declare a new topic:\n\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper\nimport xyz.block.ftl.Topic\nimport xyz.block.ftl.WriteableTopic\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper\nimport xyz.block.ftl.Topic\nimport xyz.block.ftl.TopicPartitionMapper\nimport xyz.block.ftl.WriteableTopic\n\nEvents can be published to a topic by injecting it into an `@Verb` method:\n\n\nTo subscribe to a topic use the `@Subscription` annotation, referencing the topic class and providing a method to consume the event:\n\n// if subscribing from another module, import the event and topic\nimport ftl.publisher.Invoice\nimport ftl.publisher.InvoicesTopic\nimport xyz.block.ftl.FromOffset\nimport xyz.block.ftl.Subscription\n\nIf you are subscribing to a topic from another module, FTL will generate a topic class for you so you can subscribe to it. This generated\ntopic cannot be published to, only subscribed to:\n\n\n</TabItem>\n<TabItem value=\"java\" label=\"Java\">\n\nFirst, declare a new topic:\n\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.SinglePartitionMapper;\nimport xyz.block.ftl.Topic;\nimport xyz.block.ftl.WriteableTopic;\n\nIf you want multiple partitions in the topic, you'll also need to write a partition mapper:\n\nimport xyz.block.ftl.Export;\nimport xyz.block.ftl.Topic;\nimport xyz.block.ftl.TopicPartitionMapper;\nimport xyz.block.ftl.WriteableTopic;\n\nEvents can be published to a topic by injecting it into an `@Verb` method:\n\n\nTo subscribe to a topic use the `@Subscription` annotation, referencing the topic class and providing a method to consume the event:\n\n// if subscribing from another module, import the event and topic\nimport ftl.othermodule.Invoice;\nimport ftl.othermodule.InvoicesTopic;\nimport xyz.block.ftl.FromOffset;\nimport xyz.block.ftl.Subscription;\n\nIf you are subscribing to a topic from another module, FTL will generate a topic class for you so you can subscribe to it. This generated\ntopic cannot be published to, only subscribed to:\n\n\n</TabItem>\n</Tabs> \n",
	"//ftl:typealias": "## Type aliases\n\nA type alias is an alternate name for an existing type. It can be declared like so:\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"go\" label=\"Go\" default>\n\n```go\n//ftl:typealias\ntype UserID string\n```\n\n  </TabItem>\n  <TabItem value=\"kotlin\" label=\"Kotlin\">\n\n\n  </TabItem>\n  <TabItem value=\"java\" label=\"Java\">\n\n\n  </TabItem>\n</Tabs>\n\nType aliases are useful for making code more readable and type-safe by giving meaningful names to types that represent specific concepts in your domain.\n",
	"//ftl:verb": "## Verbs\n# Verbs\n\n## Defining Verbs\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"go\" label=\"Go\" default>\n\nTo declare a Verb, write a normal Go function with the following signature, annotated with the Go [comment directive](https://tip.golang.org/doc/comment#syntax) `//ftl:verb`:\n\n```go\n//ftl:verb\nfunc F(context.Context, In) (Out, error) { }\n```\n\neg.\n\n```go\ntype EchoRequest struct {}\n\ntype EchoResponse struct {}\n\n//ftl:verb\nfunc Echo(ctx context.Context, in EchoRequest) (EchoResponse, error) {\n  // ...\n}\n```\n\n  </TabItem>\n  <TabItem value=\"kotlin\" label=\"Kotlin\">\n\nTo declare a Verb, write a normal Kotlin function with the following signature, annotated with the Kotlin [annotation](https://kotlinlang.org/docs/annotations.html) `@Verb`:\n\n\neg.\n\n\n  </TabItem>\n  <TabItem value=\"java\" label=\"Java\">\n\nTo declare a Verb, write a normal Java method with the following signature, annotated with the `@Verb` annotation:\n\n\neg.\n\nimport xyz.block.ftl.Verb;\n\n  </TabItem>\n</Tabs>\n\nBy default verbs are only visible to other verbs in the same module (see [visibility](./visibility) for more information).\n\n## Calling Verbs\n\n<Tabs groupId=\"languages\">\n  <TabItem value=\"go\" label=\"Go\" default>\n\nTo call a verb, import the module's verb client (`{ModuleName}.{VerbName}Client`), add it to your verb's signature, then invoke it as a function. eg.\n\n```go\n//ftl:verb\nfunc Echo(ctx context.Context, in EchoRequest, tc time.TimeClient) (EchoResponse, error) {\n    out, err := tc(ctx, TimeRequest{...})\n}\n```\n\nVerb clients are generated by FTL. If the callee verb belongs to the same module as the caller, you must build the\nmodule first (with callee verb defined) in order to generate its client for use by the caller. Local verb clients are\navailable in the generated `types.ftl.go` file as `{VerbName}Client`.\n\n  </TabItem>\n  <TabItem value=\"kotlin\" label=\"Kotlin\">\n\nTo call a verb, import the module's verb client, add it to your verb's signature, then `call()` it. eg.\n\nimport ftl.time.TimeClient\nimport xyz.block.ftl.Verb\n\nVerb clients are generated by FTL. If the callee verb belongs to the same module as the caller, you must manually define your\nown client:\n\n\n  </TabItem>\n  <TabItem value=\"java\" label=\"Java\">\n\nTo call a verb, import the module's verb client, add it to your verb's signature, then call it. eg.\n\nimport ftl.time.TimeClient;\nimport xyz.block.ftl.Verb;\n\nVerb clients are generated by FTL. If the callee verb belongs to the same module as the caller, you must manually define your\nown client:\n\n\n  </TabItem>\n</Tabs> \n",
}
