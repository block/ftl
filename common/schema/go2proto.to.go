// Code generated by go2proto. DO NOT EDIT.

package schema

import "fmt"
import "encoding"
import destpb "github.com/block/ftl/common/protos/xyz/block/ftl/schema/v1"
import "google.golang.org/protobuf/types/known/timestamppb"
import "google.golang.org/protobuf/types/known/durationpb"
import "github.com/alecthomas/types/optional"
import "github.com/alecthomas/types/result"

var _ fmt.Stringer
var _ = timestamppb.Timestamp{}
var _ = durationpb.Duration{}

// protoSlice converts a slice of values to a slice of protobuf values.
func protoSlice[P any, T interface{ ToProto() P }](values []T) []P {
	out := make([]P, len(values))
	for i, v := range values {
		out[i] = v.ToProto()
	}
	return out
}

func protoMust[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func sliceMap[T any, U any](values []T, f func(T) U) []U {
	out := make([]U, len(values))
	for i, v := range values {
		out[i] = f(v)
	}
	return out
}

func sliceMapR[T any, U any](values []T, f func(T) result.Result[U]) result.Result[[]U] {
	out := make([]U, len(values))
	for i, v := range values {
		r := f(v)
		if r.Err() != nil {
			return result.Err[[]U](r.Err())
		}
		out[i], _ = r.Get()
	}
	return result.Ok[[]U](out)
}

func orZero[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func orZeroR[T any](v result.Result[*T]) result.Result[T] {
	if v.Err() != nil {
		return result.Err[T](v.Err())
	}
	r, _ := v.Get()
	return result.Ok[T](orZero(r))
}

func ptr[T any](o T) *T {
	return &o
}

func ptrR[T any](o result.Result[T]) result.Result[*T] {
	if o.Err() != nil {
		return result.Err[*T](o.Err())
	}
	r, _ := o.Get()
	return result.Ok[*T](ptr(r))
}

func fromPtr[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func fromPtrR[T any](v result.Result[*T]) result.Result[T] {
	if v.Err() != nil {
		return result.Err[T](v.Err())
	}
	r, _ := v.Get()
	return result.Ok[T](fromPtr(r))
}

func optionalR[T any](r result.Result[*T]) result.Result[optional.Option[T]] {
	if r.Err() != nil {
		return result.Err[optional.Option[T]](r.Err())
	}
	v, _ := r.Get()
	return result.Ok[optional.Option[T]](optional.Ptr(v))
}

func setNil[T, O any](v *T, o *O) *T {
	if o == nil {
		return nil
	}
	return v
}

func setNilR[T, O any](v result.Result[*T], o *O) result.Result[*T] {
	if v.Err() != nil {
		return v
	}
	r, _ := v.Get()
	return result.Ok[*T](setNil(r, o))
}

type binaryUnmarshallable[T any] interface {
	*T
	encoding.BinaryUnmarshaler
}

type textUnmarshallable[T any] interface {
	*T
	encoding.TextUnmarshaler
}

func unmarshallBinary[T any, TPtr binaryUnmarshallable[T]](v []byte, f TPtr) result.Result[*T] {
	var to T
	toptr := (TPtr)(&to)

	err := toptr.UnmarshalBinary(v)
	if err != nil {
		return result.Err[*T](err)
	}
	return result.Ok[*T](&to)
}

func unmarshallText[T any, TPtr textUnmarshallable[T]](v []byte, f TPtr) result.Result[*T] {
	var to T
	toptr := (TPtr)(&to)

	err := toptr.UnmarshalText(v)
	if err != nil {
		return result.Err[*T](err)
	}
	return result.Ok[*T](&to)
}

func (x *AWSIAMAuthDatabaseConnector) ToProto() *destpb.AWSIAMAuthDatabaseConnector {
	if x == nil {
		return nil
	}
	return &destpb.AWSIAMAuthDatabaseConnector{
		Pos:      x.Pos.ToProto(),
		Username: orZero(ptr(string(x.Username))),
		Endpoint: orZero(ptr(string(x.Endpoint))),
		Database: orZero(ptr(string(x.Database))),
	}
}

func AWSIAMAuthDatabaseConnectorFromProto(v *destpb.AWSIAMAuthDatabaseConnector) (out *AWSIAMAuthDatabaseConnector, err error) {
	if v == nil {
		return nil, nil
	}

	out = &AWSIAMAuthDatabaseConnector{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Username, err = orZeroR(result.From(ptr(string(v.Username)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Username: %w", err)
	}
	if out.Endpoint, err = orZeroR(result.From(ptr(string(v.Endpoint)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Endpoint: %w", err)
	}
	if out.Database, err = orZeroR(result.From(ptr(string(v.Database)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Database: %w", err)
	}
	return out, nil
}

func (x AliasKind) ToProto() destpb.AliasKind {
	return destpb.AliasKind(x)
}

func AliasKindFromProto(v destpb.AliasKind) (AliasKind, error) {
	// TODO: Check if the value is valid.
	return AliasKind(v), nil
}

func (x *Any) ToProto() *destpb.Any {
	if x == nil {
		return nil
	}
	return &destpb.Any{
		Pos: x.Pos.ToProto(),
	}
}

func AnyFromProto(v *destpb.Any) (out *Any, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Any{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *Array) ToProto() *destpb.Array {
	if x == nil {
		return nil
	}
	return &destpb.Array{
		Pos:     x.Pos.ToProto(),
		Element: TypeToProto(x.Element),
	}
}

func ArrayFromProto(v *destpb.Array) (out *Array, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Array{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Element, err = orZeroR(ptrR(result.From(TypeFromProto(v.Element)))).Result(); err != nil {
		return nil, fmt.Errorf("Element: %w", err)
	}
	return out, nil
}

func (x *Bool) ToProto() *destpb.Bool {
	if x == nil {
		return nil
	}
	return &destpb.Bool{
		Pos: x.Pos.ToProto(),
	}
}

func BoolFromProto(v *destpb.Bool) (out *Bool, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Bool{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *Bytes) ToProto() *destpb.Bytes {
	if x == nil {
		return nil
	}
	return &destpb.Bytes{
		Pos: x.Pos.ToProto(),
	}
}

func BytesFromProto(v *destpb.Bytes) (out *Bytes, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Bytes{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *Changeset) ToProto() *destpb.Changeset {
	if x == nil {
		return nil
	}
	return &destpb.Changeset{
		Key:             orZero(ptr(string(protoMust(x.Key.MarshalText())))),
		CreatedAt:       timestamppb.New(x.CreatedAt),
		Modules:         sliceMap(x.Modules, func(v *Module) *destpb.Module { return v.ToProto() }),
		ToRemove:        sliceMap(x.ToRemove, func(v string) string { return orZero(ptr(string(v))) }),
		RemovingModules: sliceMap(x.RemovingModules, func(v *Module) *destpb.Module { return v.ToProto() }),
		State:           orZero(ptr(x.State.ToProto())),
		Error:           ptr(string(x.Error)),
	}
}

func ChangesetFromProto(v *destpb.Changeset) (out *Changeset, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Changeset{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if out.CreatedAt, err = orZeroR(result.From(setNil(ptr(v.CreatedAt.AsTime()), v.CreatedAt), nil)).Result(); err != nil {
		return nil, fmt.Errorf("CreatedAt: %w", err)
	}
	if out.Modules, err = sliceMapR(v.Modules, func(v *destpb.Module) result.Result[*Module] { return result.From(ModuleFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Modules: %w", err)
	}
	if out.ToRemove, err = sliceMapR(v.ToRemove, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("ToRemove: %w", err)
	}
	if out.RemovingModules, err = sliceMapR(v.RemovingModules, func(v *destpb.Module) result.Result[*Module] { return result.From(ModuleFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("RemovingModules: %w", err)
	}
	if out.State, err = orZeroR(ptrR(result.From(ChangesetStateFromProto(v.State)))).Result(); err != nil {
		return nil, fmt.Errorf("State: %w", err)
	}
	if out.Error, err = orZeroR(result.From(setNil(ptr(string(orZero(v.Error))), v.Error), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Error: %w", err)
	}
	return out, nil
}

func (x *ChangesetCommittedEvent) ToProto() *destpb.ChangesetCommittedEvent {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetCommittedEvent{
		Key: orZero(ptr(string(protoMust(x.Key.MarshalText())))),
	}
}

func ChangesetCommittedEventFromProto(v *destpb.ChangesetCommittedEvent) (out *ChangesetCommittedEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetCommittedEvent{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *ChangesetCommittedNotification) ToProto() *destpb.ChangesetCommittedNotification {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetCommittedNotification{
		Changeset: x.Changeset.ToProto(),
	}
}

func ChangesetCommittedNotificationFromProto(v *destpb.ChangesetCommittedNotification) (out *ChangesetCommittedNotification, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetCommittedNotification{}
	if out.Changeset, err = result.From(ChangesetFromProto(v.Changeset)).Result(); err != nil {
		return nil, fmt.Errorf("Changeset: %w", err)
	}
	return out, nil
}

func (x *ChangesetCreatedEvent) ToProto() *destpb.ChangesetCreatedEvent {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetCreatedEvent{
		Changeset: x.Changeset.ToProto(),
	}
}

func ChangesetCreatedEventFromProto(v *destpb.ChangesetCreatedEvent) (out *ChangesetCreatedEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetCreatedEvent{}
	if out.Changeset, err = result.From(ChangesetFromProto(v.Changeset)).Result(); err != nil {
		return nil, fmt.Errorf("Changeset: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *ChangesetCreatedNotification) ToProto() *destpb.ChangesetCreatedNotification {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetCreatedNotification{
		Changeset: x.Changeset.ToProto(),
	}
}

func ChangesetCreatedNotificationFromProto(v *destpb.ChangesetCreatedNotification) (out *ChangesetCreatedNotification, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetCreatedNotification{}
	if out.Changeset, err = result.From(ChangesetFromProto(v.Changeset)).Result(); err != nil {
		return nil, fmt.Errorf("Changeset: %w", err)
	}
	return out, nil
}

func (x *ChangesetDrainedEvent) ToProto() *destpb.ChangesetDrainedEvent {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetDrainedEvent{
		Key: orZero(ptr(string(protoMust(x.Key.MarshalText())))),
	}
}

func ChangesetDrainedEventFromProto(v *destpb.ChangesetDrainedEvent) (out *ChangesetDrainedEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetDrainedEvent{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *ChangesetDrainedNotification) ToProto() *destpb.ChangesetDrainedNotification {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetDrainedNotification{
		Key: orZero(ptr(string(protoMust(x.Key.MarshalText())))),
	}
}

func ChangesetDrainedNotificationFromProto(v *destpb.ChangesetDrainedNotification) (out *ChangesetDrainedNotification, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetDrainedNotification{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	return out, nil
}

func (x *ChangesetFailedEvent) ToProto() *destpb.ChangesetFailedEvent {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetFailedEvent{
		Key:   orZero(ptr(string(protoMust(x.Key.MarshalText())))),
		Error: orZero(ptr(string(x.Error))),
	}
}

func ChangesetFailedEventFromProto(v *destpb.ChangesetFailedEvent) (out *ChangesetFailedEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetFailedEvent{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if out.Error, err = orZeroR(result.From(ptr(string(v.Error)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Error: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *ChangesetFailedNotification) ToProto() *destpb.ChangesetFailedNotification {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetFailedNotification{
		Key:   orZero(ptr(string(protoMust(x.Key.MarshalText())))),
		Error: orZero(ptr(string(x.Error))),
	}
}

func ChangesetFailedNotificationFromProto(v *destpb.ChangesetFailedNotification) (out *ChangesetFailedNotification, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetFailedNotification{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if out.Error, err = orZeroR(result.From(ptr(string(v.Error)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Error: %w", err)
	}
	return out, nil
}

func (x *ChangesetFinalizedEvent) ToProto() *destpb.ChangesetFinalizedEvent {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetFinalizedEvent{
		Key: orZero(ptr(string(protoMust(x.Key.MarshalText())))),
	}
}

func ChangesetFinalizedEventFromProto(v *destpb.ChangesetFinalizedEvent) (out *ChangesetFinalizedEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetFinalizedEvent{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *ChangesetFinalizedNotification) ToProto() *destpb.ChangesetFinalizedNotification {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetFinalizedNotification{
		Key: orZero(ptr(string(protoMust(x.Key.MarshalText())))),
	}
}

func ChangesetFinalizedNotificationFromProto(v *destpb.ChangesetFinalizedNotification) (out *ChangesetFinalizedNotification, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetFinalizedNotification{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	return out, nil
}

func (x *ChangesetPreparedEvent) ToProto() *destpb.ChangesetPreparedEvent {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetPreparedEvent{
		Key: orZero(ptr(string(protoMust(x.Key.MarshalText())))),
	}
}

func ChangesetPreparedEventFromProto(v *destpb.ChangesetPreparedEvent) (out *ChangesetPreparedEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetPreparedEvent{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *ChangesetPreparedNotification) ToProto() *destpb.ChangesetPreparedNotification {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetPreparedNotification{
		Key: orZero(ptr(string(protoMust(x.Key.MarshalText())))),
	}
}

func ChangesetPreparedNotificationFromProto(v *destpb.ChangesetPreparedNotification) (out *ChangesetPreparedNotification, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetPreparedNotification{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	return out, nil
}

func (x *ChangesetRollingBackNotification) ToProto() *destpb.ChangesetRollingBackNotification {
	if x == nil {
		return nil
	}
	return &destpb.ChangesetRollingBackNotification{
		Key:   orZero(ptr(string(protoMust(x.Key.MarshalText())))),
		Error: orZero(ptr(string(x.Error))),
	}
}

func ChangesetRollingBackNotificationFromProto(v *destpb.ChangesetRollingBackNotification) (out *ChangesetRollingBackNotification, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ChangesetRollingBackNotification{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if out.Error, err = orZeroR(result.From(ptr(string(v.Error)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Error: %w", err)
	}
	return out, nil
}

func (x ChangesetState) ToProto() destpb.ChangesetState {
	return destpb.ChangesetState(x)
}

func ChangesetStateFromProto(v destpb.ChangesetState) (ChangesetState, error) {
	// TODO: Check if the value is valid.
	return ChangesetState(v), nil
}

func (x *Config) ToProto() *destpb.Config {
	if x == nil {
		return nil
	}
	return &destpb.Config{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Name:     orZero(ptr(string(x.Name))),
		Type:     TypeToProto(x.Type),
	}
}

func ConfigFromProto(v *destpb.Config) (out *Config, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Config{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	return out, nil
}

func (x *DSNDatabaseConnector) ToProto() *destpb.DSNDatabaseConnector {
	if x == nil {
		return nil
	}
	return &destpb.DSNDatabaseConnector{
		Pos: x.Pos.ToProto(),
		Dsn: orZero(ptr(string(x.DSN))),
	}
}

func DSNDatabaseConnectorFromProto(v *destpb.DSNDatabaseConnector) (out *DSNDatabaseConnector, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DSNDatabaseConnector{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.DSN, err = orZeroR(result.From(ptr(string(v.Dsn)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("DSN: %w", err)
	}
	return out, nil
}

func (x *Data) ToProto() *destpb.Data {
	if x == nil {
		return nil
	}
	return &destpb.Data{
		Pos:            x.Pos.ToProto(),
		Comments:       sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Export:         orZero(ptr(bool(x.Export))),
		Name:           orZero(ptr(string(x.Name))),
		TypeParameters: sliceMap(x.TypeParameters, func(v *TypeParameter) *destpb.TypeParameter { return v.ToProto() }),
		Fields:         sliceMap(x.Fields, func(v *Field) *destpb.Field { return v.ToProto() }),
		Metadata:       sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
	}
}

func DataFromProto(v *destpb.Data) (out *Data, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Data{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Export, err = orZeroR(result.From(ptr(bool(v.Export)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Export: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.TypeParameters, err = sliceMapR(v.TypeParameters, func(v *destpb.TypeParameter) result.Result[*TypeParameter] {
		return result.From(TypeParameterFromProto(v))
	}).Result(); err != nil {
		return nil, fmt.Errorf("TypeParameters: %w", err)
	}
	if out.Fields, err = sliceMapR(v.Fields, func(v *destpb.Field) result.Result[*Field] { return result.From(FieldFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Fields: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *Database) ToProto() *destpb.Database {
	if x == nil {
		return nil
	}
	return &destpb.Database{
		Pos:      x.Pos.ToProto(),
		Runtime:  x.Runtime.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Type:     orZero(ptr(string(x.Type))),
		Name:     orZero(ptr(string(x.Name))),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
	}
}

func DatabaseFromProto(v *destpb.Database) (out *Database, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Database{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Runtime, err = result.From(DatabaseRuntimeFromProto(v.Runtime)).Result(); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Type, err = orZeroR(result.From(ptr(string(v.Type)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

// DatabaseConnectorToProto converts a DatabaseConnector sum type to a protobuf message.
func DatabaseConnectorToProto(value DatabaseConnector) *destpb.DatabaseConnector {
	switch value := value.(type) {
	case nil:
		return nil
	case *AWSIAMAuthDatabaseConnector:
		return &destpb.DatabaseConnector{
			Value: &destpb.DatabaseConnector_AwsiamAuthDatabaseConnector{value.ToProto()},
		}
	case *DSNDatabaseConnector:
		return &destpb.DatabaseConnector{
			Value: &destpb.DatabaseConnector_DsnDatabaseConnector{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DatabaseConnectorFromProto(v *destpb.DatabaseConnector) (DatabaseConnector, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.DatabaseConnector_AwsiamAuthDatabaseConnector:
		return AWSIAMAuthDatabaseConnectorFromProto(v.GetAwsiamAuthDatabaseConnector())
	case *destpb.DatabaseConnector_DsnDatabaseConnector:
		return DSNDatabaseConnectorFromProto(v.GetDsnDatabaseConnector())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *DatabaseRuntime) ToProto() *destpb.DatabaseRuntime {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntime{
		Connections: x.Connections.ToProto(),
	}
}

func DatabaseRuntimeFromProto(v *destpb.DatabaseRuntime) (out *DatabaseRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DatabaseRuntime{}
	if out.Connections, err = result.From(DatabaseRuntimeConnectionsFromProto(v.Connections)).Result(); err != nil {
		return nil, fmt.Errorf("Connections: %w", err)
	}
	return out, nil
}

func (x *DatabaseRuntimeConnections) ToProto() *destpb.DatabaseRuntimeConnections {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntimeConnections{
		Read:  DatabaseConnectorToProto(x.Read),
		Write: DatabaseConnectorToProto(x.Write),
	}
}

func DatabaseRuntimeConnectionsFromProto(v *destpb.DatabaseRuntimeConnections) (out *DatabaseRuntimeConnections, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DatabaseRuntimeConnections{}
	if out.Read, err = orZeroR(ptrR(result.From(DatabaseConnectorFromProto(v.Read)))).Result(); err != nil {
		return nil, fmt.Errorf("Read: %w", err)
	}
	if out.Write, err = orZeroR(ptrR(result.From(DatabaseConnectorFromProto(v.Write)))).Result(); err != nil {
		return nil, fmt.Errorf("Write: %w", err)
	}
	return out, nil
}

// DeclToProto converts a Decl sum type to a protobuf message.
func DeclToProto(value Decl) *destpb.Decl {
	switch value := value.(type) {
	case nil:
		return nil
	case *Config:
		return &destpb.Decl{
			Value: &destpb.Decl_Config{value.ToProto()},
		}
	case *Data:
		return &destpb.Decl{
			Value: &destpb.Decl_Data{value.ToProto()},
		}
	case *Database:
		return &destpb.Decl{
			Value: &destpb.Decl_Database{value.ToProto()},
		}
	case *Enum:
		return &destpb.Decl{
			Value: &destpb.Decl_Enum{value.ToProto()},
		}
	case *Secret:
		return &destpb.Decl{
			Value: &destpb.Decl_Secret{value.ToProto()},
		}
	case *Topic:
		return &destpb.Decl{
			Value: &destpb.Decl_Topic{value.ToProto()},
		}
	case *TypeAlias:
		return &destpb.Decl{
			Value: &destpb.Decl_TypeAlias{value.ToProto()},
		}
	case *Verb:
		return &destpb.Decl{
			Value: &destpb.Decl_Verb{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DeclFromProto(v *destpb.Decl) (Decl, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Decl_Config:
		return ConfigFromProto(v.GetConfig())
	case *destpb.Decl_Data:
		return DataFromProto(v.GetData())
	case *destpb.Decl_Database:
		return DatabaseFromProto(v.GetDatabase())
	case *destpb.Decl_Enum:
		return EnumFromProto(v.GetEnum())
	case *destpb.Decl_Secret:
		return SecretFromProto(v.GetSecret())
	case *destpb.Decl_Topic:
		return TopicFromProto(v.GetTopic())
	case *destpb.Decl_TypeAlias:
		return TypeAliasFromProto(v.GetTypeAlias())
	case *destpb.Decl_Verb:
		return VerbFromProto(v.GetVerb())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *DeploymentCreatedEvent) ToProto() *destpb.DeploymentCreatedEvent {
	if x == nil {
		return nil
	}
	return &destpb.DeploymentCreatedEvent{
		Key:       orZero(ptr(string(protoMust(x.Key.MarshalText())))),
		Schema:    x.Schema.ToProto(),
		Changeset: orZero(ptr(string(protoMust(x.Changeset.MarshalText())))),
	}
}

func DeploymentCreatedEventFromProto(v *destpb.DeploymentCreatedEvent) (out *DeploymentCreatedEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DeploymentCreatedEvent{}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if out.Schema, err = result.From(ModuleFromProto(v.Schema)).Result(); err != nil {
		return nil, fmt.Errorf("Schema: %w", err)
	}
	if out.Changeset, err = unmarshallText([]byte(v.Changeset), out.Changeset).Result(); err != nil {
		return nil, fmt.Errorf("Changeset: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *DeploymentRuntimeEvent) ToProto() *destpb.DeploymentRuntimeEvent {
	if x == nil {
		return nil
	}
	return &destpb.DeploymentRuntimeEvent{
		Payload:   x.Payload.ToProto(),
		Changeset: orZero(ptr(string(protoMust(x.Changeset.MarshalText())))),
	}
}

func DeploymentRuntimeEventFromProto(v *destpb.DeploymentRuntimeEvent) (out *DeploymentRuntimeEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DeploymentRuntimeEvent{}
	if out.Payload, err = result.From(RuntimeElementFromProto(v.Payload)).Result(); err != nil {
		return nil, fmt.Errorf("Payload: %w", err)
	}
	if out.Changeset, err = unmarshallText([]byte(v.Changeset), out.Changeset).Result(); err != nil {
		return nil, fmt.Errorf("Changeset: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *DeploymentRuntimeNotification) ToProto() *destpb.DeploymentRuntimeNotification {
	if x == nil {
		return nil
	}
	return &destpb.DeploymentRuntimeNotification{
		Payload:   x.Payload.ToProto(),
		Changeset: orZero(ptr(string(protoMust(x.Changeset.MarshalText())))),
	}
}

func DeploymentRuntimeNotificationFromProto(v *destpb.DeploymentRuntimeNotification) (out *DeploymentRuntimeNotification, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DeploymentRuntimeNotification{}
	if out.Payload, err = result.From(RuntimeElementFromProto(v.Payload)).Result(); err != nil {
		return nil, fmt.Errorf("Payload: %w", err)
	}
	if out.Changeset, err = unmarshallText([]byte(v.Changeset), out.Changeset).Result(); err != nil {
		return nil, fmt.Errorf("Changeset: %w", err)
	}
	return out, nil
}

func (x DeploymentState) ToProto() destpb.DeploymentState {
	return destpb.DeploymentState(x)
}

func DeploymentStateFromProto(v destpb.DeploymentState) (DeploymentState, error) {
	// TODO: Check if the value is valid.
	return DeploymentState(v), nil
}

func (x *Enum) ToProto() *destpb.Enum {
	if x == nil {
		return nil
	}
	return &destpb.Enum{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Export:   orZero(ptr(bool(x.Export))),
		Name:     orZero(ptr(string(x.Name))),
		Type:     TypeToProto(x.Type),
		Variants: sliceMap(x.Variants, func(v *EnumVariant) *destpb.EnumVariant { return v.ToProto() }),
	}
}

func EnumFromProto(v *destpb.Enum) (out *Enum, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Enum{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Export, err = orZeroR(result.From(ptr(bool(v.Export)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Export: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Variants, err = sliceMapR(v.Variants, func(v *destpb.EnumVariant) result.Result[*EnumVariant] { return result.From(EnumVariantFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Variants: %w", err)
	}
	return out, nil
}

func (x *EnumVariant) ToProto() *destpb.EnumVariant {
	if x == nil {
		return nil
	}
	return &destpb.EnumVariant{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Name:     orZero(ptr(string(x.Name))),
		Value:    ValueToProto(x.Value),
	}
}

func EnumVariantFromProto(v *destpb.EnumVariant) (out *EnumVariant, err error) {
	if v == nil {
		return nil, nil
	}

	out = &EnumVariant{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Value, err = orZeroR(ptrR(result.From(ValueFromProto(v.Value)))).Result(); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

// EventToProto converts a Event sum type to a protobuf message.
func EventToProto(value Event) *destpb.Event {
	switch value := value.(type) {
	case nil:
		return nil
	case *ChangesetCommittedEvent:
		return &destpb.Event{
			Value: &destpb.Event_ChangesetCommittedEvent{value.ToProto()},
		}
	case *ChangesetCreatedEvent:
		return &destpb.Event{
			Value: &destpb.Event_ChangesetCreatedEvent{value.ToProto()},
		}
	case *ChangesetDrainedEvent:
		return &destpb.Event{
			Value: &destpb.Event_ChangesetDrainedEvent{value.ToProto()},
		}
	case *ChangesetFailedEvent:
		return &destpb.Event{
			Value: &destpb.Event_ChangesetFailedEvent{value.ToProto()},
		}
	case *ChangesetFinalizedEvent:
		return &destpb.Event{
			Value: &destpb.Event_ChangesetFinalizedEvent{value.ToProto()},
		}
	case *ChangesetPreparedEvent:
		return &destpb.Event{
			Value: &destpb.Event_ChangesetPreparedEvent{value.ToProto()},
		}
	case *DeploymentCreatedEvent:
		return &destpb.Event{
			Value: &destpb.Event_DeploymentCreatedEvent{value.ToProto()},
		}
	case *DeploymentRuntimeEvent:
		return &destpb.Event{
			Value: &destpb.Event_DeploymentRuntimeEvent{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func EventFromProto(v *destpb.Event) (Event, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Event_ChangesetCommittedEvent:
		return ChangesetCommittedEventFromProto(v.GetChangesetCommittedEvent())
	case *destpb.Event_ChangesetCreatedEvent:
		return ChangesetCreatedEventFromProto(v.GetChangesetCreatedEvent())
	case *destpb.Event_ChangesetDrainedEvent:
		return ChangesetDrainedEventFromProto(v.GetChangesetDrainedEvent())
	case *destpb.Event_ChangesetFailedEvent:
		return ChangesetFailedEventFromProto(v.GetChangesetFailedEvent())
	case *destpb.Event_ChangesetFinalizedEvent:
		return ChangesetFinalizedEventFromProto(v.GetChangesetFinalizedEvent())
	case *destpb.Event_ChangesetPreparedEvent:
		return ChangesetPreparedEventFromProto(v.GetChangesetPreparedEvent())
	case *destpb.Event_DeploymentCreatedEvent:
		return DeploymentCreatedEventFromProto(v.GetDeploymentCreatedEvent())
	case *destpb.Event_DeploymentRuntimeEvent:
		return DeploymentRuntimeEventFromProto(v.GetDeploymentRuntimeEvent())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Field) ToProto() *destpb.Field {
	if x == nil {
		return nil
	}
	return &destpb.Field{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Name:     orZero(ptr(string(x.Name))),
		Type:     TypeToProto(x.Type),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
	}
}

func FieldFromProto(v *destpb.Field) (out *Field, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Field{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *Float) ToProto() *destpb.Float {
	if x == nil {
		return nil
	}
	return &destpb.Float{
		Pos: x.Pos.ToProto(),
	}
}

func FloatFromProto(v *destpb.Float) (out *Float, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Float{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x FromOffset) ToProto() destpb.FromOffset {
	return destpb.FromOffset(x)
}

func FromOffsetFromProto(v destpb.FromOffset) (FromOffset, error) {
	// TODO: Check if the value is valid.
	return FromOffset(v), nil
}

func (x *FullSchemaNotification) ToProto() *destpb.FullSchemaNotification {
	if x == nil {
		return nil
	}
	return &destpb.FullSchemaNotification{
		Schema:     x.Schema.ToProto(),
		Changesets: sliceMap(x.Changesets, func(v *Changeset) *destpb.Changeset { return v.ToProto() }),
	}
}

func FullSchemaNotificationFromProto(v *destpb.FullSchemaNotification) (out *FullSchemaNotification, err error) {
	if v == nil {
		return nil, nil
	}

	out = &FullSchemaNotification{}
	if out.Schema, err = result.From(SchemaFromProto(v.Schema)).Result(); err != nil {
		return nil, fmt.Errorf("Schema: %w", err)
	}
	if out.Changesets, err = sliceMapR(v.Changesets, func(v *destpb.Changeset) result.Result[*Changeset] { return result.From(ChangesetFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Changesets: %w", err)
	}
	return out, nil
}

// IngressPathComponentToProto converts a IngressPathComponent sum type to a protobuf message.
func IngressPathComponentToProto(value IngressPathComponent) *destpb.IngressPathComponent {
	switch value := value.(type) {
	case nil:
		return nil
	case *IngressPathLiteral:
		return &destpb.IngressPathComponent{
			Value: &destpb.IngressPathComponent_IngressPathLiteral{value.ToProto()},
		}
	case *IngressPathParameter:
		return &destpb.IngressPathComponent{
			Value: &destpb.IngressPathComponent_IngressPathParameter{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func IngressPathComponentFromProto(v *destpb.IngressPathComponent) (IngressPathComponent, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.IngressPathComponent_IngressPathLiteral:
		return IngressPathLiteralFromProto(v.GetIngressPathLiteral())
	case *destpb.IngressPathComponent_IngressPathParameter:
		return IngressPathParameterFromProto(v.GetIngressPathParameter())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *IngressPathLiteral) ToProto() *destpb.IngressPathLiteral {
	if x == nil {
		return nil
	}
	return &destpb.IngressPathLiteral{
		Pos:  x.Pos.ToProto(),
		Text: orZero(ptr(string(x.Text))),
	}
}

func IngressPathLiteralFromProto(v *destpb.IngressPathLiteral) (out *IngressPathLiteral, err error) {
	if v == nil {
		return nil, nil
	}

	out = &IngressPathLiteral{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Text, err = orZeroR(result.From(ptr(string(v.Text)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Text: %w", err)
	}
	return out, nil
}

func (x *IngressPathParameter) ToProto() *destpb.IngressPathParameter {
	if x == nil {
		return nil
	}
	return &destpb.IngressPathParameter{
		Pos:  x.Pos.ToProto(),
		Name: orZero(ptr(string(x.Name))),
	}
}

func IngressPathParameterFromProto(v *destpb.IngressPathParameter) (out *IngressPathParameter, err error) {
	if v == nil {
		return nil, nil
	}

	out = &IngressPathParameter{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	return out, nil
}

func (x *Int) ToProto() *destpb.Int {
	if x == nil {
		return nil
	}
	return &destpb.Int{
		Pos: x.Pos.ToProto(),
	}
}

func IntFromProto(v *destpb.Int) (out *Int, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Int{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *IntValue) ToProto() *destpb.IntValue {
	if x == nil {
		return nil
	}
	return &destpb.IntValue{
		Pos:   x.Pos.ToProto(),
		Value: orZero(ptr(int64(x.Value))),
	}
}

func IntValueFromProto(v *destpb.IntValue) (out *IntValue, err error) {
	if v == nil {
		return nil, nil
	}

	out = &IntValue{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Value, err = orZeroR(result.From(ptr(int(v.Value)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

func (x *Map) ToProto() *destpb.Map {
	if x == nil {
		return nil
	}
	return &destpb.Map{
		Pos:   x.Pos.ToProto(),
		Key:   TypeToProto(x.Key),
		Value: TypeToProto(x.Value),
	}
}

func MapFromProto(v *destpb.Map) (out *Map, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Map{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Key, err = orZeroR(ptrR(result.From(TypeFromProto(v.Key)))).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if out.Value, err = orZeroR(ptrR(result.From(TypeFromProto(v.Value)))).Result(); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

// MetadataToProto converts a Metadata sum type to a protobuf message.
func MetadataToProto(value Metadata) *destpb.Metadata {
	switch value := value.(type) {
	case nil:
		return nil
	case *MetadataAlias:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Alias{value.ToProto()},
		}
	case *MetadataArtefact:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Artefact{value.ToProto()},
		}
	case *MetadataCalls:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Calls{value.ToProto()},
		}
	case *MetadataConfig:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Config{value.ToProto()},
		}
	case *MetadataCronJob:
		return &destpb.Metadata{
			Value: &destpb.Metadata_CronJob{value.ToProto()},
		}
	case *MetadataDatabases:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Databases{value.ToProto()},
		}
	case *MetadataEncoding:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Encoding{value.ToProto()},
		}
	case *MetadataIngress:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Ingress{value.ToProto()},
		}
	case *MetadataPartitions:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Partitions{value.ToProto()},
		}
	case *MetadataPublisher:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Publisher{value.ToProto()},
		}
	case *MetadataRetry:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Retry{value.ToProto()},
		}
	case *MetadataSQLColumn:
		return &destpb.Metadata{
			Value: &destpb.Metadata_SqlColumn{value.ToProto()},
		}
	case *MetadataSQLMigration:
		return &destpb.Metadata{
			Value: &destpb.Metadata_SqlMigration{value.ToProto()},
		}
	case *MetadataSQLQuery:
		return &destpb.Metadata{
			Value: &destpb.Metadata_SqlQuery{value.ToProto()},
		}
	case *MetadataSecrets:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Secrets{value.ToProto()},
		}
	case *MetadataSubscriber:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Subscriber{value.ToProto()},
		}
	case *MetadataTypeMap:
		return &destpb.Metadata{
			Value: &destpb.Metadata_TypeMap{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func MetadataFromProto(v *destpb.Metadata) (Metadata, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Metadata_Alias:
		return MetadataAliasFromProto(v.GetAlias())
	case *destpb.Metadata_Artefact:
		return MetadataArtefactFromProto(v.GetArtefact())
	case *destpb.Metadata_Calls:
		return MetadataCallsFromProto(v.GetCalls())
	case *destpb.Metadata_Config:
		return MetadataConfigFromProto(v.GetConfig())
	case *destpb.Metadata_CronJob:
		return MetadataCronJobFromProto(v.GetCronJob())
	case *destpb.Metadata_Databases:
		return MetadataDatabasesFromProto(v.GetDatabases())
	case *destpb.Metadata_Encoding:
		return MetadataEncodingFromProto(v.GetEncoding())
	case *destpb.Metadata_Ingress:
		return MetadataIngressFromProto(v.GetIngress())
	case *destpb.Metadata_Partitions:
		return MetadataPartitionsFromProto(v.GetPartitions())
	case *destpb.Metadata_Publisher:
		return MetadataPublisherFromProto(v.GetPublisher())
	case *destpb.Metadata_Retry:
		return MetadataRetryFromProto(v.GetRetry())
	case *destpb.Metadata_SqlColumn:
		return MetadataSQLColumnFromProto(v.GetSqlColumn())
	case *destpb.Metadata_SqlMigration:
		return MetadataSQLMigrationFromProto(v.GetSqlMigration())
	case *destpb.Metadata_SqlQuery:
		return MetadataSQLQueryFromProto(v.GetSqlQuery())
	case *destpb.Metadata_Secrets:
		return MetadataSecretsFromProto(v.GetSecrets())
	case *destpb.Metadata_Subscriber:
		return MetadataSubscriberFromProto(v.GetSubscriber())
	case *destpb.Metadata_TypeMap:
		return MetadataTypeMapFromProto(v.GetTypeMap())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *MetadataAlias) ToProto() *destpb.MetadataAlias {
	if x == nil {
		return nil
	}
	return &destpb.MetadataAlias{
		Pos:   x.Pos.ToProto(),
		Kind:  orZero(ptr(x.Kind.ToProto())),
		Alias: orZero(ptr(string(x.Alias))),
	}
}

func MetadataAliasFromProto(v *destpb.MetadataAlias) (out *MetadataAlias, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataAlias{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Kind, err = orZeroR(ptrR(result.From(AliasKindFromProto(v.Kind)))).Result(); err != nil {
		return nil, fmt.Errorf("Kind: %w", err)
	}
	if out.Alias, err = orZeroR(result.From(ptr(string(v.Alias)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Alias: %w", err)
	}
	return out, nil
}

func (x *MetadataArtefact) ToProto() *destpb.MetadataArtefact {
	if x == nil {
		return nil
	}
	return &destpb.MetadataArtefact{
		Pos:        x.Pos.ToProto(),
		Path:       orZero(ptr(string(x.Path))),
		Digest:     orZero(ptr(string(x.Digest))),
		Executable: orZero(ptr(bool(x.Executable))),
	}
}

func MetadataArtefactFromProto(v *destpb.MetadataArtefact) (out *MetadataArtefact, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataArtefact{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Path, err = orZeroR(result.From(ptr(string(v.Path)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Path: %w", err)
	}
	if out.Digest, err = orZeroR(result.From(ptr(string(v.Digest)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Digest: %w", err)
	}
	if out.Executable, err = orZeroR(result.From(ptr(bool(v.Executable)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Executable: %w", err)
	}
	return out, nil
}

func (x *MetadataCalls) ToProto() *destpb.MetadataCalls {
	if x == nil {
		return nil
	}
	return &destpb.MetadataCalls{
		Pos:   x.Pos.ToProto(),
		Calls: sliceMap(x.Calls, func(v *Ref) *destpb.Ref { return v.ToProto() }),
	}
}

func MetadataCallsFromProto(v *destpb.MetadataCalls) (out *MetadataCalls, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataCalls{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Calls, err = sliceMapR(v.Calls, func(v *destpb.Ref) result.Result[*Ref] { return result.From(RefFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Calls: %w", err)
	}
	return out, nil
}

func (x *MetadataConfig) ToProto() *destpb.MetadataConfig {
	if x == nil {
		return nil
	}
	return &destpb.MetadataConfig{
		Pos:    x.Pos.ToProto(),
		Config: sliceMap(x.Config, func(v *Ref) *destpb.Ref { return v.ToProto() }),
	}
}

func MetadataConfigFromProto(v *destpb.MetadataConfig) (out *MetadataConfig, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataConfig{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Config, err = sliceMapR(v.Config, func(v *destpb.Ref) result.Result[*Ref] { return result.From(RefFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Config: %w", err)
	}
	return out, nil
}

func (x *MetadataCronJob) ToProto() *destpb.MetadataCronJob {
	if x == nil {
		return nil
	}
	return &destpb.MetadataCronJob{
		Pos:  x.Pos.ToProto(),
		Cron: orZero(ptr(string(x.Cron))),
	}
}

func MetadataCronJobFromProto(v *destpb.MetadataCronJob) (out *MetadataCronJob, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataCronJob{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Cron, err = orZeroR(result.From(ptr(string(v.Cron)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Cron: %w", err)
	}
	return out, nil
}

func (x *MetadataDatabases) ToProto() *destpb.MetadataDatabases {
	if x == nil {
		return nil
	}
	return &destpb.MetadataDatabases{
		Pos:   x.Pos.ToProto(),
		Calls: sliceMap(x.Calls, func(v *Ref) *destpb.Ref { return v.ToProto() }),
	}
}

func MetadataDatabasesFromProto(v *destpb.MetadataDatabases) (out *MetadataDatabases, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataDatabases{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Calls, err = sliceMapR(v.Calls, func(v *destpb.Ref) result.Result[*Ref] { return result.From(RefFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Calls: %w", err)
	}
	return out, nil
}

func (x *MetadataEncoding) ToProto() *destpb.MetadataEncoding {
	if x == nil {
		return nil
	}
	return &destpb.MetadataEncoding{
		Pos:     x.Pos.ToProto(),
		Type:    orZero(ptr(string(x.Type))),
		Lenient: orZero(ptr(bool(x.Lenient))),
	}
}

func MetadataEncodingFromProto(v *destpb.MetadataEncoding) (out *MetadataEncoding, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataEncoding{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Type, err = orZeroR(result.From(ptr(string(v.Type)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Lenient, err = orZeroR(result.From(ptr(bool(v.Lenient)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Lenient: %w", err)
	}
	return out, nil
}

func (x *MetadataIngress) ToProto() *destpb.MetadataIngress {
	if x == nil {
		return nil
	}
	return &destpb.MetadataIngress{
		Pos:    x.Pos.ToProto(),
		Type:   orZero(ptr(string(x.Type))),
		Method: orZero(ptr(string(x.Method))),
		Path:   sliceMap(x.Path, func(v IngressPathComponent) *destpb.IngressPathComponent { return IngressPathComponentToProto(v) }),
	}
}

func MetadataIngressFromProto(v *destpb.MetadataIngress) (out *MetadataIngress, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataIngress{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Type, err = orZeroR(result.From(ptr(string(v.Type)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Method, err = orZeroR(result.From(ptr(string(v.Method)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Method: %w", err)
	}
	if out.Path, err = sliceMapR(v.Path, func(v *destpb.IngressPathComponent) result.Result[IngressPathComponent] {
		return orZeroR(ptrR(result.From(IngressPathComponentFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Path: %w", err)
	}
	return out, nil
}

func (x *MetadataPartitions) ToProto() *destpb.MetadataPartitions {
	if x == nil {
		return nil
	}
	return &destpb.MetadataPartitions{
		Pos:        x.Pos.ToProto(),
		Partitions: orZero(ptr(int64(x.Partitions))),
	}
}

func MetadataPartitionsFromProto(v *destpb.MetadataPartitions) (out *MetadataPartitions, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataPartitions{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Partitions, err = orZeroR(result.From(ptr(int(v.Partitions)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Partitions: %w", err)
	}
	return out, nil
}

func (x *MetadataPublisher) ToProto() *destpb.MetadataPublisher {
	if x == nil {
		return nil
	}
	return &destpb.MetadataPublisher{
		Pos:    x.Pos.ToProto(),
		Topics: sliceMap(x.Topics, func(v *Ref) *destpb.Ref { return v.ToProto() }),
	}
}

func MetadataPublisherFromProto(v *destpb.MetadataPublisher) (out *MetadataPublisher, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataPublisher{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Topics, err = sliceMapR(v.Topics, func(v *destpb.Ref) result.Result[*Ref] { return result.From(RefFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Topics: %w", err)
	}
	return out, nil
}

func (x *MetadataRetry) ToProto() *destpb.MetadataRetry {
	if x == nil {
		return nil
	}
	return &destpb.MetadataRetry{
		Pos:        x.Pos.ToProto(),
		Count:      setNil(ptr(int64(orZero(x.Count))), x.Count),
		MinBackoff: orZero(ptr(string(x.MinBackoff))),
		MaxBackoff: orZero(ptr(string(x.MaxBackoff))),
		Catch:      x.Catch.ToProto(),
	}
}

func MetadataRetryFromProto(v *destpb.MetadataRetry) (out *MetadataRetry, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataRetry{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Count, err = result.From(setNil(ptr(int(orZero(v.Count))), v.Count), nil).Result(); err != nil {
		return nil, fmt.Errorf("Count: %w", err)
	}
	if out.MinBackoff, err = orZeroR(result.From(ptr(string(v.MinBackoff)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("MinBackoff: %w", err)
	}
	if out.MaxBackoff, err = orZeroR(result.From(ptr(string(v.MaxBackoff)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("MaxBackoff: %w", err)
	}
	if out.Catch, err = result.From(RefFromProto(v.Catch)).Result(); err != nil {
		return nil, fmt.Errorf("Catch: %w", err)
	}
	return out, nil
}

func (x *MetadataSQLColumn) ToProto() *destpb.MetadataSQLColumn {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSQLColumn{
		Pos:   x.Pos.ToProto(),
		Table: orZero(ptr(string(x.Table))),
		Name:  orZero(ptr(string(x.Name))),
	}
}

func MetadataSQLColumnFromProto(v *destpb.MetadataSQLColumn) (out *MetadataSQLColumn, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSQLColumn{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Table, err = orZeroR(result.From(ptr(string(v.Table)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Table: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	return out, nil
}

func (x *MetadataSQLMigration) ToProto() *destpb.MetadataSQLMigration {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSQLMigration{
		Pos:    x.Pos.ToProto(),
		Digest: orZero(ptr(string(x.Digest))),
	}
}

func MetadataSQLMigrationFromProto(v *destpb.MetadataSQLMigration) (out *MetadataSQLMigration, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSQLMigration{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Digest, err = orZeroR(result.From(ptr(string(v.Digest)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Digest: %w", err)
	}
	return out, nil
}

func (x *MetadataSQLQuery) ToProto() *destpb.MetadataSQLQuery {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSQLQuery{
		Pos:     x.Pos.ToProto(),
		Command: orZero(ptr(string(x.Command))),
		Query:   orZero(ptr(string(x.Query))),
	}
}

func MetadataSQLQueryFromProto(v *destpb.MetadataSQLQuery) (out *MetadataSQLQuery, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSQLQuery{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Command, err = orZeroR(result.From(ptr(string(v.Command)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Command: %w", err)
	}
	if out.Query, err = orZeroR(result.From(ptr(string(v.Query)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Query: %w", err)
	}
	return out, nil
}

func (x *MetadataSecrets) ToProto() *destpb.MetadataSecrets {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSecrets{
		Pos:     x.Pos.ToProto(),
		Secrets: sliceMap(x.Secrets, func(v *Ref) *destpb.Ref { return v.ToProto() }),
	}
}

func MetadataSecretsFromProto(v *destpb.MetadataSecrets) (out *MetadataSecrets, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSecrets{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Secrets, err = sliceMapR(v.Secrets, func(v *destpb.Ref) result.Result[*Ref] { return result.From(RefFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Secrets: %w", err)
	}
	return out, nil
}

func (x *MetadataSubscriber) ToProto() *destpb.MetadataSubscriber {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSubscriber{
		Pos:        x.Pos.ToProto(),
		Topic:      x.Topic.ToProto(),
		FromOffset: orZero(ptr(x.FromOffset.ToProto())),
		DeadLetter: orZero(ptr(bool(x.DeadLetter))),
	}
}

func MetadataSubscriberFromProto(v *destpb.MetadataSubscriber) (out *MetadataSubscriber, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSubscriber{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Topic, err = result.From(RefFromProto(v.Topic)).Result(); err != nil {
		return nil, fmt.Errorf("Topic: %w", err)
	}
	if out.FromOffset, err = orZeroR(ptrR(result.From(FromOffsetFromProto(v.FromOffset)))).Result(); err != nil {
		return nil, fmt.Errorf("FromOffset: %w", err)
	}
	if out.DeadLetter, err = orZeroR(result.From(ptr(bool(v.DeadLetter)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("DeadLetter: %w", err)
	}
	return out, nil
}

func (x *MetadataTypeMap) ToProto() *destpb.MetadataTypeMap {
	if x == nil {
		return nil
	}
	return &destpb.MetadataTypeMap{
		Pos:        x.Pos.ToProto(),
		Runtime:    orZero(ptr(string(x.Runtime))),
		NativeName: orZero(ptr(string(x.NativeName))),
	}
}

func MetadataTypeMapFromProto(v *destpb.MetadataTypeMap) (out *MetadataTypeMap, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataTypeMap{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Runtime, err = orZeroR(result.From(ptr(string(v.Runtime)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	if out.NativeName, err = orZeroR(result.From(ptr(string(v.NativeName)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("NativeName: %w", err)
	}
	return out, nil
}

func (x *Module) ToProto() *destpb.Module {
	if x == nil {
		return nil
	}
	return &destpb.Module{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Builtin:  orZero(ptr(bool(x.Builtin))),
		Name:     orZero(ptr(string(x.Name))),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
		Decls:    sliceMap(x.Decls, func(v Decl) *destpb.Decl { return DeclToProto(v) }),
		Runtime:  x.Runtime.ToProto(),
	}
}

func ModuleFromProto(v *destpb.Module) (out *Module, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Module{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Builtin, err = orZeroR(result.From(ptr(bool(v.Builtin)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Builtin: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	if out.Decls, err = sliceMapR(v.Decls, func(v *destpb.Decl) result.Result[Decl] { return orZeroR(ptrR(result.From(DeclFromProto(v)))) }).Result(); err != nil {
		return nil, fmt.Errorf("Decls: %w", err)
	}
	if out.Runtime, err = result.From(ModuleRuntimeFromProto(v.Runtime)).Result(); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *ModuleRuntime) ToProto() *destpb.ModuleRuntime {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntime{
		Base:       x.Base.ToProto(),
		Scaling:    x.Scaling.ToProto(),
		Deployment: x.Deployment.ToProto(),
		Runner:     x.Runner.ToProto(),
	}
}

func ModuleRuntimeFromProto(v *destpb.ModuleRuntime) (out *ModuleRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntime{}
	if out.Base, err = orZeroR(result.From(ModuleRuntimeBaseFromProto(v.Base))).Result(); err != nil {
		return nil, fmt.Errorf("Base: %w", err)
	}
	if out.Scaling, err = result.From(ModuleRuntimeScalingFromProto(v.Scaling)).Result(); err != nil {
		return nil, fmt.Errorf("Scaling: %w", err)
	}
	if out.Deployment, err = result.From(ModuleRuntimeDeploymentFromProto(v.Deployment)).Result(); err != nil {
		return nil, fmt.Errorf("Deployment: %w", err)
	}
	if out.Runner, err = result.From(ModuleRuntimeRunnerFromProto(v.Runner)).Result(); err != nil {
		return nil, fmt.Errorf("Runner: %w", err)
	}
	return out, nil
}

func (x *ModuleRuntimeBase) ToProto() *destpb.ModuleRuntimeBase {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeBase{
		CreateTime: timestamppb.New(x.CreateTime),
		Language:   orZero(ptr(string(x.Language))),
		Os:         ptr(string(x.OS)),
		Arch:       ptr(string(x.Arch)),
		Image:      ptr(string(x.Image)),
	}
}

func ModuleRuntimeBaseFromProto(v *destpb.ModuleRuntimeBase) (out *ModuleRuntimeBase, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntimeBase{}
	if out.CreateTime, err = orZeroR(result.From(setNil(ptr(v.CreateTime.AsTime()), v.CreateTime), nil)).Result(); err != nil {
		return nil, fmt.Errorf("CreateTime: %w", err)
	}
	if out.Language, err = orZeroR(result.From(ptr(string(v.Language)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Language: %w", err)
	}
	if out.OS, err = orZeroR(result.From(setNil(ptr(string(orZero(v.Os))), v.Os), nil)).Result(); err != nil {
		return nil, fmt.Errorf("OS: %w", err)
	}
	if out.Arch, err = orZeroR(result.From(setNil(ptr(string(orZero(v.Arch))), v.Arch), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Arch: %w", err)
	}
	if out.Image, err = orZeroR(result.From(setNil(ptr(string(orZero(v.Image))), v.Image), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Image: %w", err)
	}
	return out, nil
}

func (x *ModuleRuntimeDeployment) ToProto() *destpb.ModuleRuntimeDeployment {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeDeployment{
		DeploymentKey: orZero(ptr(string(protoMust(x.DeploymentKey.MarshalText())))),
		CreatedAt:     timestamppb.New(x.CreatedAt),
		ActivatedAt:   setNil(timestamppb.New(orZero(x.ActivatedAt.Ptr())), x.ActivatedAt.Ptr()),
		State:         orZero(ptr(x.State.ToProto())),
	}
}

func ModuleRuntimeDeploymentFromProto(v *destpb.ModuleRuntimeDeployment) (out *ModuleRuntimeDeployment, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntimeDeployment{}
	if out.DeploymentKey, err = orZeroR(unmarshallText([]byte(v.DeploymentKey), &out.DeploymentKey)).Result(); err != nil {
		return nil, fmt.Errorf("DeploymentKey: %w", err)
	}
	if out.CreatedAt, err = orZeroR(result.From(setNil(ptr(v.CreatedAt.AsTime()), v.CreatedAt), nil)).Result(); err != nil {
		return nil, fmt.Errorf("CreatedAt: %w", err)
	}
	if out.ActivatedAt, err = optionalR(result.From(setNil(ptr(v.ActivatedAt.AsTime()), v.ActivatedAt), nil)).Result(); err != nil {
		return nil, fmt.Errorf("ActivatedAt: %w", err)
	}
	if out.State, err = orZeroR(ptrR(result.From(DeploymentStateFromProto(v.State)))).Result(); err != nil {
		return nil, fmt.Errorf("State: %w", err)
	}
	return out, nil
}

func (x *ModuleRuntimeRunner) ToProto() *destpb.ModuleRuntimeRunner {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeRunner{
		Endpoint: orZero(ptr(string(x.Endpoint))),
	}
}

func ModuleRuntimeRunnerFromProto(v *destpb.ModuleRuntimeRunner) (out *ModuleRuntimeRunner, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntimeRunner{}
	if out.Endpoint, err = orZeroR(result.From(ptr(string(v.Endpoint)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Endpoint: %w", err)
	}
	return out, nil
}

func (x *ModuleRuntimeScaling) ToProto() *destpb.ModuleRuntimeScaling {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeScaling{
		MinReplicas: orZero(ptr(int32(x.MinReplicas))),
	}
}

func ModuleRuntimeScalingFromProto(v *destpb.ModuleRuntimeScaling) (out *ModuleRuntimeScaling, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntimeScaling{}
	if out.MinReplicas, err = orZeroR(result.From(ptr(int32(v.MinReplicas)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("MinReplicas: %w", err)
	}
	return out, nil
}

// NotificationToProto converts a Notification sum type to a protobuf message.
func NotificationToProto(value Notification) *destpb.Notification {
	switch value := value.(type) {
	case nil:
		return nil
	case *ChangesetCommittedNotification:
		return &destpb.Notification{
			Value: &destpb.Notification_ChangesetCommittedNotification{value.ToProto()},
		}
	case *ChangesetCreatedNotification:
		return &destpb.Notification{
			Value: &destpb.Notification_ChangesetCreatedNotification{value.ToProto()},
		}
	case *ChangesetDrainedNotification:
		return &destpb.Notification{
			Value: &destpb.Notification_ChangesetDrainedNotification{value.ToProto()},
		}
	case *ChangesetFailedNotification:
		return &destpb.Notification{
			Value: &destpb.Notification_ChangesetFailedNotification{value.ToProto()},
		}
	case *ChangesetFinalizedNotification:
		return &destpb.Notification{
			Value: &destpb.Notification_ChangesetFinalizedNotification{value.ToProto()},
		}
	case *ChangesetPreparedNotification:
		return &destpb.Notification{
			Value: &destpb.Notification_ChangesetPreparedNotification{value.ToProto()},
		}
	case *ChangesetRollingBackNotification:
		return &destpb.Notification{
			Value: &destpb.Notification_ChangesetRollingBackNotification{value.ToProto()},
		}
	case *DeploymentRuntimeNotification:
		return &destpb.Notification{
			Value: &destpb.Notification_DeploymentRuntimeNotification{value.ToProto()},
		}
	case *FullSchemaNotification:
		return &destpb.Notification{
			Value: &destpb.Notification_FullSchemaNotification{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func NotificationFromProto(v *destpb.Notification) (Notification, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Notification_ChangesetCommittedNotification:
		return ChangesetCommittedNotificationFromProto(v.GetChangesetCommittedNotification())
	case *destpb.Notification_ChangesetCreatedNotification:
		return ChangesetCreatedNotificationFromProto(v.GetChangesetCreatedNotification())
	case *destpb.Notification_ChangesetDrainedNotification:
		return ChangesetDrainedNotificationFromProto(v.GetChangesetDrainedNotification())
	case *destpb.Notification_ChangesetFailedNotification:
		return ChangesetFailedNotificationFromProto(v.GetChangesetFailedNotification())
	case *destpb.Notification_ChangesetFinalizedNotification:
		return ChangesetFinalizedNotificationFromProto(v.GetChangesetFinalizedNotification())
	case *destpb.Notification_ChangesetPreparedNotification:
		return ChangesetPreparedNotificationFromProto(v.GetChangesetPreparedNotification())
	case *destpb.Notification_ChangesetRollingBackNotification:
		return ChangesetRollingBackNotificationFromProto(v.GetChangesetRollingBackNotification())
	case *destpb.Notification_DeploymentRuntimeNotification:
		return DeploymentRuntimeNotificationFromProto(v.GetDeploymentRuntimeNotification())
	case *destpb.Notification_FullSchemaNotification:
		return FullSchemaNotificationFromProto(v.GetFullSchemaNotification())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Optional) ToProto() *destpb.Optional {
	if x == nil {
		return nil
	}
	return &destpb.Optional{
		Pos:  x.Pos.ToProto(),
		Type: TypeToProto(x.Type),
	}
}

func OptionalFromProto(v *destpb.Optional) (out *Optional, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Optional{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	return out, nil
}

func (x *Position) ToProto() *destpb.Position {
	if x == nil {
		return nil
	}
	return &destpb.Position{
		Filename: orZero(ptr(string(x.Filename))),
		Line:     orZero(ptr(int64(x.Line))),
		Column:   orZero(ptr(int64(x.Column))),
	}
}

func PositionFromProto(v *destpb.Position) (out *Position, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Position{}
	if out.Filename, err = orZeroR(result.From(ptr(string(v.Filename)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Filename: %w", err)
	}
	if out.Line, err = orZeroR(result.From(ptr(int(v.Line)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Line: %w", err)
	}
	if out.Column, err = orZeroR(result.From(ptr(int(v.Column)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Column: %w", err)
	}
	return out, nil
}

func (x *Ref) ToProto() *destpb.Ref {
	if x == nil {
		return nil
	}
	return &destpb.Ref{
		Pos:            x.Pos.ToProto(),
		Module:         orZero(ptr(string(x.Module))),
		Name:           orZero(ptr(string(x.Name))),
		TypeParameters: sliceMap(x.TypeParameters, func(v Type) *destpb.Type { return TypeToProto(v) }),
	}
}

func RefFromProto(v *destpb.Ref) (out *Ref, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Ref{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Module, err = orZeroR(result.From(ptr(string(v.Module)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Module: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.TypeParameters, err = sliceMapR(v.TypeParameters, func(v *destpb.Type) result.Result[Type] { return orZeroR(ptrR(result.From(TypeFromProto(v)))) }).Result(); err != nil {
		return nil, fmt.Errorf("TypeParameters: %w", err)
	}
	return out, nil
}

// RuntimeToProto converts a Runtime sum type to a protobuf message.
func RuntimeToProto(value Runtime) *destpb.Runtime {
	switch value := value.(type) {
	case nil:
		return nil
	case *DatabaseRuntime:
		return &destpb.Runtime{
			Value: &destpb.Runtime_DatabaseRuntime{value.ToProto()},
		}
	case *ModuleRuntimeDeployment:
		return &destpb.Runtime{
			Value: &destpb.Runtime_ModuleRuntimeDeployment{value.ToProto()},
		}
	case *ModuleRuntimeRunner:
		return &destpb.Runtime{
			Value: &destpb.Runtime_ModuleRuntimeRunner{value.ToProto()},
		}
	case *ModuleRuntimeScaling:
		return &destpb.Runtime{
			Value: &destpb.Runtime_ModuleRuntimeScaling{value.ToProto()},
		}
	case *TopicRuntime:
		return &destpb.Runtime{
			Value: &destpb.Runtime_TopicRuntime{value.ToProto()},
		}
	case *VerbRuntime:
		return &destpb.Runtime{
			Value: &destpb.Runtime_VerbRuntime{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func RuntimeFromProto(v *destpb.Runtime) (Runtime, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Runtime_DatabaseRuntime:
		return DatabaseRuntimeFromProto(v.GetDatabaseRuntime())
	case *destpb.Runtime_ModuleRuntimeDeployment:
		return ModuleRuntimeDeploymentFromProto(v.GetModuleRuntimeDeployment())
	case *destpb.Runtime_ModuleRuntimeRunner:
		return ModuleRuntimeRunnerFromProto(v.GetModuleRuntimeRunner())
	case *destpb.Runtime_ModuleRuntimeScaling:
		return ModuleRuntimeScalingFromProto(v.GetModuleRuntimeScaling())
	case *destpb.Runtime_TopicRuntime:
		return TopicRuntimeFromProto(v.GetTopicRuntime())
	case *destpb.Runtime_VerbRuntime:
		return VerbRuntimeFromProto(v.GetVerbRuntime())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *RuntimeElement) ToProto() *destpb.RuntimeElement {
	if x == nil {
		return nil
	}
	return &destpb.RuntimeElement{
		Element:    RuntimeToProto(x.Element),
		Deployment: orZero(ptr(string(protoMust(x.Deployment.MarshalText())))),
		Name:       setNil(ptr(string(orZero(x.Name.Ptr()))), x.Name.Ptr()),
	}
}

func RuntimeElementFromProto(v *destpb.RuntimeElement) (out *RuntimeElement, err error) {
	if v == nil {
		return nil, nil
	}

	out = &RuntimeElement{}
	if out.Element, err = orZeroR(ptrR(result.From(RuntimeFromProto(v.Element)))).Result(); err != nil {
		return nil, fmt.Errorf("Element: %w", err)
	}
	if out.Deployment, err = orZeroR(unmarshallText([]byte(v.Deployment), &out.Deployment)).Result(); err != nil {
		return nil, fmt.Errorf("Deployment: %w", err)
	}
	if out.Name, err = optionalR(result.From(setNil(ptr(string(orZero(v.Name))), v.Name), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	return out, nil
}

func (x *Schema) ToProto() *destpb.Schema {
	if x == nil {
		return nil
	}
	return &destpb.Schema{
		Pos:     x.Pos.ToProto(),
		Modules: sliceMap(x.Modules, func(v *Module) *destpb.Module { return v.ToProto() }),
	}
}

func SchemaFromProto(v *destpb.Schema) (out *Schema, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Schema{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Modules, err = sliceMapR(v.Modules, func(v *destpb.Module) result.Result[*Module] { return result.From(ModuleFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Modules: %w", err)
	}
	return out, nil
}

func (x *SchemaState) ToProto() *destpb.SchemaState {
	if x == nil {
		return nil
	}
	return &destpb.SchemaState{
		Modules:          sliceMap(x.Modules, func(v *Module) *destpb.Module { return v.ToProto() }),
		Changesets:       sliceMap(x.Changesets, func(v *Changeset) *destpb.Changeset { return v.ToProto() }),
		ChangesetEvents:  sliceMap(x.ChangesetEvents, func(v *DeploymentRuntimeEvent) *destpb.DeploymentRuntimeEvent { return v.ToProto() }),
		DeploymentEvents: sliceMap(x.DeploymentEvents, func(v *DeploymentRuntimeEvent) *destpb.DeploymentRuntimeEvent { return v.ToProto() }),
	}
}

func SchemaStateFromProto(v *destpb.SchemaState) (out *SchemaState, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SchemaState{}
	if out.Modules, err = sliceMapR(v.Modules, func(v *destpb.Module) result.Result[*Module] { return result.From(ModuleFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Modules: %w", err)
	}
	if out.Changesets, err = sliceMapR(v.Changesets, func(v *destpb.Changeset) result.Result[*Changeset] { return result.From(ChangesetFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Changesets: %w", err)
	}
	if out.ChangesetEvents, err = sliceMapR(v.ChangesetEvents, func(v *destpb.DeploymentRuntimeEvent) result.Result[*DeploymentRuntimeEvent] {
		return result.From(DeploymentRuntimeEventFromProto(v))
	}).Result(); err != nil {
		return nil, fmt.Errorf("ChangesetEvents: %w", err)
	}
	if out.DeploymentEvents, err = sliceMapR(v.DeploymentEvents, func(v *destpb.DeploymentRuntimeEvent) result.Result[*DeploymentRuntimeEvent] {
		return result.From(DeploymentRuntimeEventFromProto(v))
	}).Result(); err != nil {
		return nil, fmt.Errorf("DeploymentEvents: %w", err)
	}
	return out, nil
}

func (x *Secret) ToProto() *destpb.Secret {
	if x == nil {
		return nil
	}
	return &destpb.Secret{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Name:     orZero(ptr(string(x.Name))),
		Type:     TypeToProto(x.Type),
	}
}

func SecretFromProto(v *destpb.Secret) (out *Secret, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Secret{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	return out, nil
}

func (x *String) ToProto() *destpb.String {
	if x == nil {
		return nil
	}
	return &destpb.String{
		Pos: x.Pos.ToProto(),
	}
}

func StringFromProto(v *destpb.String) (out *String, err error) {
	if v == nil {
		return nil, nil
	}

	out = &String{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *StringValue) ToProto() *destpb.StringValue {
	if x == nil {
		return nil
	}
	return &destpb.StringValue{
		Pos:   x.Pos.ToProto(),
		Value: orZero(ptr(string(x.Value))),
	}
}

func StringValueFromProto(v *destpb.StringValue) (out *StringValue, err error) {
	if v == nil {
		return nil, nil
	}

	out = &StringValue{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Value, err = orZeroR(result.From(ptr(string(v.Value)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

func (x *Time) ToProto() *destpb.Time {
	if x == nil {
		return nil
	}
	return &destpb.Time{
		Pos: x.Pos.ToProto(),
	}
}

func TimeFromProto(v *destpb.Time) (out *Time, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Time{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *Topic) ToProto() *destpb.Topic {
	if x == nil {
		return nil
	}
	return &destpb.Topic{
		Pos:      x.Pos.ToProto(),
		Runtime:  x.Runtime.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Export:   orZero(ptr(bool(x.Export))),
		Name:     orZero(ptr(string(x.Name))),
		Event:    TypeToProto(x.Event),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
	}
}

func TopicFromProto(v *destpb.Topic) (out *Topic, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Topic{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Runtime, err = result.From(TopicRuntimeFromProto(v.Runtime)).Result(); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Export, err = orZeroR(result.From(ptr(bool(v.Export)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Export: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Event, err = orZeroR(ptrR(result.From(TypeFromProto(v.Event)))).Result(); err != nil {
		return nil, fmt.Errorf("Event: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *TopicRuntime) ToProto() *destpb.TopicRuntime {
	if x == nil {
		return nil
	}
	return &destpb.TopicRuntime{
		KafkaBrokers: sliceMap(x.KafkaBrokers, func(v string) string { return orZero(ptr(string(v))) }),
		TopicId:      orZero(ptr(string(x.TopicID))),
	}
}

func TopicRuntimeFromProto(v *destpb.TopicRuntime) (out *TopicRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TopicRuntime{}
	if out.KafkaBrokers, err = sliceMapR(v.KafkaBrokers, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("KafkaBrokers: %w", err)
	}
	if out.TopicID, err = orZeroR(result.From(ptr(string(v.TopicId)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("TopicID: %w", err)
	}
	return out, nil
}

// TypeToProto converts a Type sum type to a protobuf message.
func TypeToProto(value Type) *destpb.Type {
	switch value := value.(type) {
	case nil:
		return nil
	case *Any:
		return &destpb.Type{
			Value: &destpb.Type_Any{value.ToProto()},
		}
	case *Array:
		return &destpb.Type{
			Value: &destpb.Type_Array{value.ToProto()},
		}
	case *Bool:
		return &destpb.Type{
			Value: &destpb.Type_Bool{value.ToProto()},
		}
	case *Bytes:
		return &destpb.Type{
			Value: &destpb.Type_Bytes{value.ToProto()},
		}
	case *Float:
		return &destpb.Type{
			Value: &destpb.Type_Float{value.ToProto()},
		}
	case *Int:
		return &destpb.Type{
			Value: &destpb.Type_Int{value.ToProto()},
		}
	case *Map:
		return &destpb.Type{
			Value: &destpb.Type_Map{value.ToProto()},
		}
	case *Optional:
		return &destpb.Type{
			Value: &destpb.Type_Optional{value.ToProto()},
		}
	case *Ref:
		return &destpb.Type{
			Value: &destpb.Type_Ref{value.ToProto()},
		}
	case *String:
		return &destpb.Type{
			Value: &destpb.Type_String_{value.ToProto()},
		}
	case *Time:
		return &destpb.Type{
			Value: &destpb.Type_Time{value.ToProto()},
		}
	case *Unit:
		return &destpb.Type{
			Value: &destpb.Type_Unit{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func TypeFromProto(v *destpb.Type) (Type, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Type_Any:
		return AnyFromProto(v.GetAny())
	case *destpb.Type_Array:
		return ArrayFromProto(v.GetArray())
	case *destpb.Type_Bool:
		return BoolFromProto(v.GetBool())
	case *destpb.Type_Bytes:
		return BytesFromProto(v.GetBytes())
	case *destpb.Type_Float:
		return FloatFromProto(v.GetFloat())
	case *destpb.Type_Int:
		return IntFromProto(v.GetInt())
	case *destpb.Type_Map:
		return MapFromProto(v.GetMap())
	case *destpb.Type_Optional:
		return OptionalFromProto(v.GetOptional())
	case *destpb.Type_Ref:
		return RefFromProto(v.GetRef())
	case *destpb.Type_String_:
		return StringFromProto(v.GetString_())
	case *destpb.Type_Time:
		return TimeFromProto(v.GetTime())
	case *destpb.Type_Unit:
		return UnitFromProto(v.GetUnit())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *TypeAlias) ToProto() *destpb.TypeAlias {
	if x == nil {
		return nil
	}
	return &destpb.TypeAlias{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Export:   orZero(ptr(bool(x.Export))),
		Name:     orZero(ptr(string(x.Name))),
		Type:     TypeToProto(x.Type),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
	}
}

func TypeAliasFromProto(v *destpb.TypeAlias) (out *TypeAlias, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TypeAlias{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Export, err = orZeroR(result.From(ptr(bool(v.Export)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Export: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *TypeParameter) ToProto() *destpb.TypeParameter {
	if x == nil {
		return nil
	}
	return &destpb.TypeParameter{
		Pos:  x.Pos.ToProto(),
		Name: orZero(ptr(string(x.Name))),
	}
}

func TypeParameterFromProto(v *destpb.TypeParameter) (out *TypeParameter, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TypeParameter{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	return out, nil
}

func (x *TypeValue) ToProto() *destpb.TypeValue {
	if x == nil {
		return nil
	}
	return &destpb.TypeValue{
		Pos:   x.Pos.ToProto(),
		Value: TypeToProto(x.Value),
	}
}

func TypeValueFromProto(v *destpb.TypeValue) (out *TypeValue, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TypeValue{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Value, err = orZeroR(ptrR(result.From(TypeFromProto(v.Value)))).Result(); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

func (x *Unit) ToProto() *destpb.Unit {
	if x == nil {
		return nil
	}
	return &destpb.Unit{
		Pos: x.Pos.ToProto(),
	}
}

func UnitFromProto(v *destpb.Unit) (out *Unit, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Unit{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

// ValueToProto converts a Value sum type to a protobuf message.
func ValueToProto(value Value) *destpb.Value {
	switch value := value.(type) {
	case nil:
		return nil
	case *IntValue:
		return &destpb.Value{
			Value: &destpb.Value_IntValue{value.ToProto()},
		}
	case *StringValue:
		return &destpb.Value{
			Value: &destpb.Value_StringValue{value.ToProto()},
		}
	case *TypeValue:
		return &destpb.Value{
			Value: &destpb.Value_TypeValue{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func ValueFromProto(v *destpb.Value) (Value, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Value_IntValue:
		return IntValueFromProto(v.GetIntValue())
	case *destpb.Value_StringValue:
		return StringValueFromProto(v.GetStringValue())
	case *destpb.Value_TypeValue:
		return TypeValueFromProto(v.GetTypeValue())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Verb) ToProto() *destpb.Verb {
	if x == nil {
		return nil
	}
	return &destpb.Verb{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Export:   orZero(ptr(bool(x.Export))),
		Name:     orZero(ptr(string(x.Name))),
		Request:  TypeToProto(x.Request),
		Response: TypeToProto(x.Response),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
		Runtime:  x.Runtime.ToProto(),
	}
}

func VerbFromProto(v *destpb.Verb) (out *Verb, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Verb{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Export, err = orZeroR(result.From(ptr(bool(v.Export)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Export: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Request, err = orZeroR(ptrR(result.From(TypeFromProto(v.Request)))).Result(); err != nil {
		return nil, fmt.Errorf("Request: %w", err)
	}
	if out.Response, err = orZeroR(ptrR(result.From(TypeFromProto(v.Response)))).Result(); err != nil {
		return nil, fmt.Errorf("Response: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	if out.Runtime, err = result.From(VerbRuntimeFromProto(v.Runtime)).Result(); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	return out, nil
}

func (x *VerbRuntime) ToProto() *destpb.VerbRuntime {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntime{
		Subscription: x.Subscription.ToProto(),
	}
}

func VerbRuntimeFromProto(v *destpb.VerbRuntime) (out *VerbRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &VerbRuntime{}
	if out.Subscription, err = result.From(VerbRuntimeSubscriptionFromProto(v.Subscription)).Result(); err != nil {
		return nil, fmt.Errorf("Subscription: %w", err)
	}
	return out, nil
}

func (x *VerbRuntimeSubscription) ToProto() *destpb.VerbRuntimeSubscription {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntimeSubscription{
		KafkaBrokers: sliceMap(x.KafkaBrokers, func(v string) string { return orZero(ptr(string(v))) }),
	}
}

func VerbRuntimeSubscriptionFromProto(v *destpb.VerbRuntimeSubscription) (out *VerbRuntimeSubscription, err error) {
	if v == nil {
		return nil, nil
	}

	out = &VerbRuntimeSubscription{}
	if out.KafkaBrokers, err = sliceMapR(v.KafkaBrokers, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("KafkaBrokers: %w", err)
	}
	return out, nil
}
