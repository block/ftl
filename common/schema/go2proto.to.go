// Code generated by go2proto. DO NOT EDIT.

package schema

import "fmt"
import destpb "github.com/block/ftl/common/protos/xyz/block/ftl/schema/v1"
import "google.golang.org/protobuf/proto"
import "google.golang.org/protobuf/types/known/timestamppb"
import "google.golang.org/protobuf/types/known/durationpb"

import "github.com/block/ftl/internal/key"

var _ fmt.Stringer
var _ = timestamppb.Timestamp{}
var _ = durationpb.Duration{}

// protoSlice converts a slice of values to a slice of protobuf values.
func protoSlice[P any, T interface{ ToProto() P }](values []T) []P {
	out := make([]P, len(values))
	for i, v := range values {
		out[i] = v.ToProto()
	}
	return out
}

func protoMust[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func sliceMap[T any, U any](values []T, f func(T) U) []U {
	out := make([]U, len(values))
	for i, v := range values {
		out[i] = f(v)
	}
	return out
}

func orZero[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func ptr[T any, O any](v *O, o T) *T {
	if v == nil {
		return nil
	}
	return &o
}

func fromPtr[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func (x *AWSIAMAuthDatabaseConnector) ToProto() *destpb.AWSIAMAuthDatabaseConnector {
	if x == nil {
		return nil
	}
	return &destpb.AWSIAMAuthDatabaseConnector{
		Pos:      x.Pos.ToProto(),
		Username: string(x.Username),
		Endpoint: string(x.Endpoint),
		Database: string(x.Database),
	}
}

func AWSIAMAuthDatabaseConnectorFromProto(v *destpb.AWSIAMAuthDatabaseConnector) *AWSIAMAuthDatabaseConnector {
	if v == nil {
		return nil
	}

	return &AWSIAMAuthDatabaseConnector{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Username: string(v.Username),
		Endpoint: string(v.Endpoint),
		Database: string(v.Database),
	}
}

func (x AliasKind) ToProto() destpb.AliasKind {
	return destpb.AliasKind(x)
}

func AliasKindFromProto(v destpb.AliasKind) AliasKind {
	return AliasKind(v)
}

func (x *Any) ToProto() *destpb.Any {
	if x == nil {
		return nil
	}
	return &destpb.Any{
		Pos: x.Pos.ToProto(),
	}
}

func AnyFromProto(v *destpb.Any) *Any {
	if v == nil {
		return nil
	}

	return &Any{
		Pos: fromPtr(PositionFromProto(v.Pos)),
	}
}

func (x *Array) ToProto() *destpb.Array {
	if x == nil {
		return nil
	}
	return &destpb.Array{
		Pos:     x.Pos.ToProto(),
		Element: TypeToProto(x.Element),
	}
}

func ArrayFromProto(v *destpb.Array) *Array {
	if v == nil {
		return nil
	}

	return &Array{
		Pos:     fromPtr(PositionFromProto(v.Pos)),
		Element: TypeFromProto(v.Element),
	}
}

func (x *Bool) ToProto() *destpb.Bool {
	if x == nil {
		return nil
	}
	return &destpb.Bool{
		Pos: x.Pos.ToProto(),
	}
}

func BoolFromProto(v *destpb.Bool) *Bool {
	if v == nil {
		return nil
	}

	return &Bool{
		Pos: fromPtr(PositionFromProto(v.Pos)),
	}
}

func (x *Bytes) ToProto() *destpb.Bytes {
	if x == nil {
		return nil
	}
	return &destpb.Bytes{
		Pos: x.Pos.ToProto(),
	}
}

func BytesFromProto(v *destpb.Bytes) *Bytes {
	if v == nil {
		return nil
	}

	return &Bytes{
		Pos: fromPtr(PositionFromProto(v.Pos)),
	}
}

func (x *Config) ToProto() *destpb.Config {
	if x == nil {
		return nil
	}
	return &destpb.Config{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Name:     string(x.Name),
		Type:     TypeToProto(x.Type),
	}
}

func ConfigFromProto(v *destpb.Config) *Config {
	if v == nil {
		return nil
	}

	return &Config{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Comments: sliceMap(v.Comments, func(v string) string { return string(v) }),
		Name:     string(v.Name),
		Type:     TypeFromProto(v.Type),
	}
}

func (x *DSNDatabaseConnector) ToProto() *destpb.DSNDatabaseConnector {
	if x == nil {
		return nil
	}
	return &destpb.DSNDatabaseConnector{
		Pos: x.Pos.ToProto(),
		Dsn: string(x.DSN),
	}
}

func DSNDatabaseConnectorFromProto(v *destpb.DSNDatabaseConnector) *DSNDatabaseConnector {
	if v == nil {
		return nil
	}

	return &DSNDatabaseConnector{
		Pos: fromPtr(PositionFromProto(v.Pos)),
		DSN: string(v.Dsn),
	}
}

func (x *Data) ToProto() *destpb.Data {
	if x == nil {
		return nil
	}
	return &destpb.Data{
		Pos:            x.Pos.ToProto(),
		Comments:       sliceMap(x.Comments, func(v string) string { return string(v) }),
		Export:         bool(x.Export),
		Name:           string(x.Name),
		TypeParameters: protoSlice[*destpb.TypeParameter](x.TypeParameters),
		Fields:         protoSlice[*destpb.Field](x.Fields),
		Metadata:       sliceMap(x.Metadata, MetadataToProto),
	}
}

func DataFromProto(v *destpb.Data) *Data {
	if v == nil {
		return nil
	}

	return &Data{
		Pos:            fromPtr(PositionFromProto(v.Pos)),
		Comments:       sliceMap(v.Comments, func(v string) string { return string(v) }),
		Export:         bool(v.Export),
		Name:           string(v.Name),
		TypeParameters: sliceMap(v.TypeParameters, TypeParameterFromProto),
		Fields:         sliceMap(v.Fields, FieldFromProto),
		Metadata:       sliceMap(v.Metadata, MetadataFromProto),
	}
}

func (x *Database) ToProto() *destpb.Database {
	if x == nil {
		return nil
	}
	return &destpb.Database{
		Pos:      x.Pos.ToProto(),
		Runtime:  x.Runtime.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Type:     string(x.Type),
		Name:     string(x.Name),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
	}
}

func DatabaseFromProto(v *destpb.Database) *Database {
	if v == nil {
		return nil
	}

	return &Database{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Runtime:  DatabaseRuntimeFromProto(v.Runtime),
		Comments: sliceMap(v.Comments, func(v string) string { return string(v) }),
		Type:     string(v.Type),
		Name:     string(v.Name),
		Metadata: sliceMap(v.Metadata, MetadataFromProto),
	}
}

// DatabaseConnectorToProto converts a DatabaseConnector sum type to a protobuf message.
func DatabaseConnectorToProto(value DatabaseConnector) *destpb.DatabaseConnector {
	switch value := value.(type) {
	case nil:
		return nil
	case *AWSIAMAuthDatabaseConnector:
		return &destpb.DatabaseConnector{
			Value: &destpb.DatabaseConnector_AwsiamAuthDatabaseConnector{value.ToProto()},
		}
	case *DSNDatabaseConnector:
		return &destpb.DatabaseConnector{
			Value: &destpb.DatabaseConnector_DsnDatabaseConnector{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DatabaseConnectorFromProto(v *destpb.DatabaseConnector) DatabaseConnector {
	if v == nil {
		return nil
	}
	switch v.Value.(type) {
	case *destpb.DatabaseConnector_AwsiamAuthDatabaseConnector:
		return AWSIAMAuthDatabaseConnectorFromProto(v.GetAwsiamAuthDatabaseConnector())
	case *destpb.DatabaseConnector_DsnDatabaseConnector:
		return DSNDatabaseConnectorFromProto(v.GetDsnDatabaseConnector())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *DatabaseRuntime) ToProto() *destpb.DatabaseRuntime {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntime{
		Connections: x.Connections.ToProto(),
	}
}

func DatabaseRuntimeFromProto(v *destpb.DatabaseRuntime) *DatabaseRuntime {
	if v == nil {
		return nil
	}

	return &DatabaseRuntime{
		Connections: DatabaseRuntimeConnectionsFromProto(v.Connections),
	}
}

func (x *DatabaseRuntimeConnections) ToProto() *destpb.DatabaseRuntimeConnections {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntimeConnections{
		Read:  DatabaseConnectorToProto(x.Read),
		Write: DatabaseConnectorToProto(x.Write),
	}
}

func DatabaseRuntimeConnectionsFromProto(v *destpb.DatabaseRuntimeConnections) *DatabaseRuntimeConnections {
	if v == nil {
		return nil
	}

	return &DatabaseRuntimeConnections{
		Read:  DatabaseConnectorFromProto(v.Read),
		Write: DatabaseConnectorFromProto(v.Write),
	}
}

func (x *DatabaseRuntimeConnectionsEvent) ToProto() *destpb.DatabaseRuntimeConnectionsEvent {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntimeConnectionsEvent{
		Connections: x.Connections.ToProto(),
	}
}

func DatabaseRuntimeConnectionsEventFromProto(v *destpb.DatabaseRuntimeConnectionsEvent) *DatabaseRuntimeConnectionsEvent {
	if v == nil {
		return nil
	}

	return &DatabaseRuntimeConnectionsEvent{
		Connections: DatabaseRuntimeConnectionsFromProto(v.Connections),
	}
}

func (x *DatabaseRuntimeEvent) ToProto() *destpb.DatabaseRuntimeEvent {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntimeEvent{
		Id:      string(x.ID),
		Payload: DatabaseRuntimeEventPayloadToProto(x.Payload),
	}
}

func DatabaseRuntimeEventFromProto(v *destpb.DatabaseRuntimeEvent) *DatabaseRuntimeEvent {
	if v == nil {
		return nil
	}

	return &DatabaseRuntimeEvent{
		ID:      string(v.Id),
		Payload: DatabaseRuntimeEventPayloadFromProto(v.Payload),
	}
}

// DatabaseRuntimeEventPayloadToProto converts a DatabaseRuntimeEventPayload sum type to a protobuf message.
func DatabaseRuntimeEventPayloadToProto(value DatabaseRuntimeEventPayload) *destpb.DatabaseRuntimeEventPayload {
	switch value := value.(type) {
	case nil:
		return nil
	case *DatabaseRuntimeConnectionsEvent:
		return &destpb.DatabaseRuntimeEventPayload{
			Value: &destpb.DatabaseRuntimeEventPayload_DatabaseRuntimeConnectionsEvent{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DatabaseRuntimeEventPayloadFromProto(v *destpb.DatabaseRuntimeEventPayload) DatabaseRuntimeEventPayload {
	if v == nil {
		return nil
	}
	switch v.Value.(type) {
	case *destpb.DatabaseRuntimeEventPayload_DatabaseRuntimeConnectionsEvent:
		return DatabaseRuntimeConnectionsEventFromProto(v.GetDatabaseRuntimeConnectionsEvent())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

// DeclToProto converts a Decl sum type to a protobuf message.
func DeclToProto(value Decl) *destpb.Decl {
	switch value := value.(type) {
	case nil:
		return nil
	case *Config:
		return &destpb.Decl{
			Value: &destpb.Decl_Config{value.ToProto()},
		}
	case *Data:
		return &destpb.Decl{
			Value: &destpb.Decl_Data{value.ToProto()},
		}
	case *Database:
		return &destpb.Decl{
			Value: &destpb.Decl_Database{value.ToProto()},
		}
	case *Enum:
		return &destpb.Decl{
			Value: &destpb.Decl_Enum{value.ToProto()},
		}
	case *Secret:
		return &destpb.Decl{
			Value: &destpb.Decl_Secret{value.ToProto()},
		}
	case *Topic:
		return &destpb.Decl{
			Value: &destpb.Decl_Topic{value.ToProto()},
		}
	case *TypeAlias:
		return &destpb.Decl{
			Value: &destpb.Decl_TypeAlias{value.ToProto()},
		}
	case *Verb:
		return &destpb.Decl{
			Value: &destpb.Decl_Verb{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DeclFromProto(v *destpb.Decl) Decl {
	if v == nil {
		return nil
	}
	switch v.Value.(type) {
	case *destpb.Decl_Config:
		return ConfigFromProto(v.GetConfig())
	case *destpb.Decl_Data:
		return DataFromProto(v.GetData())
	case *destpb.Decl_Database:
		return DatabaseFromProto(v.GetDatabase())
	case *destpb.Decl_Enum:
		return EnumFromProto(v.GetEnum())
	case *destpb.Decl_Secret:
		return SecretFromProto(v.GetSecret())
	case *destpb.Decl_Topic:
		return TopicFromProto(v.GetTopic())
	case *destpb.Decl_TypeAlias:
		return TypeAliasFromProto(v.GetTypeAlias())
	case *destpb.Decl_Verb:
		return VerbFromProto(v.GetVerb())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Enum) ToProto() *destpb.Enum {
	if x == nil {
		return nil
	}
	return &destpb.Enum{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Export:   bool(x.Export),
		Name:     string(x.Name),
		Type:     TypeToProto(x.Type),
		Variants: protoSlice[*destpb.EnumVariant](x.Variants),
	}
}

func EnumFromProto(v *destpb.Enum) *Enum {
	if v == nil {
		return nil
	}

	return &Enum{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Comments: sliceMap(v.Comments, func(v string) string { return string(v) }),
		Export:   bool(v.Export),
		Name:     string(v.Name),
		Type:     TypeFromProto(v.Type),
		Variants: sliceMap(v.Variants, EnumVariantFromProto),
	}
}

func (x *EnumVariant) ToProto() *destpb.EnumVariant {
	if x == nil {
		return nil
	}
	return &destpb.EnumVariant{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Name:     string(x.Name),
		Value:    ValueToProto(x.Value),
	}
}

func EnumVariantFromProto(v *destpb.EnumVariant) *EnumVariant {
	if v == nil {
		return nil
	}

	return &EnumVariant{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Comments: sliceMap(v.Comments, func(v string) string { return string(v) }),
		Name:     string(v.Name),
		Value:    ValueFromProto(v.Value),
	}
}

func (x *Field) ToProto() *destpb.Field {
	if x == nil {
		return nil
	}
	return &destpb.Field{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Name:     string(x.Name),
		Type:     TypeToProto(x.Type),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
	}
}

func FieldFromProto(v *destpb.Field) *Field {
	if v == nil {
		return nil
	}

	return &Field{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Comments: sliceMap(v.Comments, func(v string) string { return string(v) }),
		Name:     string(v.Name),
		Type:     TypeFromProto(v.Type),
		Metadata: sliceMap(v.Metadata, MetadataFromProto),
	}
}

func (x *Float) ToProto() *destpb.Float {
	if x == nil {
		return nil
	}
	return &destpb.Float{
		Pos: x.Pos.ToProto(),
	}
}

func FloatFromProto(v *destpb.Float) *Float {
	if v == nil {
		return nil
	}

	return &Float{
		Pos: fromPtr(PositionFromProto(v.Pos)),
	}
}

func (x FromOffset) ToProto() destpb.FromOffset {
	return destpb.FromOffset(x)
}

func FromOffsetFromProto(v destpb.FromOffset) FromOffset {
	return FromOffset(v)
}

// IngressPathComponentToProto converts a IngressPathComponent sum type to a protobuf message.
func IngressPathComponentToProto(value IngressPathComponent) *destpb.IngressPathComponent {
	switch value := value.(type) {
	case nil:
		return nil
	case *IngressPathLiteral:
		return &destpb.IngressPathComponent{
			Value: &destpb.IngressPathComponent_IngressPathLiteral{value.ToProto()},
		}
	case *IngressPathParameter:
		return &destpb.IngressPathComponent{
			Value: &destpb.IngressPathComponent_IngressPathParameter{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func IngressPathComponentFromProto(v *destpb.IngressPathComponent) IngressPathComponent {
	if v == nil {
		return nil
	}
	switch v.Value.(type) {
	case *destpb.IngressPathComponent_IngressPathLiteral:
		return IngressPathLiteralFromProto(v.GetIngressPathLiteral())
	case *destpb.IngressPathComponent_IngressPathParameter:
		return IngressPathParameterFromProto(v.GetIngressPathParameter())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *IngressPathLiteral) ToProto() *destpb.IngressPathLiteral {
	if x == nil {
		return nil
	}
	return &destpb.IngressPathLiteral{
		Pos:  x.Pos.ToProto(),
		Text: string(x.Text),
	}
}

func IngressPathLiteralFromProto(v *destpb.IngressPathLiteral) *IngressPathLiteral {
	if v == nil {
		return nil
	}

	return &IngressPathLiteral{
		Pos:  fromPtr(PositionFromProto(v.Pos)),
		Text: string(v.Text),
	}
}

func (x *IngressPathParameter) ToProto() *destpb.IngressPathParameter {
	if x == nil {
		return nil
	}
	return &destpb.IngressPathParameter{
		Pos:  x.Pos.ToProto(),
		Name: string(x.Name),
	}
}

func IngressPathParameterFromProto(v *destpb.IngressPathParameter) *IngressPathParameter {
	if v == nil {
		return nil
	}

	return &IngressPathParameter{
		Pos:  fromPtr(PositionFromProto(v.Pos)),
		Name: string(v.Name),
	}
}

func (x *Int) ToProto() *destpb.Int {
	if x == nil {
		return nil
	}
	return &destpb.Int{
		Pos: x.Pos.ToProto(),
	}
}

func IntFromProto(v *destpb.Int) *Int {
	if v == nil {
		return nil
	}

	return &Int{
		Pos: fromPtr(PositionFromProto(v.Pos)),
	}
}

func (x *IntValue) ToProto() *destpb.IntValue {
	if x == nil {
		return nil
	}
	return &destpb.IntValue{
		Pos:   x.Pos.ToProto(),
		Value: int64(x.Value),
	}
}

func IntValueFromProto(v *destpb.IntValue) *IntValue {
	if v == nil {
		return nil
	}

	return &IntValue{
		Pos:   fromPtr(PositionFromProto(v.Pos)),
		Value: int(v.Value),
	}
}

func (x *Map) ToProto() *destpb.Map {
	if x == nil {
		return nil
	}
	return &destpb.Map{
		Pos:   x.Pos.ToProto(),
		Key:   TypeToProto(x.Key),
		Value: TypeToProto(x.Value),
	}
}

func MapFromProto(v *destpb.Map) *Map {
	if v == nil {
		return nil
	}

	return &Map{
		Pos:   fromPtr(PositionFromProto(v.Pos)),
		Key:   TypeFromProto(v.Key),
		Value: TypeFromProto(v.Value),
	}
}

// MetadataToProto converts a Metadata sum type to a protobuf message.
func MetadataToProto(value Metadata) *destpb.Metadata {
	switch value := value.(type) {
	case nil:
		return nil
	case *MetadataAlias:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Alias{value.ToProto()},
		}
	case *MetadataArtefact:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Artefact{value.ToProto()},
		}
	case *MetadataCalls:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Calls{value.ToProto()},
		}
	case *MetadataConfig:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Config{value.ToProto()},
		}
	case *MetadataCronJob:
		return &destpb.Metadata{
			Value: &destpb.Metadata_CronJob{value.ToProto()},
		}
	case *MetadataDBColumn:
		return &destpb.Metadata{
			Value: &destpb.Metadata_DbColumn{value.ToProto()},
		}
	case *MetadataDatabases:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Databases{value.ToProto()},
		}
	case *MetadataEncoding:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Encoding{value.ToProto()},
		}
	case *MetadataIngress:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Ingress{value.ToProto()},
		}
	case *MetadataPartitions:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Partitions{value.ToProto()},
		}
	case *MetadataPublisher:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Publisher{value.ToProto()},
		}
	case *MetadataRetry:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Retry{value.ToProto()},
		}
	case *MetadataSQLMigration:
		return &destpb.Metadata{
			Value: &destpb.Metadata_SqlMigration{value.ToProto()},
		}
	case *MetadataSQLQuery:
		return &destpb.Metadata{
			Value: &destpb.Metadata_SqlQuery{value.ToProto()},
		}
	case *MetadataSecrets:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Secrets{value.ToProto()},
		}
	case *MetadataSubscriber:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Subscriber{value.ToProto()},
		}
	case *MetadataTypeMap:
		return &destpb.Metadata{
			Value: &destpb.Metadata_TypeMap{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func MetadataFromProto(v *destpb.Metadata) Metadata {
	if v == nil {
		return nil
	}
	switch v.Value.(type) {
	case *destpb.Metadata_Alias:
		return MetadataAliasFromProto(v.GetAlias())
	case *destpb.Metadata_Artefact:
		return MetadataArtefactFromProto(v.GetArtefact())
	case *destpb.Metadata_Calls:
		return MetadataCallsFromProto(v.GetCalls())
	case *destpb.Metadata_Config:
		return MetadataConfigFromProto(v.GetConfig())
	case *destpb.Metadata_CronJob:
		return MetadataCronJobFromProto(v.GetCronJob())
	case *destpb.Metadata_DbColumn:
		return MetadataDBColumnFromProto(v.GetDbColumn())
	case *destpb.Metadata_Databases:
		return MetadataDatabasesFromProto(v.GetDatabases())
	case *destpb.Metadata_Encoding:
		return MetadataEncodingFromProto(v.GetEncoding())
	case *destpb.Metadata_Ingress:
		return MetadataIngressFromProto(v.GetIngress())
	case *destpb.Metadata_Partitions:
		return MetadataPartitionsFromProto(v.GetPartitions())
	case *destpb.Metadata_Publisher:
		return MetadataPublisherFromProto(v.GetPublisher())
	case *destpb.Metadata_Retry:
		return MetadataRetryFromProto(v.GetRetry())
	case *destpb.Metadata_SqlMigration:
		return MetadataSQLMigrationFromProto(v.GetSqlMigration())
	case *destpb.Metadata_SqlQuery:
		return MetadataSQLQueryFromProto(v.GetSqlQuery())
	case *destpb.Metadata_Secrets:
		return MetadataSecretsFromProto(v.GetSecrets())
	case *destpb.Metadata_Subscriber:
		return MetadataSubscriberFromProto(v.GetSubscriber())
	case *destpb.Metadata_TypeMap:
		return MetadataTypeMapFromProto(v.GetTypeMap())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *MetadataAlias) ToProto() *destpb.MetadataAlias {
	if x == nil {
		return nil
	}
	return &destpb.MetadataAlias{
		Pos:   x.Pos.ToProto(),
		Kind:  x.Kind.ToProto(),
		Alias: string(x.Alias),
	}
}

func MetadataAliasFromProto(v *destpb.MetadataAlias) *MetadataAlias {
	if v == nil {
		return nil
	}

	return &MetadataAlias{
		Pos:   fromPtr(PositionFromProto(v.Pos)),
		Kind:  AliasKindFromProto(v.Kind),
		Alias: string(v.Alias),
	}
}

func (x *MetadataArtefact) ToProto() *destpb.MetadataArtefact {
	if x == nil {
		return nil
	}
	return &destpb.MetadataArtefact{
		Pos:        x.Pos.ToProto(),
		Path:       string(x.Path),
		Digest:     string(x.Digest),
		Executable: bool(x.Executable),
	}
}

func MetadataArtefactFromProto(v *destpb.MetadataArtefact) *MetadataArtefact {
	if v == nil {
		return nil
	}

	return &MetadataArtefact{
		Pos:        fromPtr(PositionFromProto(v.Pos)),
		Path:       string(v.Path),
		Digest:     string(v.Digest),
		Executable: bool(v.Executable),
	}
}

func (x *MetadataCalls) ToProto() *destpb.MetadataCalls {
	if x == nil {
		return nil
	}
	return &destpb.MetadataCalls{
		Pos:   x.Pos.ToProto(),
		Calls: protoSlice[*destpb.Ref](x.Calls),
	}
}

func MetadataCallsFromProto(v *destpb.MetadataCalls) *MetadataCalls {
	if v == nil {
		return nil
	}

	return &MetadataCalls{
		Pos:   fromPtr(PositionFromProto(v.Pos)),
		Calls: sliceMap(v.Calls, RefFromProto),
	}
}

func (x *MetadataConfig) ToProto() *destpb.MetadataConfig {
	if x == nil {
		return nil
	}
	return &destpb.MetadataConfig{
		Pos:    x.Pos.ToProto(),
		Config: protoSlice[*destpb.Ref](x.Config),
	}
}

func MetadataConfigFromProto(v *destpb.MetadataConfig) *MetadataConfig {
	if v == nil {
		return nil
	}

	return &MetadataConfig{
		Pos:    fromPtr(PositionFromProto(v.Pos)),
		Config: sliceMap(v.Config, RefFromProto),
	}
}

func (x *MetadataCronJob) ToProto() *destpb.MetadataCronJob {
	if x == nil {
		return nil
	}
	return &destpb.MetadataCronJob{
		Pos:  x.Pos.ToProto(),
		Cron: string(x.Cron),
	}
}

func MetadataCronJobFromProto(v *destpb.MetadataCronJob) *MetadataCronJob {
	if v == nil {
		return nil
	}

	return &MetadataCronJob{
		Pos:  fromPtr(PositionFromProto(v.Pos)),
		Cron: string(v.Cron),
	}
}

func (x *MetadataDBColumn) ToProto() *destpb.MetadataDBColumn {
	if x == nil {
		return nil
	}
	return &destpb.MetadataDBColumn{
		Pos:   x.Pos.ToProto(),
		Table: string(x.Table),
		Name:  string(x.Name),
	}
}

func MetadataDBColumnFromProto(v *destpb.MetadataDBColumn) *MetadataDBColumn {
	if v == nil {
		return nil
	}

	return &MetadataDBColumn{
		Pos:   fromPtr(PositionFromProto(v.Pos)),
		Table: string(v.Table),
		Name:  string(v.Name),
	}
}

func (x *MetadataDatabases) ToProto() *destpb.MetadataDatabases {
	if x == nil {
		return nil
	}
	return &destpb.MetadataDatabases{
		Pos:   x.Pos.ToProto(),
		Calls: protoSlice[*destpb.Ref](x.Calls),
	}
}

func MetadataDatabasesFromProto(v *destpb.MetadataDatabases) *MetadataDatabases {
	if v == nil {
		return nil
	}

	return &MetadataDatabases{
		Pos:   fromPtr(PositionFromProto(v.Pos)),
		Calls: sliceMap(v.Calls, RefFromProto),
	}
}

func (x *MetadataEncoding) ToProto() *destpb.MetadataEncoding {
	if x == nil {
		return nil
	}
	return &destpb.MetadataEncoding{
		Pos:     x.Pos.ToProto(),
		Type:    string(x.Type),
		Lenient: bool(x.Lenient),
	}
}

func MetadataEncodingFromProto(v *destpb.MetadataEncoding) *MetadataEncoding {
	if v == nil {
		return nil
	}

	return &MetadataEncoding{
		Pos:     fromPtr(PositionFromProto(v.Pos)),
		Type:    string(v.Type),
		Lenient: bool(v.Lenient),
	}
}

func (x *MetadataIngress) ToProto() *destpb.MetadataIngress {
	if x == nil {
		return nil
	}
	return &destpb.MetadataIngress{
		Pos:    x.Pos.ToProto(),
		Type:   string(x.Type),
		Method: string(x.Method),
		Path:   sliceMap(x.Path, IngressPathComponentToProto),
	}
}

func MetadataIngressFromProto(v *destpb.MetadataIngress) *MetadataIngress {
	if v == nil {
		return nil
	}

	return &MetadataIngress{
		Pos:    fromPtr(PositionFromProto(v.Pos)),
		Type:   string(v.Type),
		Method: string(v.Method),
		Path:   sliceMap(v.Path, IngressPathComponentFromProto),
	}
}

func (x *MetadataPartitions) ToProto() *destpb.MetadataPartitions {
	if x == nil {
		return nil
	}
	return &destpb.MetadataPartitions{
		Pos:        x.Pos.ToProto(),
		Partitions: int64(x.Partitions),
	}
}

func MetadataPartitionsFromProto(v *destpb.MetadataPartitions) *MetadataPartitions {
	if v == nil {
		return nil
	}

	return &MetadataPartitions{
		Pos:        fromPtr(PositionFromProto(v.Pos)),
		Partitions: int(v.Partitions),
	}
}

func (x *MetadataPublisher) ToProto() *destpb.MetadataPublisher {
	if x == nil {
		return nil
	}
	return &destpb.MetadataPublisher{
		Pos:    x.Pos.ToProto(),
		Topics: protoSlice[*destpb.Ref](x.Topics),
	}
}

func MetadataPublisherFromProto(v *destpb.MetadataPublisher) *MetadataPublisher {
	if v == nil {
		return nil
	}

	return &MetadataPublisher{
		Pos:    fromPtr(PositionFromProto(v.Pos)),
		Topics: sliceMap(v.Topics, RefFromProto),
	}
}

func (x *MetadataRetry) ToProto() *destpb.MetadataRetry {
	if x == nil {
		return nil
	}
	return &destpb.MetadataRetry{
		Pos:        x.Pos.ToProto(),
		Count:      proto.Int64(int64(*x.Count)),
		MinBackoff: string(x.MinBackoff),
		MaxBackoff: string(x.MaxBackoff),
		Catch:      x.Catch.ToProto(),
	}
}

func MetadataRetryFromProto(v *destpb.MetadataRetry) *MetadataRetry {
	if v == nil {
		return nil
	}

	return &MetadataRetry{
		Pos:        fromPtr(PositionFromProto(v.Pos)),
		Count:      ptr(v.Count, int(orZero(v.Count))),
		MinBackoff: string(v.MinBackoff),
		MaxBackoff: string(v.MaxBackoff),
		Catch:      RefFromProto(v.Catch),
	}
}

func (x *MetadataSQLMigration) ToProto() *destpb.MetadataSQLMigration {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSQLMigration{
		Pos:    x.Pos.ToProto(),
		Digest: string(x.Digest),
	}
}

func MetadataSQLMigrationFromProto(v *destpb.MetadataSQLMigration) *MetadataSQLMigration {
	if v == nil {
		return nil
	}

	return &MetadataSQLMigration{
		Pos:    fromPtr(PositionFromProto(v.Pos)),
		Digest: string(v.Digest),
	}
}

func (x *MetadataSQLQuery) ToProto() *destpb.MetadataSQLQuery {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSQLQuery{
		Pos:   x.Pos.ToProto(),
		Query: string(x.Query),
	}
}

func MetadataSQLQueryFromProto(v *destpb.MetadataSQLQuery) *MetadataSQLQuery {
	if v == nil {
		return nil
	}

	return &MetadataSQLQuery{
		Pos:   fromPtr(PositionFromProto(v.Pos)),
		Query: string(v.Query),
	}
}

func (x *MetadataSecrets) ToProto() *destpb.MetadataSecrets {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSecrets{
		Pos:     x.Pos.ToProto(),
		Secrets: protoSlice[*destpb.Ref](x.Secrets),
	}
}

func MetadataSecretsFromProto(v *destpb.MetadataSecrets) *MetadataSecrets {
	if v == nil {
		return nil
	}

	return &MetadataSecrets{
		Pos:     fromPtr(PositionFromProto(v.Pos)),
		Secrets: sliceMap(v.Secrets, RefFromProto),
	}
}

func (x *MetadataSubscriber) ToProto() *destpb.MetadataSubscriber {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSubscriber{
		Pos:        x.Pos.ToProto(),
		Topic:      x.Topic.ToProto(),
		FromOffset: x.FromOffset.ToProto(),
		DeadLetter: bool(x.DeadLetter),
	}
}

func MetadataSubscriberFromProto(v *destpb.MetadataSubscriber) *MetadataSubscriber {
	if v == nil {
		return nil
	}

	return &MetadataSubscriber{
		Pos:        fromPtr(PositionFromProto(v.Pos)),
		Topic:      RefFromProto(v.Topic),
		FromOffset: FromOffsetFromProto(v.FromOffset),
		DeadLetter: bool(v.DeadLetter),
	}
}

func (x *MetadataTypeMap) ToProto() *destpb.MetadataTypeMap {
	if x == nil {
		return nil
	}
	return &destpb.MetadataTypeMap{
		Pos:        x.Pos.ToProto(),
		Runtime:    string(x.Runtime),
		NativeName: string(x.NativeName),
	}
}

func MetadataTypeMapFromProto(v *destpb.MetadataTypeMap) *MetadataTypeMap {
	if v == nil {
		return nil
	}

	return &MetadataTypeMap{
		Pos:        fromPtr(PositionFromProto(v.Pos)),
		Runtime:    string(v.Runtime),
		NativeName: string(v.NativeName),
	}
}

func (x *Module) ToProto() *destpb.Module {
	if x == nil {
		return nil
	}
	return &destpb.Module{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Builtin:  bool(x.Builtin),
		Name:     string(x.Name),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
		Decls:    sliceMap(x.Decls, DeclToProto),
		Runtime:  x.Runtime.ToProto(),
	}
}

func ModuleFromProto(v *destpb.Module) *Module {
	if v == nil {
		return nil
	}

	return &Module{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Comments: sliceMap(v.Comments, func(v string) string { return string(v) }),
		Builtin:  bool(v.Builtin),
		Name:     string(v.Name),
		Metadata: sliceMap(v.Metadata, MetadataFromProto),
		Decls:    sliceMap(v.Decls, DeclFromProto),
		Runtime:  ModuleRuntimeFromProto(v.Runtime),
	}
}

func (x *ModuleRuntime) ToProto() *destpb.ModuleRuntime {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntime{
		Base:       x.Base.ToProto(),
		Scaling:    x.Scaling.ToProto(),
		Deployment: x.Deployment.ToProto(),
	}
}

func ModuleRuntimeFromProto(v *destpb.ModuleRuntime) *ModuleRuntime {
	if v == nil {
		return nil
	}

	return &ModuleRuntime{
		Base:       fromPtr(ModuleRuntimeBaseFromProto(v.Base)),
		Scaling:    ModuleRuntimeScalingFromProto(v.Scaling),
		Deployment: ModuleRuntimeDeploymentFromProto(v.Deployment),
	}
}

func (x *ModuleRuntimeBase) ToProto() *destpb.ModuleRuntimeBase {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeBase{
		CreateTime: timestamppb.New(x.CreateTime),
		Language:   string(x.Language),
		Os:         proto.String(string(x.OS)),
		Arch:       proto.String(string(x.Arch)),
		Image:      proto.String(string(x.Image)),
	}
}

func ModuleRuntimeBaseFromProto(v *destpb.ModuleRuntimeBase) *ModuleRuntimeBase {
	if v == nil {
		return nil
	}

	return &ModuleRuntimeBase{
		CreateTime: v.CreateTime.AsTime(),
		Language:   string(v.Language),
		OS:         string(orZero(v.Os)),
		Arch:       string(orZero(v.Arch)),
		Image:      string(orZero(v.Image)),
	}
}

func (x *ModuleRuntimeDeployment) ToProto() *destpb.ModuleRuntimeDeployment {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeDeployment{
		Endpoint:      string(x.Endpoint),
		DeploymentKey: string(protoMust(x.DeploymentKey.MarshalText())),
		CreatedAt:     timestamppb.New(x.CreatedAt),
		ActivatedAt:   timestamppb.New(x.ActivatedAt),
	}
}

func ModuleRuntimeDeploymentFromProto(v *destpb.ModuleRuntimeDeployment) *ModuleRuntimeDeployment {
	if v == nil {
		return nil
	}
	f2 := &key.Deployment{}
	f2.UnmarshalText([]byte(v.DeploymentKey))

	return &ModuleRuntimeDeployment{
		Endpoint:      string(v.Endpoint),
		DeploymentKey: fromPtr(f2),
		CreatedAt:     v.CreatedAt.AsTime(),
		ActivatedAt:   v.ActivatedAt.AsTime(),
	}
}

// ModuleRuntimeEventToProto converts a ModuleRuntimeEvent sum type to a protobuf message.
func ModuleRuntimeEventToProto(value ModuleRuntimeEvent) *destpb.ModuleRuntimeEvent {
	switch value := value.(type) {
	case nil:
		return nil
	case *ModuleRuntimeBase:
		return &destpb.ModuleRuntimeEvent{
			Value: &destpb.ModuleRuntimeEvent_ModuleRuntimeBase{value.ToProto()},
		}
	case *ModuleRuntimeDeployment:
		return &destpb.ModuleRuntimeEvent{
			Value: &destpb.ModuleRuntimeEvent_ModuleRuntimeDeployment{value.ToProto()},
		}
	case *ModuleRuntimeScaling:
		return &destpb.ModuleRuntimeEvent{
			Value: &destpb.ModuleRuntimeEvent_ModuleRuntimeScaling{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func ModuleRuntimeEventFromProto(v *destpb.ModuleRuntimeEvent) ModuleRuntimeEvent {
	if v == nil {
		return nil
	}
	switch v.Value.(type) {
	case *destpb.ModuleRuntimeEvent_ModuleRuntimeBase:
		return ModuleRuntimeBaseFromProto(v.GetModuleRuntimeBase())
	case *destpb.ModuleRuntimeEvent_ModuleRuntimeDeployment:
		return ModuleRuntimeDeploymentFromProto(v.GetModuleRuntimeDeployment())
	case *destpb.ModuleRuntimeEvent_ModuleRuntimeScaling:
		return ModuleRuntimeScalingFromProto(v.GetModuleRuntimeScaling())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *ModuleRuntimeScaling) ToProto() *destpb.ModuleRuntimeScaling {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeScaling{
		MinReplicas: int32(x.MinReplicas),
	}
}

func ModuleRuntimeScalingFromProto(v *destpb.ModuleRuntimeScaling) *ModuleRuntimeScaling {
	if v == nil {
		return nil
	}

	return &ModuleRuntimeScaling{
		MinReplicas: int32(v.MinReplicas),
	}
}

func (x *Optional) ToProto() *destpb.Optional {
	if x == nil {
		return nil
	}
	return &destpb.Optional{
		Pos:  x.Pos.ToProto(),
		Type: TypeToProto(x.Type),
	}
}

func OptionalFromProto(v *destpb.Optional) *Optional {
	if v == nil {
		return nil
	}

	return &Optional{
		Pos:  fromPtr(PositionFromProto(v.Pos)),
		Type: TypeFromProto(v.Type),
	}
}

func (x *Position) ToProto() *destpb.Position {
	if x == nil {
		return nil
	}
	return &destpb.Position{
		Filename: string(x.Filename),
		Line:     int64(x.Line),
		Column:   int64(x.Column),
	}
}

func PositionFromProto(v *destpb.Position) *Position {
	if v == nil {
		return nil
	}

	return &Position{
		Filename: string(v.Filename),
		Line:     int(v.Line),
		Column:   int(v.Column),
	}
}

func (x *Ref) ToProto() *destpb.Ref {
	if x == nil {
		return nil
	}
	return &destpb.Ref{
		Pos:            x.Pos.ToProto(),
		Module:         string(x.Module),
		Name:           string(x.Name),
		TypeParameters: sliceMap(x.TypeParameters, TypeToProto),
	}
}

func RefFromProto(v *destpb.Ref) *Ref {
	if v == nil {
		return nil
	}

	return &Ref{
		Pos:            fromPtr(PositionFromProto(v.Pos)),
		Module:         string(v.Module),
		Name:           string(v.Name),
		TypeParameters: sliceMap(v.TypeParameters, TypeFromProto),
	}
}

// RuntimeEventToProto converts a RuntimeEvent sum type to a protobuf message.
func RuntimeEventToProto(value RuntimeEvent) *destpb.RuntimeEvent {
	switch value := value.(type) {
	case nil:
		return nil
	case *DatabaseRuntimeEvent:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_DatabaseRuntimeEvent{value.ToProto()},
		}
	case *ModuleRuntimeBase:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_ModuleRuntimeBase{value.ToProto()},
		}
	case *ModuleRuntimeDeployment:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_ModuleRuntimeDeployment{value.ToProto()},
		}
	case *ModuleRuntimeScaling:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_ModuleRuntimeScaling{value.ToProto()},
		}
	case *TopicRuntimeEvent:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_TopicRuntimeEvent{value.ToProto()},
		}
	case *VerbRuntimeEvent:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_VerbRuntimeEvent{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func RuntimeEventFromProto(v *destpb.RuntimeEvent) RuntimeEvent {
	if v == nil {
		return nil
	}
	switch v.Value.(type) {
	case *destpb.RuntimeEvent_DatabaseRuntimeEvent:
		return DatabaseRuntimeEventFromProto(v.GetDatabaseRuntimeEvent())
	case *destpb.RuntimeEvent_ModuleRuntimeBase:
		return ModuleRuntimeBaseFromProto(v.GetModuleRuntimeBase())
	case *destpb.RuntimeEvent_ModuleRuntimeDeployment:
		return ModuleRuntimeDeploymentFromProto(v.GetModuleRuntimeDeployment())
	case *destpb.RuntimeEvent_ModuleRuntimeScaling:
		return ModuleRuntimeScalingFromProto(v.GetModuleRuntimeScaling())
	case *destpb.RuntimeEvent_TopicRuntimeEvent:
		return TopicRuntimeEventFromProto(v.GetTopicRuntimeEvent())
	case *destpb.RuntimeEvent_VerbRuntimeEvent:
		return VerbRuntimeEventFromProto(v.GetVerbRuntimeEvent())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Schema) ToProto() *destpb.Schema {
	if x == nil {
		return nil
	}
	return &destpb.Schema{
		Pos:     x.Pos.ToProto(),
		Modules: protoSlice[*destpb.Module](x.Modules),
	}
}

func SchemaFromProto(v *destpb.Schema) *Schema {
	if v == nil {
		return nil
	}

	return &Schema{
		Pos:     fromPtr(PositionFromProto(v.Pos)),
		Modules: sliceMap(v.Modules, ModuleFromProto),
	}
}

func (x *Secret) ToProto() *destpb.Secret {
	if x == nil {
		return nil
	}
	return &destpb.Secret{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Name:     string(x.Name),
		Type:     TypeToProto(x.Type),
	}
}

func SecretFromProto(v *destpb.Secret) *Secret {
	if v == nil {
		return nil
	}

	return &Secret{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Comments: sliceMap(v.Comments, func(v string) string { return string(v) }),
		Name:     string(v.Name),
		Type:     TypeFromProto(v.Type),
	}
}

func (x *String) ToProto() *destpb.String {
	if x == nil {
		return nil
	}
	return &destpb.String{
		Pos: x.Pos.ToProto(),
	}
}

func StringFromProto(v *destpb.String) *String {
	if v == nil {
		return nil
	}

	return &String{
		Pos: fromPtr(PositionFromProto(v.Pos)),
	}
}

func (x *StringValue) ToProto() *destpb.StringValue {
	if x == nil {
		return nil
	}
	return &destpb.StringValue{
		Pos:   x.Pos.ToProto(),
		Value: string(x.Value),
	}
}

func StringValueFromProto(v *destpb.StringValue) *StringValue {
	if v == nil {
		return nil
	}

	return &StringValue{
		Pos:   fromPtr(PositionFromProto(v.Pos)),
		Value: string(v.Value),
	}
}

func (x *Time) ToProto() *destpb.Time {
	if x == nil {
		return nil
	}
	return &destpb.Time{
		Pos: x.Pos.ToProto(),
	}
}

func TimeFromProto(v *destpb.Time) *Time {
	if v == nil {
		return nil
	}

	return &Time{
		Pos: fromPtr(PositionFromProto(v.Pos)),
	}
}

func (x *Topic) ToProto() *destpb.Topic {
	if x == nil {
		return nil
	}
	return &destpb.Topic{
		Pos:      x.Pos.ToProto(),
		Runtime:  x.Runtime.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Export:   bool(x.Export),
		Name:     string(x.Name),
		Event:    TypeToProto(x.Event),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
	}
}

func TopicFromProto(v *destpb.Topic) *Topic {
	if v == nil {
		return nil
	}

	return &Topic{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Runtime:  TopicRuntimeFromProto(v.Runtime),
		Comments: sliceMap(v.Comments, func(v string) string { return string(v) }),
		Export:   bool(v.Export),
		Name:     string(v.Name),
		Event:    TypeFromProto(v.Event),
		Metadata: sliceMap(v.Metadata, MetadataFromProto),
	}
}

func (x *TopicRuntime) ToProto() *destpb.TopicRuntime {
	if x == nil {
		return nil
	}
	return &destpb.TopicRuntime{
		KafkaBrokers: sliceMap(x.KafkaBrokers, func(v string) string { return string(v) }),
		TopicId:      string(x.TopicID),
	}
}

func TopicRuntimeFromProto(v *destpb.TopicRuntime) *TopicRuntime {
	if v == nil {
		return nil
	}

	return &TopicRuntime{
		KafkaBrokers: sliceMap(v.KafkaBrokers, func(v string) string { return string(v) }),
		TopicID:      string(v.TopicId),
	}
}

func (x *TopicRuntimeEvent) ToProto() *destpb.TopicRuntimeEvent {
	if x == nil {
		return nil
	}
	return &destpb.TopicRuntimeEvent{
		Id:      string(x.ID),
		Payload: x.Payload.ToProto(),
	}
}

func TopicRuntimeEventFromProto(v *destpb.TopicRuntimeEvent) *TopicRuntimeEvent {
	if v == nil {
		return nil
	}

	return &TopicRuntimeEvent{
		ID:      string(v.Id),
		Payload: TopicRuntimeFromProto(v.Payload),
	}
}

// TypeToProto converts a Type sum type to a protobuf message.
func TypeToProto(value Type) *destpb.Type {
	switch value := value.(type) {
	case nil:
		return nil
	case *Any:
		return &destpb.Type{
			Value: &destpb.Type_Any{value.ToProto()},
		}
	case *Array:
		return &destpb.Type{
			Value: &destpb.Type_Array{value.ToProto()},
		}
	case *Bool:
		return &destpb.Type{
			Value: &destpb.Type_Bool{value.ToProto()},
		}
	case *Bytes:
		return &destpb.Type{
			Value: &destpb.Type_Bytes{value.ToProto()},
		}
	case *Float:
		return &destpb.Type{
			Value: &destpb.Type_Float{value.ToProto()},
		}
	case *Int:
		return &destpb.Type{
			Value: &destpb.Type_Int{value.ToProto()},
		}
	case *Map:
		return &destpb.Type{
			Value: &destpb.Type_Map{value.ToProto()},
		}
	case *Optional:
		return &destpb.Type{
			Value: &destpb.Type_Optional{value.ToProto()},
		}
	case *Ref:
		return &destpb.Type{
			Value: &destpb.Type_Ref{value.ToProto()},
		}
	case *String:
		return &destpb.Type{
			Value: &destpb.Type_String_{value.ToProto()},
		}
	case *Time:
		return &destpb.Type{
			Value: &destpb.Type_Time{value.ToProto()},
		}
	case *Unit:
		return &destpb.Type{
			Value: &destpb.Type_Unit{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func TypeFromProto(v *destpb.Type) Type {
	if v == nil {
		return nil
	}
	switch v.Value.(type) {
	case *destpb.Type_Any:
		return AnyFromProto(v.GetAny())
	case *destpb.Type_Array:
		return ArrayFromProto(v.GetArray())
	case *destpb.Type_Bool:
		return BoolFromProto(v.GetBool())
	case *destpb.Type_Bytes:
		return BytesFromProto(v.GetBytes())
	case *destpb.Type_Float:
		return FloatFromProto(v.GetFloat())
	case *destpb.Type_Int:
		return IntFromProto(v.GetInt())
	case *destpb.Type_Map:
		return MapFromProto(v.GetMap())
	case *destpb.Type_Optional:
		return OptionalFromProto(v.GetOptional())
	case *destpb.Type_Ref:
		return RefFromProto(v.GetRef())
	case *destpb.Type_String_:
		return StringFromProto(v.GetString_())
	case *destpb.Type_Time:
		return TimeFromProto(v.GetTime())
	case *destpb.Type_Unit:
		return UnitFromProto(v.GetUnit())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *TypeAlias) ToProto() *destpb.TypeAlias {
	if x == nil {
		return nil
	}
	return &destpb.TypeAlias{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Export:   bool(x.Export),
		Name:     string(x.Name),
		Type:     TypeToProto(x.Type),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
	}
}

func TypeAliasFromProto(v *destpb.TypeAlias) *TypeAlias {
	if v == nil {
		return nil
	}

	return &TypeAlias{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Comments: sliceMap(v.Comments, func(v string) string { return string(v) }),
		Export:   bool(v.Export),
		Name:     string(v.Name),
		Type:     TypeFromProto(v.Type),
		Metadata: sliceMap(v.Metadata, MetadataFromProto),
	}
}

func (x *TypeParameter) ToProto() *destpb.TypeParameter {
	if x == nil {
		return nil
	}
	return &destpb.TypeParameter{
		Pos:  x.Pos.ToProto(),
		Name: string(x.Name),
	}
}

func TypeParameterFromProto(v *destpb.TypeParameter) *TypeParameter {
	if v == nil {
		return nil
	}

	return &TypeParameter{
		Pos:  fromPtr(PositionFromProto(v.Pos)),
		Name: string(v.Name),
	}
}

func (x *TypeValue) ToProto() *destpb.TypeValue {
	if x == nil {
		return nil
	}
	return &destpb.TypeValue{
		Pos:   x.Pos.ToProto(),
		Value: TypeToProto(x.Value),
	}
}

func TypeValueFromProto(v *destpb.TypeValue) *TypeValue {
	if v == nil {
		return nil
	}

	return &TypeValue{
		Pos:   fromPtr(PositionFromProto(v.Pos)),
		Value: TypeFromProto(v.Value),
	}
}

func (x *Unit) ToProto() *destpb.Unit {
	if x == nil {
		return nil
	}
	return &destpb.Unit{
		Pos: x.Pos.ToProto(),
	}
}

func UnitFromProto(v *destpb.Unit) *Unit {
	if v == nil {
		return nil
	}

	return &Unit{
		Pos: fromPtr(PositionFromProto(v.Pos)),
	}
}

// ValueToProto converts a Value sum type to a protobuf message.
func ValueToProto(value Value) *destpb.Value {
	switch value := value.(type) {
	case nil:
		return nil
	case *IntValue:
		return &destpb.Value{
			Value: &destpb.Value_IntValue{value.ToProto()},
		}
	case *StringValue:
		return &destpb.Value{
			Value: &destpb.Value_StringValue{value.ToProto()},
		}
	case *TypeValue:
		return &destpb.Value{
			Value: &destpb.Value_TypeValue{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func ValueFromProto(v *destpb.Value) Value {
	if v == nil {
		return nil
	}
	switch v.Value.(type) {
	case *destpb.Value_IntValue:
		return IntValueFromProto(v.GetIntValue())
	case *destpb.Value_StringValue:
		return StringValueFromProto(v.GetStringValue())
	case *destpb.Value_TypeValue:
		return TypeValueFromProto(v.GetTypeValue())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Verb) ToProto() *destpb.Verb {
	if x == nil {
		return nil
	}
	return &destpb.Verb{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Export:   bool(x.Export),
		Name:     string(x.Name),
		Request:  TypeToProto(x.Request),
		Response: TypeToProto(x.Response),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
		Runtime:  x.Runtime.ToProto(),
	}
}

func VerbFromProto(v *destpb.Verb) *Verb {
	if v == nil {
		return nil
	}

	return &Verb{
		Pos:      fromPtr(PositionFromProto(v.Pos)),
		Comments: sliceMap(v.Comments, func(v string) string { return string(v) }),
		Export:   bool(v.Export),
		Name:     string(v.Name),
		Request:  TypeFromProto(v.Request),
		Response: TypeFromProto(v.Response),
		Metadata: sliceMap(v.Metadata, MetadataFromProto),
		Runtime:  VerbRuntimeFromProto(v.Runtime),
	}
}

func (x *VerbRuntime) ToProto() *destpb.VerbRuntime {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntime{
		Base:         x.Base.ToProto(),
		Subscription: x.Subscription.ToProto(),
	}
}

func VerbRuntimeFromProto(v *destpb.VerbRuntime) *VerbRuntime {
	if v == nil {
		return nil
	}

	return &VerbRuntime{
		Base:         fromPtr(VerbRuntimeBaseFromProto(v.Base)),
		Subscription: VerbRuntimeSubscriptionFromProto(v.Subscription),
	}
}

func (x *VerbRuntimeBase) ToProto() *destpb.VerbRuntimeBase {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntimeBase{
		CreateTime: timestamppb.New(x.CreateTime),
		StartTime:  timestamppb.New(x.StartTime),
	}
}

func VerbRuntimeBaseFromProto(v *destpb.VerbRuntimeBase) *VerbRuntimeBase {
	if v == nil {
		return nil
	}

	return &VerbRuntimeBase{
		CreateTime: v.CreateTime.AsTime(),
		StartTime:  v.StartTime.AsTime(),
	}
}

func (x *VerbRuntimeEvent) ToProto() *destpb.VerbRuntimeEvent {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntimeEvent{
		Id:      string(x.ID),
		Payload: VerbRuntimePayloadToProto(x.Payload),
	}
}

func VerbRuntimeEventFromProto(v *destpb.VerbRuntimeEvent) *VerbRuntimeEvent {
	if v == nil {
		return nil
	}

	return &VerbRuntimeEvent{
		ID:      string(v.Id),
		Payload: VerbRuntimePayloadFromProto(v.Payload),
	}
}

// VerbRuntimePayloadToProto converts a VerbRuntimePayload sum type to a protobuf message.
func VerbRuntimePayloadToProto(value VerbRuntimePayload) *destpb.VerbRuntimePayload {
	switch value := value.(type) {
	case nil:
		return nil
	case *VerbRuntimeBase:
		return &destpb.VerbRuntimePayload{
			Value: &destpb.VerbRuntimePayload_VerbRuntimeBase{value.ToProto()},
		}
	case *VerbRuntimeSubscription:
		return &destpb.VerbRuntimePayload{
			Value: &destpb.VerbRuntimePayload_VerbRuntimeSubscription{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func VerbRuntimePayloadFromProto(v *destpb.VerbRuntimePayload) VerbRuntimePayload {
	if v == nil {
		return nil
	}
	switch v.Value.(type) {
	case *destpb.VerbRuntimePayload_VerbRuntimeBase:
		return VerbRuntimeBaseFromProto(v.GetVerbRuntimeBase())
	case *destpb.VerbRuntimePayload_VerbRuntimeSubscription:
		return VerbRuntimeSubscriptionFromProto(v.GetVerbRuntimeSubscription())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *VerbRuntimeSubscription) ToProto() *destpb.VerbRuntimeSubscription {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntimeSubscription{
		KafkaBrokers: sliceMap(x.KafkaBrokers, func(v string) string { return string(v) }),
	}
}

func VerbRuntimeSubscriptionFromProto(v *destpb.VerbRuntimeSubscription) *VerbRuntimeSubscription {
	if v == nil {
		return nil
	}

	return &VerbRuntimeSubscription{
		KafkaBrokers: sliceMap(v.KafkaBrokers, func(v string) string { return string(v) }),
	}
}
