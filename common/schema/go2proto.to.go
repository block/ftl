// Code generated by go2proto. DO NOT EDIT.

package schema

import "fmt"
import "encoding"
import destpb "github.com/block/ftl/common/protos/xyz/block/ftl/schema/v1"
import "google.golang.org/protobuf/types/known/timestamppb"
import "google.golang.org/protobuf/types/known/durationpb"
import "github.com/alecthomas/types/optional"
import "github.com/alecthomas/types/result"

var _ fmt.Stringer
var _ = timestamppb.Timestamp{}
var _ = durationpb.Duration{}

// protoSlice converts a slice of values to a slice of protobuf values.
func protoSlice[P any, T interface{ ToProto() P }](values []T) []P {
	out := make([]P, len(values))
	for i, v := range values {
		out[i] = v.ToProto()
	}
	return out
}

func protoMust[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func sliceMap[T any, U any](values []T, f func(T) U) []U {
	out := make([]U, len(values))
	for i, v := range values {
		out[i] = f(v)
	}
	return out
}

func sliceMapR[T any, U any](values []T, f func(T) result.Result[U]) result.Result[[]U] {
	out := make([]U, len(values))
	for i, v := range values {
		r := f(v)
		if r.Err() != nil {
			return result.Err[[]U](r.Err())
		}
		out[i], _ = r.Get()
	}
	return result.Ok[[]U](out)
}

func orZero[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func orZeroR[T any](v result.Result[*T]) result.Result[T] {
	if v.Err() != nil {
		return result.Err[T](v.Err())
	}
	r, _ := v.Get()
	return result.Ok[T](orZero(r))
}

func ptr[T any](o T) *T {
	return &o
}

func ptrR[T any](o result.Result[T]) result.Result[*T] {
	if o.Err() != nil {
		return result.Err[*T](o.Err())
	}
	r, _ := o.Get()
	return result.Ok[*T](ptr(r))
}

func fromPtr[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func fromPtrR[T any](v result.Result[*T]) result.Result[T] {
	if v.Err() != nil {
		return result.Err[T](v.Err())
	}
	r, _ := v.Get()
	return result.Ok[T](fromPtr(r))
}

func optionalR[T any](r result.Result[*T]) result.Result[optional.Option[T]] {
	if r.Err() != nil {
		return result.Err[optional.Option[T]](r.Err())
	}
	v, _ := r.Get()
	return result.Ok[optional.Option[T]](optional.Ptr(v))
}

func setNil[T, O any](v *T, o *O) *T {
	if o == nil {
		return nil
	}
	return v
}

func setNilR[T, O any](v result.Result[*T], o *O) result.Result[*T] {
	if v.Err() != nil {
		return v
	}
	r, _ := v.Get()
	return result.Ok[*T](setNil(r, o))
}

type binaryUnmarshallable[T any] interface {
	*T
	encoding.BinaryUnmarshaler
}

type textUnmarshallable[T any] interface {
	*T
	encoding.TextUnmarshaler
}

func unmarshallBinary[T any, TPtr binaryUnmarshallable[T]](v []byte, f TPtr) result.Result[*T] {
	var to T
	toptr := (TPtr)(&to)

	err := toptr.UnmarshalBinary(v)
	if err != nil {
		return result.Err[*T](err)
	}
	return result.Ok[*T](&to)
}

func unmarshallText[T any, TPtr textUnmarshallable[T]](v []byte, f TPtr) result.Result[*T] {
	var to T
	toptr := (TPtr)(&to)

	err := toptr.UnmarshalText(v)
	if err != nil {
		return result.Err[*T](err)
	}
	return result.Ok[*T](&to)
}

func (x *AWSIAMAuthDatabaseConnector) ToProto() *destpb.AWSIAMAuthDatabaseConnector {
	if x == nil {
		return nil
	}
	return &destpb.AWSIAMAuthDatabaseConnector{
		Pos:      x.Pos.ToProto(),
		Username: orZero(ptr(string(x.Username))),
		Endpoint: orZero(ptr(string(x.Endpoint))),
		Database: orZero(ptr(string(x.Database))),
	}
}

func AWSIAMAuthDatabaseConnectorFromProto(v *destpb.AWSIAMAuthDatabaseConnector) (out *AWSIAMAuthDatabaseConnector, err error) {
	if v == nil {
		return nil, nil
	}

	out = &AWSIAMAuthDatabaseConnector{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Username, err = orZeroR(result.From(ptr(string(v.Username)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Username: %w", err)
	}
	if out.Endpoint, err = orZeroR(result.From(ptr(string(v.Endpoint)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Endpoint: %w", err)
	}
	if out.Database, err = orZeroR(result.From(ptr(string(v.Database)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Database: %w", err)
	}
	return out, nil
}

func (x AliasKind) ToProto() destpb.AliasKind {
	return destpb.AliasKind(x)
}

func AliasKindFromProto(v destpb.AliasKind) (AliasKind, error) {
	// TODO: Check if the value is valid.
	return AliasKind(v), nil
}

func (x *Any) ToProto() *destpb.Any {
	if x == nil {
		return nil
	}
	return &destpb.Any{
		Pos: x.Pos.ToProto(),
	}
}

func AnyFromProto(v *destpb.Any) (out *Any, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Any{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *Array) ToProto() *destpb.Array {
	if x == nil {
		return nil
	}
	return &destpb.Array{
		Pos:     x.Pos.ToProto(),
		Element: TypeToProto(x.Element),
	}
}

func ArrayFromProto(v *destpb.Array) (out *Array, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Array{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Element, err = orZeroR(ptrR(result.From(TypeFromProto(v.Element)))).Result(); err != nil {
		return nil, fmt.Errorf("Element: %w", err)
	}
	return out, nil
}

func (x *Bool) ToProto() *destpb.Bool {
	if x == nil {
		return nil
	}
	return &destpb.Bool{
		Pos: x.Pos.ToProto(),
	}
}

func BoolFromProto(v *destpb.Bool) (out *Bool, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Bool{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *Bytes) ToProto() *destpb.Bytes {
	if x == nil {
		return nil
	}
	return &destpb.Bytes{
		Pos: x.Pos.ToProto(),
	}
}

func BytesFromProto(v *destpb.Bytes) (out *Bytes, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Bytes{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *Config) ToProto() *destpb.Config {
	if x == nil {
		return nil
	}
	return &destpb.Config{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Name:     orZero(ptr(string(x.Name))),
		Type:     TypeToProto(x.Type),
	}
}

func ConfigFromProto(v *destpb.Config) (out *Config, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Config{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	return out, nil
}

func (x *DSNDatabaseConnector) ToProto() *destpb.DSNDatabaseConnector {
	if x == nil {
		return nil
	}
	return &destpb.DSNDatabaseConnector{
		Pos: x.Pos.ToProto(),
		Dsn: orZero(ptr(string(x.DSN))),
	}
}

func DSNDatabaseConnectorFromProto(v *destpb.DSNDatabaseConnector) (out *DSNDatabaseConnector, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DSNDatabaseConnector{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.DSN, err = orZeroR(result.From(ptr(string(v.Dsn)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("DSN: %w", err)
	}
	return out, nil
}

func (x *Data) ToProto() *destpb.Data {
	if x == nil {
		return nil
	}
	return &destpb.Data{
		Pos:            x.Pos.ToProto(),
		Comments:       sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Export:         orZero(ptr(bool(x.Export))),
		Name:           orZero(ptr(string(x.Name))),
		TypeParameters: sliceMap(x.TypeParameters, func(v *TypeParameter) *destpb.TypeParameter { return v.ToProto() }),
		Fields:         sliceMap(x.Fields, func(v *Field) *destpb.Field { return v.ToProto() }),
		Metadata:       sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
	}
}

func DataFromProto(v *destpb.Data) (out *Data, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Data{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Export, err = orZeroR(result.From(ptr(bool(v.Export)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Export: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.TypeParameters, err = sliceMapR(v.TypeParameters, func(v *destpb.TypeParameter) result.Result[*TypeParameter] {
		return result.From(TypeParameterFromProto(v))
	}).Result(); err != nil {
		return nil, fmt.Errorf("TypeParameters: %w", err)
	}
	if out.Fields, err = sliceMapR(v.Fields, func(v *destpb.Field) result.Result[*Field] { return result.From(FieldFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Fields: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *Database) ToProto() *destpb.Database {
	if x == nil {
		return nil
	}
	return &destpb.Database{
		Pos:      x.Pos.ToProto(),
		Runtime:  x.Runtime.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Type:     orZero(ptr(string(x.Type))),
		Name:     orZero(ptr(string(x.Name))),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
	}
}

func DatabaseFromProto(v *destpb.Database) (out *Database, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Database{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Runtime, err = result.From(DatabaseRuntimeFromProto(v.Runtime)).Result(); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Type, err = orZeroR(result.From(ptr(string(v.Type)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

// DatabaseConnectorToProto converts a DatabaseConnector sum type to a protobuf message.
func DatabaseConnectorToProto(value DatabaseConnector) *destpb.DatabaseConnector {
	switch value := value.(type) {
	case nil:
		return nil
	case *AWSIAMAuthDatabaseConnector:
		return &destpb.DatabaseConnector{
			Value: &destpb.DatabaseConnector_AwsiamAuthDatabaseConnector{value.ToProto()},
		}
	case *DSNDatabaseConnector:
		return &destpb.DatabaseConnector{
			Value: &destpb.DatabaseConnector_DsnDatabaseConnector{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DatabaseConnectorFromProto(v *destpb.DatabaseConnector) (DatabaseConnector, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.DatabaseConnector_AwsiamAuthDatabaseConnector:
		return AWSIAMAuthDatabaseConnectorFromProto(v.GetAwsiamAuthDatabaseConnector())
	case *destpb.DatabaseConnector_DsnDatabaseConnector:
		return DSNDatabaseConnectorFromProto(v.GetDsnDatabaseConnector())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *DatabaseRuntime) ToProto() *destpb.DatabaseRuntime {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntime{
		Connections: x.Connections.ToProto(),
	}
}

func DatabaseRuntimeFromProto(v *destpb.DatabaseRuntime) (out *DatabaseRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DatabaseRuntime{}
	if out.Connections, err = result.From(DatabaseRuntimeConnectionsFromProto(v.Connections)).Result(); err != nil {
		return nil, fmt.Errorf("Connections: %w", err)
	}
	return out, nil
}

func (x *DatabaseRuntimeConnections) ToProto() *destpb.DatabaseRuntimeConnections {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntimeConnections{
		Read:  DatabaseConnectorToProto(x.Read),
		Write: DatabaseConnectorToProto(x.Write),
	}
}

func DatabaseRuntimeConnectionsFromProto(v *destpb.DatabaseRuntimeConnections) (out *DatabaseRuntimeConnections, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DatabaseRuntimeConnections{}
	if out.Read, err = orZeroR(ptrR(result.From(DatabaseConnectorFromProto(v.Read)))).Result(); err != nil {
		return nil, fmt.Errorf("Read: %w", err)
	}
	if out.Write, err = orZeroR(ptrR(result.From(DatabaseConnectorFromProto(v.Write)))).Result(); err != nil {
		return nil, fmt.Errorf("Write: %w", err)
	}
	return out, nil
}

func (x *DatabaseRuntimeConnectionsEvent) ToProto() *destpb.DatabaseRuntimeConnectionsEvent {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntimeConnectionsEvent{
		Connections: x.Connections.ToProto(),
	}
}

func DatabaseRuntimeConnectionsEventFromProto(v *destpb.DatabaseRuntimeConnectionsEvent) (out *DatabaseRuntimeConnectionsEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DatabaseRuntimeConnectionsEvent{}
	if out.Connections, err = result.From(DatabaseRuntimeConnectionsFromProto(v.Connections)).Result(); err != nil {
		return nil, fmt.Errorf("Connections: %w", err)
	}
	return out, nil
}

func (x *DatabaseRuntimeEvent) ToProto() *destpb.DatabaseRuntimeEvent {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntimeEvent{
		Id:      orZero(ptr(string(x.ID))),
		Payload: DatabaseRuntimeEventPayloadToProto(x.Payload),
	}
}

func DatabaseRuntimeEventFromProto(v *destpb.DatabaseRuntimeEvent) (out *DatabaseRuntimeEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DatabaseRuntimeEvent{}
	if out.ID, err = orZeroR(result.From(ptr(string(v.Id)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("ID: %w", err)
	}
	if out.Payload, err = orZeroR(ptrR(result.From(DatabaseRuntimeEventPayloadFromProto(v.Payload)))).Result(); err != nil {
		return nil, fmt.Errorf("Payload: %w", err)
	}
	return out, nil
}

// DatabaseRuntimeEventPayloadToProto converts a DatabaseRuntimeEventPayload sum type to a protobuf message.
func DatabaseRuntimeEventPayloadToProto(value DatabaseRuntimeEventPayload) *destpb.DatabaseRuntimeEventPayload {
	switch value := value.(type) {
	case nil:
		return nil
	case *DatabaseRuntimeConnectionsEvent:
		return &destpb.DatabaseRuntimeEventPayload{
			Value: &destpb.DatabaseRuntimeEventPayload_DatabaseRuntimeConnectionsEvent{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DatabaseRuntimeEventPayloadFromProto(v *destpb.DatabaseRuntimeEventPayload) (DatabaseRuntimeEventPayload, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.DatabaseRuntimeEventPayload_DatabaseRuntimeConnectionsEvent:
		return DatabaseRuntimeConnectionsEventFromProto(v.GetDatabaseRuntimeConnectionsEvent())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

// DeclToProto converts a Decl sum type to a protobuf message.
func DeclToProto(value Decl) *destpb.Decl {
	switch value := value.(type) {
	case nil:
		return nil
	case *Config:
		return &destpb.Decl{
			Value: &destpb.Decl_Config{value.ToProto()},
		}
	case *Data:
		return &destpb.Decl{
			Value: &destpb.Decl_Data{value.ToProto()},
		}
	case *Database:
		return &destpb.Decl{
			Value: &destpb.Decl_Database{value.ToProto()},
		}
	case *Enum:
		return &destpb.Decl{
			Value: &destpb.Decl_Enum{value.ToProto()},
		}
	case *Secret:
		return &destpb.Decl{
			Value: &destpb.Decl_Secret{value.ToProto()},
		}
	case *Topic:
		return &destpb.Decl{
			Value: &destpb.Decl_Topic{value.ToProto()},
		}
	case *TypeAlias:
		return &destpb.Decl{
			Value: &destpb.Decl_TypeAlias{value.ToProto()},
		}
	case *Verb:
		return &destpb.Decl{
			Value: &destpb.Decl_Verb{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DeclFromProto(v *destpb.Decl) (Decl, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Decl_Config:
		return ConfigFromProto(v.GetConfig())
	case *destpb.Decl_Data:
		return DataFromProto(v.GetData())
	case *destpb.Decl_Database:
		return DatabaseFromProto(v.GetDatabase())
	case *destpb.Decl_Enum:
		return EnumFromProto(v.GetEnum())
	case *destpb.Decl_Secret:
		return SecretFromProto(v.GetSecret())
	case *destpb.Decl_Topic:
		return TopicFromProto(v.GetTopic())
	case *destpb.Decl_TypeAlias:
		return TypeAliasFromProto(v.GetTypeAlias())
	case *destpb.Decl_Verb:
		return VerbFromProto(v.GetVerb())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Enum) ToProto() *destpb.Enum {
	if x == nil {
		return nil
	}
	return &destpb.Enum{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Export:   orZero(ptr(bool(x.Export))),
		Name:     orZero(ptr(string(x.Name))),
		Type:     TypeToProto(x.Type),
		Variants: sliceMap(x.Variants, func(v *EnumVariant) *destpb.EnumVariant { return v.ToProto() }),
	}
}

func EnumFromProto(v *destpb.Enum) (out *Enum, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Enum{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Export, err = orZeroR(result.From(ptr(bool(v.Export)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Export: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Variants, err = sliceMapR(v.Variants, func(v *destpb.EnumVariant) result.Result[*EnumVariant] { return result.From(EnumVariantFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Variants: %w", err)
	}
	return out, nil
}

func (x *EnumVariant) ToProto() *destpb.EnumVariant {
	if x == nil {
		return nil
	}
	return &destpb.EnumVariant{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Name:     orZero(ptr(string(x.Name))),
		Value:    ValueToProto(x.Value),
	}
}

func EnumVariantFromProto(v *destpb.EnumVariant) (out *EnumVariant, err error) {
	if v == nil {
		return nil, nil
	}

	out = &EnumVariant{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Value, err = orZeroR(ptrR(result.From(ValueFromProto(v.Value)))).Result(); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

func (x *Field) ToProto() *destpb.Field {
	if x == nil {
		return nil
	}
	return &destpb.Field{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Name:     orZero(ptr(string(x.Name))),
		Type:     TypeToProto(x.Type),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
	}
}

func FieldFromProto(v *destpb.Field) (out *Field, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Field{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *Float) ToProto() *destpb.Float {
	if x == nil {
		return nil
	}
	return &destpb.Float{
		Pos: x.Pos.ToProto(),
	}
}

func FloatFromProto(v *destpb.Float) (out *Float, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Float{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x FromOffset) ToProto() destpb.FromOffset {
	return destpb.FromOffset(x)
}

func FromOffsetFromProto(v destpb.FromOffset) (FromOffset, error) {
	// TODO: Check if the value is valid.
	return FromOffset(v), nil
}

// IngressPathComponentToProto converts a IngressPathComponent sum type to a protobuf message.
func IngressPathComponentToProto(value IngressPathComponent) *destpb.IngressPathComponent {
	switch value := value.(type) {
	case nil:
		return nil
	case *IngressPathLiteral:
		return &destpb.IngressPathComponent{
			Value: &destpb.IngressPathComponent_IngressPathLiteral{value.ToProto()},
		}
	case *IngressPathParameter:
		return &destpb.IngressPathComponent{
			Value: &destpb.IngressPathComponent_IngressPathParameter{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func IngressPathComponentFromProto(v *destpb.IngressPathComponent) (IngressPathComponent, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.IngressPathComponent_IngressPathLiteral:
		return IngressPathLiteralFromProto(v.GetIngressPathLiteral())
	case *destpb.IngressPathComponent_IngressPathParameter:
		return IngressPathParameterFromProto(v.GetIngressPathParameter())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *IngressPathLiteral) ToProto() *destpb.IngressPathLiteral {
	if x == nil {
		return nil
	}
	return &destpb.IngressPathLiteral{
		Pos:  x.Pos.ToProto(),
		Text: orZero(ptr(string(x.Text))),
	}
}

func IngressPathLiteralFromProto(v *destpb.IngressPathLiteral) (out *IngressPathLiteral, err error) {
	if v == nil {
		return nil, nil
	}

	out = &IngressPathLiteral{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Text, err = orZeroR(result.From(ptr(string(v.Text)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Text: %w", err)
	}
	return out, nil
}

func (x *IngressPathParameter) ToProto() *destpb.IngressPathParameter {
	if x == nil {
		return nil
	}
	return &destpb.IngressPathParameter{
		Pos:  x.Pos.ToProto(),
		Name: orZero(ptr(string(x.Name))),
	}
}

func IngressPathParameterFromProto(v *destpb.IngressPathParameter) (out *IngressPathParameter, err error) {
	if v == nil {
		return nil, nil
	}

	out = &IngressPathParameter{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	return out, nil
}

func (x *Int) ToProto() *destpb.Int {
	if x == nil {
		return nil
	}
	return &destpb.Int{
		Pos: x.Pos.ToProto(),
	}
}

func IntFromProto(v *destpb.Int) (out *Int, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Int{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *IntValue) ToProto() *destpb.IntValue {
	if x == nil {
		return nil
	}
	return &destpb.IntValue{
		Pos:   x.Pos.ToProto(),
		Value: orZero(ptr(int64(x.Value))),
	}
}

func IntValueFromProto(v *destpb.IntValue) (out *IntValue, err error) {
	if v == nil {
		return nil, nil
	}

	out = &IntValue{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Value, err = orZeroR(result.From(ptr(int(v.Value)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

func (x *Map) ToProto() *destpb.Map {
	if x == nil {
		return nil
	}
	return &destpb.Map{
		Pos:   x.Pos.ToProto(),
		Key:   TypeToProto(x.Key),
		Value: TypeToProto(x.Value),
	}
}

func MapFromProto(v *destpb.Map) (out *Map, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Map{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Key, err = orZeroR(ptrR(result.From(TypeFromProto(v.Key)))).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if out.Value, err = orZeroR(ptrR(result.From(TypeFromProto(v.Value)))).Result(); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

// MetadataToProto converts a Metadata sum type to a protobuf message.
func MetadataToProto(value Metadata) *destpb.Metadata {
	switch value := value.(type) {
	case nil:
		return nil
	case *MetadataAlias:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Alias{value.ToProto()},
		}
	case *MetadataArtefact:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Artefact{value.ToProto()},
		}
	case *MetadataCalls:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Calls{value.ToProto()},
		}
	case *MetadataConfig:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Config{value.ToProto()},
		}
	case *MetadataCronJob:
		return &destpb.Metadata{
			Value: &destpb.Metadata_CronJob{value.ToProto()},
		}
	case *MetadataDatabases:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Databases{value.ToProto()},
		}
	case *MetadataEncoding:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Encoding{value.ToProto()},
		}
	case *MetadataIngress:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Ingress{value.ToProto()},
		}
	case *MetadataPartitions:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Partitions{value.ToProto()},
		}
	case *MetadataPublisher:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Publisher{value.ToProto()},
		}
	case *MetadataRetry:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Retry{value.ToProto()},
		}
	case *MetadataSQLColumn:
		return &destpb.Metadata{
			Value: &destpb.Metadata_SqlColumn{value.ToProto()},
		}
	case *MetadataSQLMigration:
		return &destpb.Metadata{
			Value: &destpb.Metadata_SqlMigration{value.ToProto()},
		}
	case *MetadataSQLQuery:
		return &destpb.Metadata{
			Value: &destpb.Metadata_SqlQuery{value.ToProto()},
		}
	case *MetadataSecrets:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Secrets{value.ToProto()},
		}
	case *MetadataSubscriber:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Subscriber{value.ToProto()},
		}
	case *MetadataTypeMap:
		return &destpb.Metadata{
			Value: &destpb.Metadata_TypeMap{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func MetadataFromProto(v *destpb.Metadata) (Metadata, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Metadata_Alias:
		return MetadataAliasFromProto(v.GetAlias())
	case *destpb.Metadata_Artefact:
		return MetadataArtefactFromProto(v.GetArtefact())
	case *destpb.Metadata_Calls:
		return MetadataCallsFromProto(v.GetCalls())
	case *destpb.Metadata_Config:
		return MetadataConfigFromProto(v.GetConfig())
	case *destpb.Metadata_CronJob:
		return MetadataCronJobFromProto(v.GetCronJob())
	case *destpb.Metadata_Databases:
		return MetadataDatabasesFromProto(v.GetDatabases())
	case *destpb.Metadata_Encoding:
		return MetadataEncodingFromProto(v.GetEncoding())
	case *destpb.Metadata_Ingress:
		return MetadataIngressFromProto(v.GetIngress())
	case *destpb.Metadata_Partitions:
		return MetadataPartitionsFromProto(v.GetPartitions())
	case *destpb.Metadata_Publisher:
		return MetadataPublisherFromProto(v.GetPublisher())
	case *destpb.Metadata_Retry:
		return MetadataRetryFromProto(v.GetRetry())
	case *destpb.Metadata_SqlColumn:
		return MetadataSQLColumnFromProto(v.GetSqlColumn())
	case *destpb.Metadata_SqlMigration:
		return MetadataSQLMigrationFromProto(v.GetSqlMigration())
	case *destpb.Metadata_SqlQuery:
		return MetadataSQLQueryFromProto(v.GetSqlQuery())
	case *destpb.Metadata_Secrets:
		return MetadataSecretsFromProto(v.GetSecrets())
	case *destpb.Metadata_Subscriber:
		return MetadataSubscriberFromProto(v.GetSubscriber())
	case *destpb.Metadata_TypeMap:
		return MetadataTypeMapFromProto(v.GetTypeMap())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *MetadataAlias) ToProto() *destpb.MetadataAlias {
	if x == nil {
		return nil
	}
	return &destpb.MetadataAlias{
		Pos:   x.Pos.ToProto(),
		Kind:  orZero(ptr(x.Kind.ToProto())),
		Alias: orZero(ptr(string(x.Alias))),
	}
}

func MetadataAliasFromProto(v *destpb.MetadataAlias) (out *MetadataAlias, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataAlias{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Kind, err = orZeroR(ptrR(result.From(AliasKindFromProto(v.Kind)))).Result(); err != nil {
		return nil, fmt.Errorf("Kind: %w", err)
	}
	if out.Alias, err = orZeroR(result.From(ptr(string(v.Alias)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Alias: %w", err)
	}
	return out, nil
}

func (x *MetadataArtefact) ToProto() *destpb.MetadataArtefact {
	if x == nil {
		return nil
	}
	return &destpb.MetadataArtefact{
		Pos:        x.Pos.ToProto(),
		Path:       orZero(ptr(string(x.Path))),
		Digest:     orZero(ptr(string(x.Digest))),
		Executable: orZero(ptr(bool(x.Executable))),
	}
}

func MetadataArtefactFromProto(v *destpb.MetadataArtefact) (out *MetadataArtefact, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataArtefact{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Path, err = orZeroR(result.From(ptr(string(v.Path)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Path: %w", err)
	}
	if out.Digest, err = orZeroR(result.From(ptr(string(v.Digest)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Digest: %w", err)
	}
	if out.Executable, err = orZeroR(result.From(ptr(bool(v.Executable)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Executable: %w", err)
	}
	return out, nil
}

func (x *MetadataCalls) ToProto() *destpb.MetadataCalls {
	if x == nil {
		return nil
	}
	return &destpb.MetadataCalls{
		Pos:   x.Pos.ToProto(),
		Calls: sliceMap(x.Calls, func(v *Ref) *destpb.Ref { return v.ToProto() }),
	}
}

func MetadataCallsFromProto(v *destpb.MetadataCalls) (out *MetadataCalls, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataCalls{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Calls, err = sliceMapR(v.Calls, func(v *destpb.Ref) result.Result[*Ref] { return result.From(RefFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Calls: %w", err)
	}
	return out, nil
}

func (x *MetadataConfig) ToProto() *destpb.MetadataConfig {
	if x == nil {
		return nil
	}
	return &destpb.MetadataConfig{
		Pos:    x.Pos.ToProto(),
		Config: sliceMap(x.Config, func(v *Ref) *destpb.Ref { return v.ToProto() }),
	}
}

func MetadataConfigFromProto(v *destpb.MetadataConfig) (out *MetadataConfig, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataConfig{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Config, err = sliceMapR(v.Config, func(v *destpb.Ref) result.Result[*Ref] { return result.From(RefFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Config: %w", err)
	}
	return out, nil
}

func (x *MetadataCronJob) ToProto() *destpb.MetadataCronJob {
	if x == nil {
		return nil
	}
	return &destpb.MetadataCronJob{
		Pos:  x.Pos.ToProto(),
		Cron: orZero(ptr(string(x.Cron))),
	}
}

func MetadataCronJobFromProto(v *destpb.MetadataCronJob) (out *MetadataCronJob, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataCronJob{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
<<<<<<< HEAD
	if out.Cron, err = orZeroR(result.From(ptr(string(v.Cron)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Cron: %w", err)
	}
=======
	out.Cron = string(v.Cron)
>>>>>>> 505dfe2d4 (fix hot reload)
	return out, nil
}

func (x *MetadataDatabases) ToProto() *destpb.MetadataDatabases {
	if x == nil {
		return nil
	}
	return &destpb.MetadataDatabases{
		Pos:   x.Pos.ToProto(),
		Calls: sliceMap(x.Calls, func(v *Ref) *destpb.Ref { return v.ToProto() }),
	}
}

func MetadataDatabasesFromProto(v *destpb.MetadataDatabases) (out *MetadataDatabases, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataDatabases{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Calls, err = sliceMapR(v.Calls, func(v *destpb.Ref) result.Result[*Ref] { return result.From(RefFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Calls: %w", err)
	}
	return out, nil
}

func (x *MetadataEncoding) ToProto() *destpb.MetadataEncoding {
	if x == nil {
		return nil
	}
	return &destpb.MetadataEncoding{
		Pos:     x.Pos.ToProto(),
		Type:    orZero(ptr(string(x.Type))),
		Lenient: orZero(ptr(bool(x.Lenient))),
	}
}

func MetadataEncodingFromProto(v *destpb.MetadataEncoding) (out *MetadataEncoding, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataEncoding{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Type, err = orZeroR(result.From(ptr(string(v.Type)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Lenient, err = orZeroR(result.From(ptr(bool(v.Lenient)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Lenient: %w", err)
	}
	return out, nil
}

func (x *MetadataIngress) ToProto() *destpb.MetadataIngress {
	if x == nil {
		return nil
	}
	return &destpb.MetadataIngress{
		Pos:    x.Pos.ToProto(),
		Type:   orZero(ptr(string(x.Type))),
		Method: orZero(ptr(string(x.Method))),
		Path:   sliceMap(x.Path, func(v IngressPathComponent) *destpb.IngressPathComponent { return IngressPathComponentToProto(v) }),
	}
}

func MetadataIngressFromProto(v *destpb.MetadataIngress) (out *MetadataIngress, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataIngress{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Type, err = orZeroR(result.From(ptr(string(v.Type)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Method, err = orZeroR(result.From(ptr(string(v.Method)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Method: %w", err)
	}
	if out.Path, err = sliceMapR(v.Path, func(v *destpb.IngressPathComponent) result.Result[IngressPathComponent] {
		return orZeroR(ptrR(result.From(IngressPathComponentFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Path: %w", err)
	}
	return out, nil
}

func (x *MetadataPartitions) ToProto() *destpb.MetadataPartitions {
	if x == nil {
		return nil
	}
	return &destpb.MetadataPartitions{
		Pos:        x.Pos.ToProto(),
		Partitions: orZero(ptr(int64(x.Partitions))),
	}
}

func MetadataPartitionsFromProto(v *destpb.MetadataPartitions) (out *MetadataPartitions, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataPartitions{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Partitions, err = orZeroR(result.From(ptr(int(v.Partitions)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Partitions: %w", err)
	}
	return out, nil
}

func (x *MetadataPublisher) ToProto() *destpb.MetadataPublisher {
	if x == nil {
		return nil
	}
	return &destpb.MetadataPublisher{
		Pos:    x.Pos.ToProto(),
		Topics: sliceMap(x.Topics, func(v *Ref) *destpb.Ref { return v.ToProto() }),
	}
}

func MetadataPublisherFromProto(v *destpb.MetadataPublisher) (out *MetadataPublisher, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataPublisher{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Topics, err = sliceMapR(v.Topics, func(v *destpb.Ref) result.Result[*Ref] { return result.From(RefFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Topics: %w", err)
	}
	return out, nil
}

func (x *MetadataRetry) ToProto() *destpb.MetadataRetry {
	if x == nil {
		return nil
	}
	return &destpb.MetadataRetry{
		Pos:        x.Pos.ToProto(),
		Count:      setNil(ptr(int64(orZero(x.Count))), x.Count),
		MinBackoff: orZero(ptr(string(x.MinBackoff))),
		MaxBackoff: orZero(ptr(string(x.MaxBackoff))),
		Catch:      x.Catch.ToProto(),
	}
}

func MetadataRetryFromProto(v *destpb.MetadataRetry) (out *MetadataRetry, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataRetry{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Count, err = result.From(setNil(ptr(int(orZero(v.Count))), v.Count), nil).Result(); err != nil {
		return nil, fmt.Errorf("Count: %w", err)
	}
	if out.MinBackoff, err = orZeroR(result.From(ptr(string(v.MinBackoff)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("MinBackoff: %w", err)
	}
	if out.MaxBackoff, err = orZeroR(result.From(ptr(string(v.MaxBackoff)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("MaxBackoff: %w", err)
	}
	if out.Catch, err = result.From(RefFromProto(v.Catch)).Result(); err != nil {
		return nil, fmt.Errorf("Catch: %w", err)
	}
	return out, nil
}

func (x *MetadataSQLColumn) ToProto() *destpb.MetadataSQLColumn {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSQLColumn{
		Pos:   x.Pos.ToProto(),
<<<<<<< HEAD
		Table: orZero(ptr(string(x.Table))),
		Name:  orZero(ptr(string(x.Name))),
=======
		Table: string(x.Table),
		Name:  string(x.Name),
>>>>>>> 505dfe2d4 (fix hot reload)
	}
}

func MetadataSQLColumnFromProto(v *destpb.MetadataSQLColumn) (out *MetadataSQLColumn, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSQLColumn{}
<<<<<<< HEAD
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Table, err = orZeroR(result.From(ptr(string(v.Table)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Table: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
=======
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Table = string(v.Table)
	out.Name = string(v.Name)
>>>>>>> 505dfe2d4 (fix hot reload)
	return out, nil
}

func (x *MetadataSQLMigration) ToProto() *destpb.MetadataSQLMigration {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSQLMigration{
		Pos:    x.Pos.ToProto(),
		Digest: orZero(ptr(string(x.Digest))),
	}
}

func MetadataSQLMigrationFromProto(v *destpb.MetadataSQLMigration) (out *MetadataSQLMigration, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSQLMigration{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Digest, err = orZeroR(result.From(ptr(string(v.Digest)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Digest: %w", err)
	}
	return out, nil
}

func (x *MetadataSQLQuery) ToProto() *destpb.MetadataSQLQuery {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSQLQuery{
		Pos:     x.Pos.ToProto(),
		Command: orZero(ptr(string(x.Command))),
		Query:   orZero(ptr(string(x.Query))),
	}
}

func MetadataSQLQueryFromProto(v *destpb.MetadataSQLQuery) (out *MetadataSQLQuery, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSQLQuery{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Command, err = orZeroR(result.From(ptr(string(v.Command)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Command: %w", err)
	}
	if out.Query, err = orZeroR(result.From(ptr(string(v.Query)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Query: %w", err)
	}
	return out, nil
}

func (x *MetadataSecrets) ToProto() *destpb.MetadataSecrets {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSecrets{
		Pos:     x.Pos.ToProto(),
		Secrets: sliceMap(x.Secrets, func(v *Ref) *destpb.Ref { return v.ToProto() }),
	}
}

func MetadataSecretsFromProto(v *destpb.MetadataSecrets) (out *MetadataSecrets, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSecrets{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Secrets, err = sliceMapR(v.Secrets, func(v *destpb.Ref) result.Result[*Ref] { return result.From(RefFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Secrets: %w", err)
	}
	return out, nil
}

func (x *MetadataSubscriber) ToProto() *destpb.MetadataSubscriber {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSubscriber{
		Pos:        x.Pos.ToProto(),
		Topic:      x.Topic.ToProto(),
		FromOffset: orZero(ptr(x.FromOffset.ToProto())),
		DeadLetter: orZero(ptr(bool(x.DeadLetter))),
	}
}

func MetadataSubscriberFromProto(v *destpb.MetadataSubscriber) (out *MetadataSubscriber, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSubscriber{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Topic, err = result.From(RefFromProto(v.Topic)).Result(); err != nil {
		return nil, fmt.Errorf("Topic: %w", err)
	}
	if out.FromOffset, err = orZeroR(ptrR(result.From(FromOffsetFromProto(v.FromOffset)))).Result(); err != nil {
		return nil, fmt.Errorf("FromOffset: %w", err)
	}
	if out.DeadLetter, err = orZeroR(result.From(ptr(bool(v.DeadLetter)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("DeadLetter: %w", err)
	}
	return out, nil
}

func (x *MetadataTypeMap) ToProto() *destpb.MetadataTypeMap {
	if x == nil {
		return nil
	}
	return &destpb.MetadataTypeMap{
		Pos:        x.Pos.ToProto(),
		Runtime:    orZero(ptr(string(x.Runtime))),
		NativeName: orZero(ptr(string(x.NativeName))),
	}
}

func MetadataTypeMapFromProto(v *destpb.MetadataTypeMap) (out *MetadataTypeMap, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataTypeMap{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Runtime, err = orZeroR(result.From(ptr(string(v.Runtime)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	if out.NativeName, err = orZeroR(result.From(ptr(string(v.NativeName)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("NativeName: %w", err)
	}
	return out, nil
}

func (x *Module) ToProto() *destpb.Module {
	if x == nil {
		return nil
	}
	return &destpb.Module{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Builtin:  orZero(ptr(bool(x.Builtin))),
		Name:     orZero(ptr(string(x.Name))),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
		Decls:    sliceMap(x.Decls, func(v Decl) *destpb.Decl { return DeclToProto(v) }),
		Runtime:  x.Runtime.ToProto(),
	}
}

func ModuleFromProto(v *destpb.Module) (out *Module, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Module{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Builtin, err = orZeroR(result.From(ptr(bool(v.Builtin)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Builtin: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	if out.Decls, err = sliceMapR(v.Decls, func(v *destpb.Decl) result.Result[Decl] { return orZeroR(ptrR(result.From(DeclFromProto(v)))) }).Result(); err != nil {
		return nil, fmt.Errorf("Decls: %w", err)
	}
	if out.Runtime, err = result.From(ModuleRuntimeFromProto(v.Runtime)).Result(); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *ModuleRuntime) ToProto() *destpb.ModuleRuntime {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntime{
		Base:       x.Base.ToProto(),
		Scaling:    x.Scaling.ToProto(),
		Deployment: x.Deployment.ToProto(),
	}
}

func ModuleRuntimeFromProto(v *destpb.ModuleRuntime) (out *ModuleRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntime{}
	if out.Base, err = orZeroR(result.From(ModuleRuntimeBaseFromProto(v.Base))).Result(); err != nil {
		return nil, fmt.Errorf("Base: %w", err)
	}
	if out.Scaling, err = result.From(ModuleRuntimeScalingFromProto(v.Scaling)).Result(); err != nil {
		return nil, fmt.Errorf("Scaling: %w", err)
	}
	if out.Deployment, err = result.From(ModuleRuntimeDeploymentFromProto(v.Deployment)).Result(); err != nil {
		return nil, fmt.Errorf("Deployment: %w", err)
	}
	return out, nil
}

func (x *ModuleRuntimeBase) ToProto() *destpb.ModuleRuntimeBase {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeBase{
		CreateTime: timestamppb.New(x.CreateTime),
		Language:   orZero(ptr(string(x.Language))),
		Os:         ptr(string(x.OS)),
		Arch:       ptr(string(x.Arch)),
		Image:      ptr(string(x.Image)),
	}
}

func ModuleRuntimeBaseFromProto(v *destpb.ModuleRuntimeBase) (out *ModuleRuntimeBase, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntimeBase{}
	if out.CreateTime, err = orZeroR(result.From(setNil(ptr(v.CreateTime.AsTime()), v.CreateTime), nil)).Result(); err != nil {
		return nil, fmt.Errorf("CreateTime: %w", err)
	}
	if out.Language, err = orZeroR(result.From(ptr(string(v.Language)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Language: %w", err)
	}
	if out.OS, err = orZeroR(result.From(setNil(ptr(string(orZero(v.Os))), v.Os), nil)).Result(); err != nil {
		return nil, fmt.Errorf("OS: %w", err)
	}
	if out.Arch, err = orZeroR(result.From(setNil(ptr(string(orZero(v.Arch))), v.Arch), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Arch: %w", err)
	}
	if out.Image, err = orZeroR(result.From(setNil(ptr(string(orZero(v.Image))), v.Image), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Image: %w", err)
	}
	return out, nil
}

func (x *ModuleRuntimeDeployment) ToProto() *destpb.ModuleRuntimeDeployment {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeDeployment{
		Endpoint:      orZero(ptr(string(x.Endpoint))),
		DeploymentKey: orZero(ptr(string(protoMust(x.DeploymentKey.MarshalText())))),
		CreatedAt:     timestamppb.New(x.CreatedAt),
		ActivatedAt:   setNil(timestamppb.New(orZero(x.ActivatedAt.Ptr())), x.ActivatedAt.Ptr()),
	}
}

func ModuleRuntimeDeploymentFromProto(v *destpb.ModuleRuntimeDeployment) (out *ModuleRuntimeDeployment, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntimeDeployment{}
	if out.Endpoint, err = orZeroR(result.From(ptr(string(v.Endpoint)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Endpoint: %w", err)
	}
	if out.DeploymentKey, err = orZeroR(unmarshallText([]byte(v.DeploymentKey), &out.DeploymentKey)).Result(); err != nil {
		return nil, fmt.Errorf("DeploymentKey: %w", err)
	}
	if out.CreatedAt, err = orZeroR(result.From(setNil(ptr(v.CreatedAt.AsTime()), v.CreatedAt), nil)).Result(); err != nil {
		return nil, fmt.Errorf("CreatedAt: %w", err)
	}
	if out.ActivatedAt, err = optionalR(result.From(setNil(ptr(v.ActivatedAt.AsTime()), v.ActivatedAt), nil)).Result(); err != nil {
		return nil, fmt.Errorf("ActivatedAt: %w", err)
	}
	return out, nil
}

// ModuleRuntimeEventToProto converts a ModuleRuntimeEvent sum type to a protobuf message.
func ModuleRuntimeEventToProto(value ModuleRuntimeEvent) *destpb.ModuleRuntimeEvent {
	switch value := value.(type) {
	case nil:
		return nil
	case *ModuleRuntimeBase:
		return &destpb.ModuleRuntimeEvent{
			Value: &destpb.ModuleRuntimeEvent_ModuleRuntimeBase{value.ToProto()},
		}
	case *ModuleRuntimeDeployment:
		return &destpb.ModuleRuntimeEvent{
			Value: &destpb.ModuleRuntimeEvent_ModuleRuntimeDeployment{value.ToProto()},
		}
	case *ModuleRuntimeScaling:
		return &destpb.ModuleRuntimeEvent{
			Value: &destpb.ModuleRuntimeEvent_ModuleRuntimeScaling{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func ModuleRuntimeEventFromProto(v *destpb.ModuleRuntimeEvent) (ModuleRuntimeEvent, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.ModuleRuntimeEvent_ModuleRuntimeBase:
		return ModuleRuntimeBaseFromProto(v.GetModuleRuntimeBase())
	case *destpb.ModuleRuntimeEvent_ModuleRuntimeDeployment:
		return ModuleRuntimeDeploymentFromProto(v.GetModuleRuntimeDeployment())
	case *destpb.ModuleRuntimeEvent_ModuleRuntimeScaling:
		return ModuleRuntimeScalingFromProto(v.GetModuleRuntimeScaling())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *ModuleRuntimeScaling) ToProto() *destpb.ModuleRuntimeScaling {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeScaling{
		MinReplicas: orZero(ptr(int32(x.MinReplicas))),
	}
}

func ModuleRuntimeScalingFromProto(v *destpb.ModuleRuntimeScaling) (out *ModuleRuntimeScaling, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntimeScaling{}
	if out.MinReplicas, err = orZeroR(result.From(ptr(int32(v.MinReplicas)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("MinReplicas: %w", err)
	}
	return out, nil
}

func (x *Optional) ToProto() *destpb.Optional {
	if x == nil {
		return nil
	}
	return &destpb.Optional{
		Pos:  x.Pos.ToProto(),
		Type: TypeToProto(x.Type),
	}
}

func OptionalFromProto(v *destpb.Optional) (out *Optional, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Optional{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	return out, nil
}

func (x *Position) ToProto() *destpb.Position {
	if x == nil {
		return nil
	}
	return &destpb.Position{
		Filename: orZero(ptr(string(x.Filename))),
		Line:     orZero(ptr(int64(x.Line))),
		Column:   orZero(ptr(int64(x.Column))),
	}
}

func PositionFromProto(v *destpb.Position) (out *Position, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Position{}
	if out.Filename, err = orZeroR(result.From(ptr(string(v.Filename)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Filename: %w", err)
	}
	if out.Line, err = orZeroR(result.From(ptr(int(v.Line)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Line: %w", err)
	}
	if out.Column, err = orZeroR(result.From(ptr(int(v.Column)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Column: %w", err)
	}
	return out, nil
}

func (x *Ref) ToProto() *destpb.Ref {
	if x == nil {
		return nil
	}
	return &destpb.Ref{
		Pos:            x.Pos.ToProto(),
		Module:         orZero(ptr(string(x.Module))),
		Name:           orZero(ptr(string(x.Name))),
		TypeParameters: sliceMap(x.TypeParameters, func(v Type) *destpb.Type { return TypeToProto(v) }),
	}
}

func RefFromProto(v *destpb.Ref) (out *Ref, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Ref{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Module, err = orZeroR(result.From(ptr(string(v.Module)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Module: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.TypeParameters, err = sliceMapR(v.TypeParameters, func(v *destpb.Type) result.Result[Type] { return orZeroR(ptrR(result.From(TypeFromProto(v)))) }).Result(); err != nil {
		return nil, fmt.Errorf("TypeParameters: %w", err)
	}
	return out, nil
}

// RuntimeEventToProto converts a RuntimeEvent sum type to a protobuf message.
func RuntimeEventToProto(value RuntimeEvent) *destpb.RuntimeEvent {
	switch value := value.(type) {
	case nil:
		return nil
	case *DatabaseRuntimeEvent:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_DatabaseRuntimeEvent{value.ToProto()},
		}
	case *ModuleRuntimeBase:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_ModuleRuntimeBase{value.ToProto()},
		}
	case *ModuleRuntimeDeployment:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_ModuleRuntimeDeployment{value.ToProto()},
		}
	case *ModuleRuntimeScaling:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_ModuleRuntimeScaling{value.ToProto()},
		}
	case *TopicRuntimeEvent:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_TopicRuntimeEvent{value.ToProto()},
		}
	case *VerbRuntimeEvent:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_VerbRuntimeEvent{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func RuntimeEventFromProto(v *destpb.RuntimeEvent) (RuntimeEvent, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.RuntimeEvent_DatabaseRuntimeEvent:
		return DatabaseRuntimeEventFromProto(v.GetDatabaseRuntimeEvent())
	case *destpb.RuntimeEvent_ModuleRuntimeBase:
		return ModuleRuntimeBaseFromProto(v.GetModuleRuntimeBase())
	case *destpb.RuntimeEvent_ModuleRuntimeDeployment:
		return ModuleRuntimeDeploymentFromProto(v.GetModuleRuntimeDeployment())
	case *destpb.RuntimeEvent_ModuleRuntimeScaling:
		return ModuleRuntimeScalingFromProto(v.GetModuleRuntimeScaling())
	case *destpb.RuntimeEvent_TopicRuntimeEvent:
		return TopicRuntimeEventFromProto(v.GetTopicRuntimeEvent())
	case *destpb.RuntimeEvent_VerbRuntimeEvent:
		return VerbRuntimeEventFromProto(v.GetVerbRuntimeEvent())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Schema) ToProto() *destpb.Schema {
	if x == nil {
		return nil
	}
	return &destpb.Schema{
		Pos:     x.Pos.ToProto(),
		Modules: sliceMap(x.Modules, func(v *Module) *destpb.Module { return v.ToProto() }),
	}
}

func SchemaFromProto(v *destpb.Schema) (out *Schema, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Schema{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Modules, err = sliceMapR(v.Modules, func(v *destpb.Module) result.Result[*Module] { return result.From(ModuleFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("Modules: %w", err)
	}
	return out, nil
}

func (x *Secret) ToProto() *destpb.Secret {
	if x == nil {
		return nil
	}
	return &destpb.Secret{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Name:     orZero(ptr(string(x.Name))),
		Type:     TypeToProto(x.Type),
	}
}

func SecretFromProto(v *destpb.Secret) (out *Secret, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Secret{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	return out, nil
}

func (x *String) ToProto() *destpb.String {
	if x == nil {
		return nil
	}
	return &destpb.String{
		Pos: x.Pos.ToProto(),
	}
}

func StringFromProto(v *destpb.String) (out *String, err error) {
	if v == nil {
		return nil, nil
	}

	out = &String{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *StringValue) ToProto() *destpb.StringValue {
	if x == nil {
		return nil
	}
	return &destpb.StringValue{
		Pos:   x.Pos.ToProto(),
		Value: orZero(ptr(string(x.Value))),
	}
}

func StringValueFromProto(v *destpb.StringValue) (out *StringValue, err error) {
	if v == nil {
		return nil, nil
	}

	out = &StringValue{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Value, err = orZeroR(result.From(ptr(string(v.Value)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

func (x *Time) ToProto() *destpb.Time {
	if x == nil {
		return nil
	}
	return &destpb.Time{
		Pos: x.Pos.ToProto(),
	}
}

func TimeFromProto(v *destpb.Time) (out *Time, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Time{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

func (x *Topic) ToProto() *destpb.Topic {
	if x == nil {
		return nil
	}
	return &destpb.Topic{
		Pos:      x.Pos.ToProto(),
		Runtime:  x.Runtime.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Export:   orZero(ptr(bool(x.Export))),
		Name:     orZero(ptr(string(x.Name))),
		Event:    TypeToProto(x.Event),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
	}
}

func TopicFromProto(v *destpb.Topic) (out *Topic, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Topic{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Runtime, err = result.From(TopicRuntimeFromProto(v.Runtime)).Result(); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Export, err = orZeroR(result.From(ptr(bool(v.Export)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Export: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Event, err = orZeroR(ptrR(result.From(TypeFromProto(v.Event)))).Result(); err != nil {
		return nil, fmt.Errorf("Event: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *TopicRuntime) ToProto() *destpb.TopicRuntime {
	if x == nil {
		return nil
	}
	return &destpb.TopicRuntime{
		KafkaBrokers: sliceMap(x.KafkaBrokers, func(v string) string { return orZero(ptr(string(v))) }),
		TopicId:      orZero(ptr(string(x.TopicID))),
	}
}

func TopicRuntimeFromProto(v *destpb.TopicRuntime) (out *TopicRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TopicRuntime{}
	if out.KafkaBrokers, err = sliceMapR(v.KafkaBrokers, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("KafkaBrokers: %w", err)
	}
	if out.TopicID, err = orZeroR(result.From(ptr(string(v.TopicId)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("TopicID: %w", err)
	}
	return out, nil
}

func (x *TopicRuntimeEvent) ToProto() *destpb.TopicRuntimeEvent {
	if x == nil {
		return nil
	}
	return &destpb.TopicRuntimeEvent{
		Id:      orZero(ptr(string(x.ID))),
		Payload: x.Payload.ToProto(),
	}
}

func TopicRuntimeEventFromProto(v *destpb.TopicRuntimeEvent) (out *TopicRuntimeEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TopicRuntimeEvent{}
	if out.ID, err = orZeroR(result.From(ptr(string(v.Id)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("ID: %w", err)
	}
	if out.Payload, err = result.From(TopicRuntimeFromProto(v.Payload)).Result(); err != nil {
		return nil, fmt.Errorf("Payload: %w", err)
	}
	return out, nil
}

// TypeToProto converts a Type sum type to a protobuf message.
func TypeToProto(value Type) *destpb.Type {
	switch value := value.(type) {
	case nil:
		return nil
	case *Any:
		return &destpb.Type{
			Value: &destpb.Type_Any{value.ToProto()},
		}
	case *Array:
		return &destpb.Type{
			Value: &destpb.Type_Array{value.ToProto()},
		}
	case *Bool:
		return &destpb.Type{
			Value: &destpb.Type_Bool{value.ToProto()},
		}
	case *Bytes:
		return &destpb.Type{
			Value: &destpb.Type_Bytes{value.ToProto()},
		}
	case *Float:
		return &destpb.Type{
			Value: &destpb.Type_Float{value.ToProto()},
		}
	case *Int:
		return &destpb.Type{
			Value: &destpb.Type_Int{value.ToProto()},
		}
	case *Map:
		return &destpb.Type{
			Value: &destpb.Type_Map{value.ToProto()},
		}
	case *Optional:
		return &destpb.Type{
			Value: &destpb.Type_Optional{value.ToProto()},
		}
	case *Ref:
		return &destpb.Type{
			Value: &destpb.Type_Ref{value.ToProto()},
		}
	case *String:
		return &destpb.Type{
			Value: &destpb.Type_String_{value.ToProto()},
		}
	case *Time:
		return &destpb.Type{
			Value: &destpb.Type_Time{value.ToProto()},
		}
	case *Unit:
		return &destpb.Type{
			Value: &destpb.Type_Unit{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func TypeFromProto(v *destpb.Type) (Type, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Type_Any:
		return AnyFromProto(v.GetAny())
	case *destpb.Type_Array:
		return ArrayFromProto(v.GetArray())
	case *destpb.Type_Bool:
		return BoolFromProto(v.GetBool())
	case *destpb.Type_Bytes:
		return BytesFromProto(v.GetBytes())
	case *destpb.Type_Float:
		return FloatFromProto(v.GetFloat())
	case *destpb.Type_Int:
		return IntFromProto(v.GetInt())
	case *destpb.Type_Map:
		return MapFromProto(v.GetMap())
	case *destpb.Type_Optional:
		return OptionalFromProto(v.GetOptional())
	case *destpb.Type_Ref:
		return RefFromProto(v.GetRef())
	case *destpb.Type_String_:
		return StringFromProto(v.GetString_())
	case *destpb.Type_Time:
		return TimeFromProto(v.GetTime())
	case *destpb.Type_Unit:
		return UnitFromProto(v.GetUnit())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *TypeAlias) ToProto() *destpb.TypeAlias {
	if x == nil {
		return nil
	}
	return &destpb.TypeAlias{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Export:   orZero(ptr(bool(x.Export))),
		Name:     orZero(ptr(string(x.Name))),
		Type:     TypeToProto(x.Type),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
	}
}

func TypeAliasFromProto(v *destpb.TypeAlias) (out *TypeAlias, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TypeAlias{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Export, err = orZeroR(result.From(ptr(bool(v.Export)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Export: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Type, err = orZeroR(ptrR(result.From(TypeFromProto(v.Type)))).Result(); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *TypeParameter) ToProto() *destpb.TypeParameter {
	if x == nil {
		return nil
	}
	return &destpb.TypeParameter{
		Pos:  x.Pos.ToProto(),
		Name: orZero(ptr(string(x.Name))),
	}
}

func TypeParameterFromProto(v *destpb.TypeParameter) (out *TypeParameter, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TypeParameter{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	return out, nil
}

func (x *TypeValue) ToProto() *destpb.TypeValue {
	if x == nil {
		return nil
	}
	return &destpb.TypeValue{
		Pos:   x.Pos.ToProto(),
		Value: TypeToProto(x.Value),
	}
}

func TypeValueFromProto(v *destpb.TypeValue) (out *TypeValue, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TypeValue{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Value, err = orZeroR(ptrR(result.From(TypeFromProto(v.Value)))).Result(); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

func (x *Unit) ToProto() *destpb.Unit {
	if x == nil {
		return nil
	}
	return &destpb.Unit{
		Pos: x.Pos.ToProto(),
	}
}

func UnitFromProto(v *destpb.Unit) (out *Unit, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Unit{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	return out, nil
}

// ValueToProto converts a Value sum type to a protobuf message.
func ValueToProto(value Value) *destpb.Value {
	switch value := value.(type) {
	case nil:
		return nil
	case *IntValue:
		return &destpb.Value{
			Value: &destpb.Value_IntValue{value.ToProto()},
		}
	case *StringValue:
		return &destpb.Value{
			Value: &destpb.Value_StringValue{value.ToProto()},
		}
	case *TypeValue:
		return &destpb.Value{
			Value: &destpb.Value_TypeValue{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func ValueFromProto(v *destpb.Value) (Value, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Value_IntValue:
		return IntValueFromProto(v.GetIntValue())
	case *destpb.Value_StringValue:
		return StringValueFromProto(v.GetStringValue())
	case *destpb.Value_TypeValue:
		return TypeValueFromProto(v.GetTypeValue())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Verb) ToProto() *destpb.Verb {
	if x == nil {
		return nil
	}
	return &destpb.Verb{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return orZero(ptr(string(v))) }),
		Export:   orZero(ptr(bool(x.Export))),
		Name:     orZero(ptr(string(x.Name))),
		Request:  TypeToProto(x.Request),
		Response: TypeToProto(x.Response),
		Metadata: sliceMap(x.Metadata, func(v Metadata) *destpb.Metadata { return MetadataToProto(v) }),
		Runtime:  x.Runtime.ToProto(),
	}
}

func VerbFromProto(v *destpb.Verb) (out *Verb, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Verb{}
	if out.Pos, err = orZeroR(result.From(PositionFromProto(v.Pos))).Result(); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	}
	if out.Comments, err = sliceMapR(v.Comments, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("Comments: %w", err)
	}
	if out.Export, err = orZeroR(result.From(ptr(bool(v.Export)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Export: %w", err)
	}
	if out.Name, err = orZeroR(result.From(ptr(string(v.Name)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Name: %w", err)
	}
	if out.Request, err = orZeroR(ptrR(result.From(TypeFromProto(v.Request)))).Result(); err != nil {
		return nil, fmt.Errorf("Request: %w", err)
	}
	if out.Response, err = orZeroR(ptrR(result.From(TypeFromProto(v.Response)))).Result(); err != nil {
		return nil, fmt.Errorf("Response: %w", err)
	}
	if out.Metadata, err = sliceMapR(v.Metadata, func(v *destpb.Metadata) result.Result[Metadata] {
		return orZeroR(ptrR(result.From(MetadataFromProto(v))))
	}).Result(); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	if out.Runtime, err = result.From(VerbRuntimeFromProto(v.Runtime)).Result(); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	return out, nil
}

func (x *VerbRuntime) ToProto() *destpb.VerbRuntime {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntime{
		Base:         x.Base.ToProto(),
		Subscription: x.Subscription.ToProto(),
	}
}

func VerbRuntimeFromProto(v *destpb.VerbRuntime) (out *VerbRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &VerbRuntime{}
	if out.Base, err = orZeroR(result.From(VerbRuntimeBaseFromProto(v.Base))).Result(); err != nil {
		return nil, fmt.Errorf("Base: %w", err)
	}
	if out.Subscription, err = result.From(VerbRuntimeSubscriptionFromProto(v.Subscription)).Result(); err != nil {
		return nil, fmt.Errorf("Subscription: %w", err)
	}
	return out, nil
}

func (x *VerbRuntimeBase) ToProto() *destpb.VerbRuntimeBase {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntimeBase{
		CreateTime: timestamppb.New(x.CreateTime),
		StartTime:  timestamppb.New(x.StartTime),
	}
}

func VerbRuntimeBaseFromProto(v *destpb.VerbRuntimeBase) (out *VerbRuntimeBase, err error) {
	if v == nil {
		return nil, nil
	}

	out = &VerbRuntimeBase{}
	if out.CreateTime, err = orZeroR(result.From(setNil(ptr(v.CreateTime.AsTime()), v.CreateTime), nil)).Result(); err != nil {
		return nil, fmt.Errorf("CreateTime: %w", err)
	}
	if out.StartTime, err = orZeroR(result.From(setNil(ptr(v.StartTime.AsTime()), v.StartTime), nil)).Result(); err != nil {
		return nil, fmt.Errorf("StartTime: %w", err)
	}
	return out, nil
}

func (x *VerbRuntimeEvent) ToProto() *destpb.VerbRuntimeEvent {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntimeEvent{
		Id:      orZero(ptr(string(x.ID))),
		Payload: VerbRuntimePayloadToProto(x.Payload),
	}
}

func VerbRuntimeEventFromProto(v *destpb.VerbRuntimeEvent) (out *VerbRuntimeEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &VerbRuntimeEvent{}
	if out.ID, err = orZeroR(result.From(ptr(string(v.Id)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("ID: %w", err)
	}
	if out.Payload, err = orZeroR(ptrR(result.From(VerbRuntimePayloadFromProto(v.Payload)))).Result(); err != nil {
		return nil, fmt.Errorf("Payload: %w", err)
	}
	return out, nil
}

// VerbRuntimePayloadToProto converts a VerbRuntimePayload sum type to a protobuf message.
func VerbRuntimePayloadToProto(value VerbRuntimePayload) *destpb.VerbRuntimePayload {
	switch value := value.(type) {
	case nil:
		return nil
	case *VerbRuntimeBase:
		return &destpb.VerbRuntimePayload{
			Value: &destpb.VerbRuntimePayload_VerbRuntimeBase{value.ToProto()},
		}
	case *VerbRuntimeSubscription:
		return &destpb.VerbRuntimePayload{
			Value: &destpb.VerbRuntimePayload_VerbRuntimeSubscription{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func VerbRuntimePayloadFromProto(v *destpb.VerbRuntimePayload) (VerbRuntimePayload, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.VerbRuntimePayload_VerbRuntimeBase:
		return VerbRuntimeBaseFromProto(v.GetVerbRuntimeBase())
	case *destpb.VerbRuntimePayload_VerbRuntimeSubscription:
		return VerbRuntimeSubscriptionFromProto(v.GetVerbRuntimeSubscription())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *VerbRuntimeSubscription) ToProto() *destpb.VerbRuntimeSubscription {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntimeSubscription{
		KafkaBrokers: sliceMap(x.KafkaBrokers, func(v string) string { return orZero(ptr(string(v))) }),
	}
}

func VerbRuntimeSubscriptionFromProto(v *destpb.VerbRuntimeSubscription) (out *VerbRuntimeSubscription, err error) {
	if v == nil {
		return nil, nil
	}

	out = &VerbRuntimeSubscription{}
	if out.KafkaBrokers, err = sliceMapR(v.KafkaBrokers, func(v string) result.Result[string] { return orZeroR(result.From(ptr(string(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("KafkaBrokers: %w", err)
	}
	return out, nil
}
