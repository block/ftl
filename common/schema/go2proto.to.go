// Code generated by go2proto. DO NOT EDIT.

package schema

import "fmt"
import destpb "github.com/block/ftl/common/protos/xyz/block/ftl/schema/v1"
import "google.golang.org/protobuf/proto"
import "google.golang.org/protobuf/types/known/timestamppb"
import "google.golang.org/protobuf/types/known/durationpb"

var _ fmt.Stringer
var _ = timestamppb.Timestamp{}
var _ = durationpb.Duration{}

// protoSlice converts a slice of values to a slice of protobuf values.
func protoSlice[P any, T interface{ ToProto() P }](values []T) []P {
	out := make([]P, len(values))
	for i, v := range values {
		out[i] = v.ToProto()
	}
	return out
}

func protoMust[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func sliceMap[T any, U any](values []T, f func(T) U) []U {
	out := make([]U, len(values))
	for i, v := range values {
		out[i] = f(v)
	}
	return out
}

func sliceMapErr[T any, U any](values []T, f func(T) (U, error)) ([]U, error) {
	var err error
	out := make([]U, len(values))
	for i, v := range values {
		if out[i], err = f(v); err != nil {
			return nil, err
		}
	}
	return out, nil
}

func orZero[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func ptr[T any, O any](v *O, o T) *T {
	if v == nil {
		return nil
	}
	return &o
}

func fromPtr[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func (x *AWSIAMAuthDatabaseConnector) ToProto() *destpb.AWSIAMAuthDatabaseConnector {
	if x == nil {
		return nil
	}
	return &destpb.AWSIAMAuthDatabaseConnector{
		Pos:      x.Pos.ToProto(),
		Username: string(x.Username),
		Endpoint: string(x.Endpoint),
		Database: string(x.Database),
	}
}

func AWSIAMAuthDatabaseConnectorFromProto(v *destpb.AWSIAMAuthDatabaseConnector) (out *AWSIAMAuthDatabaseConnector, err error) {
	if v == nil {
		return nil, nil
	}

	out = &AWSIAMAuthDatabaseConnector{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Username = string(v.Username)
	out.Endpoint = string(v.Endpoint)
	out.Database = string(v.Database)
	return out, nil
}

func (x AliasKind) ToProto() destpb.AliasKind {
	return destpb.AliasKind(x)
}

func AliasKindFromProto(v destpb.AliasKind) (AliasKind, error) {
	// TODO: Check if the value is valid.
	return AliasKind(v), nil
}

func (x *Any) ToProto() *destpb.Any {
	if x == nil {
		return nil
	}
	return &destpb.Any{
		Pos: x.Pos.ToProto(),
	}
}

func AnyFromProto(v *destpb.Any) (out *Any, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Any{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	return out, nil
}

func (x *Array) ToProto() *destpb.Array {
	if x == nil {
		return nil
	}
	return &destpb.Array{
		Pos:     x.Pos.ToProto(),
		Element: TypeToProto(x.Element),
	}
}

func ArrayFromProto(v *destpb.Array) (out *Array, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Array{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Element, err = TypeFromProto(v.Element); err != nil {
		return nil, fmt.Errorf("Element: %w", err)
	}
	return out, nil
}

func (x *Bool) ToProto() *destpb.Bool {
	if x == nil {
		return nil
	}
	return &destpb.Bool{
		Pos: x.Pos.ToProto(),
	}
}

func BoolFromProto(v *destpb.Bool) (out *Bool, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Bool{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	return out, nil
}

func (x *Bytes) ToProto() *destpb.Bytes {
	if x == nil {
		return nil
	}
	return &destpb.Bytes{
		Pos: x.Pos.ToProto(),
	}
}

func BytesFromProto(v *destpb.Bytes) (out *Bytes, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Bytes{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	return out, nil
}

func (x *Config) ToProto() *destpb.Config {
	if x == nil {
		return nil
	}
	return &destpb.Config{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Name:     string(x.Name),
		Type:     TypeToProto(x.Type),
	}
}

func ConfigFromProto(v *destpb.Config) (out *Config, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Config{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Name = string(v.Name)
	if out.Type, err = TypeFromProto(v.Type); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	return out, nil
}

func (x *DSNDatabaseConnector) ToProto() *destpb.DSNDatabaseConnector {
	if x == nil {
		return nil
	}
	return &destpb.DSNDatabaseConnector{
		Pos: x.Pos.ToProto(),
		Dsn: string(x.DSN),
	}
}

func DSNDatabaseConnectorFromProto(v *destpb.DSNDatabaseConnector) (out *DSNDatabaseConnector, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DSNDatabaseConnector{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.DSN = string(v.Dsn)
	return out, nil
}

func (x *Data) ToProto() *destpb.Data {
	if x == nil {
		return nil
	}
	return &destpb.Data{
		Pos:            x.Pos.ToProto(),
		Comments:       sliceMap(x.Comments, func(v string) string { return string(v) }),
		Export:         bool(x.Export),
		Name:           string(x.Name),
		TypeParameters: protoSlice[*destpb.TypeParameter](x.TypeParameters),
		Fields:         protoSlice[*destpb.Field](x.Fields),
		Metadata:       sliceMap(x.Metadata, MetadataToProto),
	}
}

func DataFromProto(v *destpb.Data) (out *Data, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Data{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Export = bool(v.Export)
	out.Name = string(v.Name)
	if out.TypeParameters, err = sliceMapErr(v.TypeParameters, TypeParameterFromProto); err != nil {
		return nil, fmt.Errorf("TypeParameters: %w", err)
	}
	if out.Fields, err = sliceMapErr(v.Fields, FieldFromProto); err != nil {
		return nil, fmt.Errorf("Fields: %w", err)
	}
	if out.Metadata, err = sliceMapErr(v.Metadata, MetadataFromProto); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *Database) ToProto() *destpb.Database {
	if x == nil {
		return nil
	}
	return &destpb.Database{
		Pos:      x.Pos.ToProto(),
		Runtime:  x.Runtime.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Type:     string(x.Type),
		Name:     string(x.Name),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
	}
}

func DatabaseFromProto(v *destpb.Database) (out *Database, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Database{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Runtime, err = DatabaseRuntimeFromProto(v.Runtime); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Type = string(v.Type)
	out.Name = string(v.Name)
	if out.Metadata, err = sliceMapErr(v.Metadata, MetadataFromProto); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

// DatabaseConnectorToProto converts a DatabaseConnector sum type to a protobuf message.
func DatabaseConnectorToProto(value DatabaseConnector) *destpb.DatabaseConnector {
	switch value := value.(type) {
	case nil:
		return nil
	case *AWSIAMAuthDatabaseConnector:
		return &destpb.DatabaseConnector{
			Value: &destpb.DatabaseConnector_AwsiamAuthDatabaseConnector{value.ToProto()},
		}
	case *DSNDatabaseConnector:
		return &destpb.DatabaseConnector{
			Value: &destpb.DatabaseConnector_DsnDatabaseConnector{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DatabaseConnectorFromProto(v *destpb.DatabaseConnector) (DatabaseConnector, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.DatabaseConnector_AwsiamAuthDatabaseConnector:
		return AWSIAMAuthDatabaseConnectorFromProto(v.GetAwsiamAuthDatabaseConnector())
	case *destpb.DatabaseConnector_DsnDatabaseConnector:
		return DSNDatabaseConnectorFromProto(v.GetDsnDatabaseConnector())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *DatabaseRuntime) ToProto() *destpb.DatabaseRuntime {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntime{
		Connections: x.Connections.ToProto(),
	}
}

func DatabaseRuntimeFromProto(v *destpb.DatabaseRuntime) (out *DatabaseRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DatabaseRuntime{}
	if out.Connections, err = DatabaseRuntimeConnectionsFromProto(v.Connections); err != nil {
		return nil, fmt.Errorf("Connections: %w", err)
	}
	return out, nil
}

func (x *DatabaseRuntimeConnections) ToProto() *destpb.DatabaseRuntimeConnections {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntimeConnections{
		Read:  DatabaseConnectorToProto(x.Read),
		Write: DatabaseConnectorToProto(x.Write),
	}
}

func DatabaseRuntimeConnectionsFromProto(v *destpb.DatabaseRuntimeConnections) (out *DatabaseRuntimeConnections, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DatabaseRuntimeConnections{}
	if out.Read, err = DatabaseConnectorFromProto(v.Read); err != nil {
		return nil, fmt.Errorf("Read: %w", err)
	}
	if out.Write, err = DatabaseConnectorFromProto(v.Write); err != nil {
		return nil, fmt.Errorf("Write: %w", err)
	}
	return out, nil
}

func (x *DatabaseRuntimeConnectionsEvent) ToProto() *destpb.DatabaseRuntimeConnectionsEvent {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntimeConnectionsEvent{
		Connections: x.Connections.ToProto(),
	}
}

func DatabaseRuntimeConnectionsEventFromProto(v *destpb.DatabaseRuntimeConnectionsEvent) (out *DatabaseRuntimeConnectionsEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DatabaseRuntimeConnectionsEvent{}
	if out.Connections, err = DatabaseRuntimeConnectionsFromProto(v.Connections); err != nil {
		return nil, fmt.Errorf("Connections: %w", err)
	}
	return out, nil
}

func (x *DatabaseRuntimeEvent) ToProto() *destpb.DatabaseRuntimeEvent {
	if x == nil {
		return nil
	}
	return &destpb.DatabaseRuntimeEvent{
		Id:      string(x.ID),
		Payload: DatabaseRuntimeEventPayloadToProto(x.Payload),
	}
}

func DatabaseRuntimeEventFromProto(v *destpb.DatabaseRuntimeEvent) (out *DatabaseRuntimeEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &DatabaseRuntimeEvent{}
	out.ID = string(v.Id)
	if out.Payload, err = DatabaseRuntimeEventPayloadFromProto(v.Payload); err != nil {
		return nil, fmt.Errorf("Payload: %w", err)
	}
	return out, nil
}

// DatabaseRuntimeEventPayloadToProto converts a DatabaseRuntimeEventPayload sum type to a protobuf message.
func DatabaseRuntimeEventPayloadToProto(value DatabaseRuntimeEventPayload) *destpb.DatabaseRuntimeEventPayload {
	switch value := value.(type) {
	case nil:
		return nil
	case *DatabaseRuntimeConnectionsEvent:
		return &destpb.DatabaseRuntimeEventPayload{
			Value: &destpb.DatabaseRuntimeEventPayload_DatabaseRuntimeConnectionsEvent{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DatabaseRuntimeEventPayloadFromProto(v *destpb.DatabaseRuntimeEventPayload) (DatabaseRuntimeEventPayload, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.DatabaseRuntimeEventPayload_DatabaseRuntimeConnectionsEvent:
		return DatabaseRuntimeConnectionsEventFromProto(v.GetDatabaseRuntimeConnectionsEvent())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

// DeclToProto converts a Decl sum type to a protobuf message.
func DeclToProto(value Decl) *destpb.Decl {
	switch value := value.(type) {
	case nil:
		return nil
	case *Config:
		return &destpb.Decl{
			Value: &destpb.Decl_Config{value.ToProto()},
		}
	case *Data:
		return &destpb.Decl{
			Value: &destpb.Decl_Data{value.ToProto()},
		}
	case *Database:
		return &destpb.Decl{
			Value: &destpb.Decl_Database{value.ToProto()},
		}
	case *Enum:
		return &destpb.Decl{
			Value: &destpb.Decl_Enum{value.ToProto()},
		}
	case *Secret:
		return &destpb.Decl{
			Value: &destpb.Decl_Secret{value.ToProto()},
		}
	case *Topic:
		return &destpb.Decl{
			Value: &destpb.Decl_Topic{value.ToProto()},
		}
	case *TypeAlias:
		return &destpb.Decl{
			Value: &destpb.Decl_TypeAlias{value.ToProto()},
		}
	case *Verb:
		return &destpb.Decl{
			Value: &destpb.Decl_Verb{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func DeclFromProto(v *destpb.Decl) (Decl, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Decl_Config:
		return ConfigFromProto(v.GetConfig())
	case *destpb.Decl_Data:
		return DataFromProto(v.GetData())
	case *destpb.Decl_Database:
		return DatabaseFromProto(v.GetDatabase())
	case *destpb.Decl_Enum:
		return EnumFromProto(v.GetEnum())
	case *destpb.Decl_Secret:
		return SecretFromProto(v.GetSecret())
	case *destpb.Decl_Topic:
		return TopicFromProto(v.GetTopic())
	case *destpb.Decl_TypeAlias:
		return TypeAliasFromProto(v.GetTypeAlias())
	case *destpb.Decl_Verb:
		return VerbFromProto(v.GetVerb())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Enum) ToProto() *destpb.Enum {
	if x == nil {
		return nil
	}
	return &destpb.Enum{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Export:   bool(x.Export),
		Name:     string(x.Name),
		Type:     TypeToProto(x.Type),
		Variants: protoSlice[*destpb.EnumVariant](x.Variants),
	}
}

func EnumFromProto(v *destpb.Enum) (out *Enum, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Enum{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Export = bool(v.Export)
	out.Name = string(v.Name)
	if out.Type, err = TypeFromProto(v.Type); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Variants, err = sliceMapErr(v.Variants, EnumVariantFromProto); err != nil {
		return nil, fmt.Errorf("Variants: %w", err)
	}
	return out, nil
}

func (x *EnumVariant) ToProto() *destpb.EnumVariant {
	if x == nil {
		return nil
	}
	return &destpb.EnumVariant{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Name:     string(x.Name),
		Value:    ValueToProto(x.Value),
	}
}

func EnumVariantFromProto(v *destpb.EnumVariant) (out *EnumVariant, err error) {
	if v == nil {
		return nil, nil
	}

	out = &EnumVariant{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Name = string(v.Name)
	if out.Value, err = ValueFromProto(v.Value); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

func (x *Field) ToProto() *destpb.Field {
	if x == nil {
		return nil
	}
	return &destpb.Field{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Name:     string(x.Name),
		Type:     TypeToProto(x.Type),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
	}
}

func FieldFromProto(v *destpb.Field) (out *Field, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Field{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Name = string(v.Name)
	if out.Type, err = TypeFromProto(v.Type); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Metadata, err = sliceMapErr(v.Metadata, MetadataFromProto); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *Float) ToProto() *destpb.Float {
	if x == nil {
		return nil
	}
	return &destpb.Float{
		Pos: x.Pos.ToProto(),
	}
}

func FloatFromProto(v *destpb.Float) (out *Float, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Float{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	return out, nil
}

func (x FromOffset) ToProto() destpb.FromOffset {
	return destpb.FromOffset(x)
}

func FromOffsetFromProto(v destpb.FromOffset) (FromOffset, error) {
	// TODO: Check if the value is valid.
	return FromOffset(v), nil
}

// IngressPathComponentToProto converts a IngressPathComponent sum type to a protobuf message.
func IngressPathComponentToProto(value IngressPathComponent) *destpb.IngressPathComponent {
	switch value := value.(type) {
	case nil:
		return nil
	case *IngressPathLiteral:
		return &destpb.IngressPathComponent{
			Value: &destpb.IngressPathComponent_IngressPathLiteral{value.ToProto()},
		}
	case *IngressPathParameter:
		return &destpb.IngressPathComponent{
			Value: &destpb.IngressPathComponent_IngressPathParameter{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func IngressPathComponentFromProto(v *destpb.IngressPathComponent) (IngressPathComponent, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.IngressPathComponent_IngressPathLiteral:
		return IngressPathLiteralFromProto(v.GetIngressPathLiteral())
	case *destpb.IngressPathComponent_IngressPathParameter:
		return IngressPathParameterFromProto(v.GetIngressPathParameter())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *IngressPathLiteral) ToProto() *destpb.IngressPathLiteral {
	if x == nil {
		return nil
	}
	return &destpb.IngressPathLiteral{
		Pos:  x.Pos.ToProto(),
		Text: string(x.Text),
	}
}

func IngressPathLiteralFromProto(v *destpb.IngressPathLiteral) (out *IngressPathLiteral, err error) {
	if v == nil {
		return nil, nil
	}

	out = &IngressPathLiteral{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Text = string(v.Text)
	return out, nil
}

func (x *IngressPathParameter) ToProto() *destpb.IngressPathParameter {
	if x == nil {
		return nil
	}
	return &destpb.IngressPathParameter{
		Pos:  x.Pos.ToProto(),
		Name: string(x.Name),
	}
}

func IngressPathParameterFromProto(v *destpb.IngressPathParameter) (out *IngressPathParameter, err error) {
	if v == nil {
		return nil, nil
	}

	out = &IngressPathParameter{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Name = string(v.Name)
	return out, nil
}

func (x *Int) ToProto() *destpb.Int {
	if x == nil {
		return nil
	}
	return &destpb.Int{
		Pos: x.Pos.ToProto(),
	}
}

func IntFromProto(v *destpb.Int) (out *Int, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Int{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	return out, nil
}

func (x *IntValue) ToProto() *destpb.IntValue {
	if x == nil {
		return nil
	}
	return &destpb.IntValue{
		Pos:   x.Pos.ToProto(),
		Value: int64(x.Value),
	}
}

func IntValueFromProto(v *destpb.IntValue) (out *IntValue, err error) {
	if v == nil {
		return nil, nil
	}

	out = &IntValue{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Value = int(v.Value)
	return out, nil
}

func (x *Map) ToProto() *destpb.Map {
	if x == nil {
		return nil
	}
	return &destpb.Map{
		Pos:   x.Pos.ToProto(),
		Key:   TypeToProto(x.Key),
		Value: TypeToProto(x.Value),
	}
}

func MapFromProto(v *destpb.Map) (out *Map, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Map{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Key, err = TypeFromProto(v.Key); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if out.Value, err = TypeFromProto(v.Value); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

// MetadataToProto converts a Metadata sum type to a protobuf message.
func MetadataToProto(value Metadata) *destpb.Metadata {
	switch value := value.(type) {
	case nil:
		return nil
	case *MetadataAlias:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Alias{value.ToProto()},
		}
	case *MetadataArtefact:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Artefact{value.ToProto()},
		}
	case *MetadataCalls:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Calls{value.ToProto()},
		}
	case *MetadataConfig:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Config{value.ToProto()},
		}
	case *MetadataCronJob:
		return &destpb.Metadata{
			Value: &destpb.Metadata_CronJob{value.ToProto()},
		}
	case *MetadataDBColumn:
		return &destpb.Metadata{
			Value: &destpb.Metadata_DbColumn{value.ToProto()},
		}
	case *MetadataDatabases:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Databases{value.ToProto()},
		}
	case *MetadataEncoding:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Encoding{value.ToProto()},
		}
	case *MetadataIngress:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Ingress{value.ToProto()},
		}
	case *MetadataPartitions:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Partitions{value.ToProto()},
		}
	case *MetadataPublisher:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Publisher{value.ToProto()},
		}
	case *MetadataRetry:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Retry{value.ToProto()},
		}
	case *MetadataSQLMigration:
		return &destpb.Metadata{
			Value: &destpb.Metadata_SqlMigration{value.ToProto()},
		}
	case *MetadataSQLQuery:
		return &destpb.Metadata{
			Value: &destpb.Metadata_SqlQuery{value.ToProto()},
		}
	case *MetadataSecrets:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Secrets{value.ToProto()},
		}
	case *MetadataSubscriber:
		return &destpb.Metadata{
			Value: &destpb.Metadata_Subscriber{value.ToProto()},
		}
	case *MetadataTypeMap:
		return &destpb.Metadata{
			Value: &destpb.Metadata_TypeMap{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func MetadataFromProto(v *destpb.Metadata) (Metadata, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Metadata_Alias:
		return MetadataAliasFromProto(v.GetAlias())
	case *destpb.Metadata_Artefact:
		return MetadataArtefactFromProto(v.GetArtefact())
	case *destpb.Metadata_Calls:
		return MetadataCallsFromProto(v.GetCalls())
	case *destpb.Metadata_Config:
		return MetadataConfigFromProto(v.GetConfig())
	case *destpb.Metadata_CronJob:
		return MetadataCronJobFromProto(v.GetCronJob())
	case *destpb.Metadata_DbColumn:
		return MetadataDBColumnFromProto(v.GetDbColumn())
	case *destpb.Metadata_Databases:
		return MetadataDatabasesFromProto(v.GetDatabases())
	case *destpb.Metadata_Encoding:
		return MetadataEncodingFromProto(v.GetEncoding())
	case *destpb.Metadata_Ingress:
		return MetadataIngressFromProto(v.GetIngress())
	case *destpb.Metadata_Partitions:
		return MetadataPartitionsFromProto(v.GetPartitions())
	case *destpb.Metadata_Publisher:
		return MetadataPublisherFromProto(v.GetPublisher())
	case *destpb.Metadata_Retry:
		return MetadataRetryFromProto(v.GetRetry())
	case *destpb.Metadata_SqlMigration:
		return MetadataSQLMigrationFromProto(v.GetSqlMigration())
	case *destpb.Metadata_SqlQuery:
		return MetadataSQLQueryFromProto(v.GetSqlQuery())
	case *destpb.Metadata_Secrets:
		return MetadataSecretsFromProto(v.GetSecrets())
	case *destpb.Metadata_Subscriber:
		return MetadataSubscriberFromProto(v.GetSubscriber())
	case *destpb.Metadata_TypeMap:
		return MetadataTypeMapFromProto(v.GetTypeMap())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *MetadataAlias) ToProto() *destpb.MetadataAlias {
	if x == nil {
		return nil
	}
	return &destpb.MetadataAlias{
		Pos:   x.Pos.ToProto(),
		Kind:  x.Kind.ToProto(),
		Alias: string(x.Alias),
	}
}

func MetadataAliasFromProto(v *destpb.MetadataAlias) (out *MetadataAlias, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataAlias{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Kind, err = AliasKindFromProto(v.Kind); err != nil {
		return nil, fmt.Errorf("Kind: %w", err)
	}
	out.Alias = string(v.Alias)
	return out, nil
}

func (x *MetadataArtefact) ToProto() *destpb.MetadataArtefact {
	if x == nil {
		return nil
	}
	return &destpb.MetadataArtefact{
		Pos:        x.Pos.ToProto(),
		Path:       string(x.Path),
		Digest:     string(x.Digest),
		Executable: bool(x.Executable),
	}
}

func MetadataArtefactFromProto(v *destpb.MetadataArtefact) (out *MetadataArtefact, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataArtefact{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Path = string(v.Path)
	out.Digest = string(v.Digest)
	out.Executable = bool(v.Executable)
	return out, nil
}

func (x *MetadataCalls) ToProto() *destpb.MetadataCalls {
	if x == nil {
		return nil
	}
	return &destpb.MetadataCalls{
		Pos:   x.Pos.ToProto(),
		Calls: protoSlice[*destpb.Ref](x.Calls),
	}
}

func MetadataCallsFromProto(v *destpb.MetadataCalls) (out *MetadataCalls, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataCalls{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Calls, err = sliceMapErr(v.Calls, RefFromProto); err != nil {
		return nil, fmt.Errorf("Calls: %w", err)
	}
	return out, nil
}

func (x *MetadataConfig) ToProto() *destpb.MetadataConfig {
	if x == nil {
		return nil
	}
	return &destpb.MetadataConfig{
		Pos:    x.Pos.ToProto(),
		Config: protoSlice[*destpb.Ref](x.Config),
	}
}

func MetadataConfigFromProto(v *destpb.MetadataConfig) (out *MetadataConfig, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataConfig{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Config, err = sliceMapErr(v.Config, RefFromProto); err != nil {
		return nil, fmt.Errorf("Config: %w", err)
	}
	return out, nil
}

func (x *MetadataCronJob) ToProto() *destpb.MetadataCronJob {
	if x == nil {
		return nil
	}
	return &destpb.MetadataCronJob{
		Pos:  x.Pos.ToProto(),
		Cron: string(x.Cron),
	}
}

func MetadataCronJobFromProto(v *destpb.MetadataCronJob) (out *MetadataCronJob, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataCronJob{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Cron = string(v.Cron)
	return out, nil
}

func (x *MetadataDBColumn) ToProto() *destpb.MetadataDBColumn {
	if x == nil {
		return nil
	}
	return &destpb.MetadataDBColumn{
		Pos:   x.Pos.ToProto(),
		Table: string(x.Table),
		Name:  string(x.Name),
	}
}

func MetadataDBColumnFromProto(v *destpb.MetadataDBColumn) (out *MetadataDBColumn, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataDBColumn{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Table = string(v.Table)
	out.Name = string(v.Name)
	return out, nil
}

func (x *MetadataDatabases) ToProto() *destpb.MetadataDatabases {
	if x == nil {
		return nil
	}
	return &destpb.MetadataDatabases{
		Pos:   x.Pos.ToProto(),
		Calls: protoSlice[*destpb.Ref](x.Calls),
	}
}

func MetadataDatabasesFromProto(v *destpb.MetadataDatabases) (out *MetadataDatabases, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataDatabases{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Calls, err = sliceMapErr(v.Calls, RefFromProto); err != nil {
		return nil, fmt.Errorf("Calls: %w", err)
	}
	return out, nil
}

func (x *MetadataEncoding) ToProto() *destpb.MetadataEncoding {
	if x == nil {
		return nil
	}
	return &destpb.MetadataEncoding{
		Pos:     x.Pos.ToProto(),
		Type:    string(x.Type),
		Lenient: bool(x.Lenient),
	}
}

func MetadataEncodingFromProto(v *destpb.MetadataEncoding) (out *MetadataEncoding, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataEncoding{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Type = string(v.Type)
	out.Lenient = bool(v.Lenient)
	return out, nil
}

func (x *MetadataIngress) ToProto() *destpb.MetadataIngress {
	if x == nil {
		return nil
	}
	return &destpb.MetadataIngress{
		Pos:    x.Pos.ToProto(),
		Type:   string(x.Type),
		Method: string(x.Method),
		Path:   sliceMap(x.Path, IngressPathComponentToProto),
	}
}

func MetadataIngressFromProto(v *destpb.MetadataIngress) (out *MetadataIngress, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataIngress{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Type = string(v.Type)
	out.Method = string(v.Method)
	if out.Path, err = sliceMapErr(v.Path, IngressPathComponentFromProto); err != nil {
		return nil, fmt.Errorf("Path: %w", err)
	}
	return out, nil
}

func (x *MetadataPartitions) ToProto() *destpb.MetadataPartitions {
	if x == nil {
		return nil
	}
	return &destpb.MetadataPartitions{
		Pos:        x.Pos.ToProto(),
		Partitions: int64(x.Partitions),
	}
}

func MetadataPartitionsFromProto(v *destpb.MetadataPartitions) (out *MetadataPartitions, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataPartitions{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Partitions = int(v.Partitions)
	return out, nil
}

func (x *MetadataPublisher) ToProto() *destpb.MetadataPublisher {
	if x == nil {
		return nil
	}
	return &destpb.MetadataPublisher{
		Pos:    x.Pos.ToProto(),
		Topics: protoSlice[*destpb.Ref](x.Topics),
	}
}

func MetadataPublisherFromProto(v *destpb.MetadataPublisher) (out *MetadataPublisher, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataPublisher{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Topics, err = sliceMapErr(v.Topics, RefFromProto); err != nil {
		return nil, fmt.Errorf("Topics: %w", err)
	}
	return out, nil
}

func (x *MetadataRetry) ToProto() *destpb.MetadataRetry {
	if x == nil {
		return nil
	}
	return &destpb.MetadataRetry{
		Pos:        x.Pos.ToProto(),
		Count:      proto.Int64(int64(*x.Count)),
		MinBackoff: string(x.MinBackoff),
		MaxBackoff: string(x.MaxBackoff),
		Catch:      x.Catch.ToProto(),
	}
}

func MetadataRetryFromProto(v *destpb.MetadataRetry) (out *MetadataRetry, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataRetry{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Count = ptr(v.Count, int(orZero(v.Count)))
	out.MinBackoff = string(v.MinBackoff)
	out.MaxBackoff = string(v.MaxBackoff)
	if out.Catch, err = RefFromProto(v.Catch); err != nil {
		return nil, fmt.Errorf("Catch: %w", err)
	}
	return out, nil
}

func (x *MetadataSQLMigration) ToProto() *destpb.MetadataSQLMigration {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSQLMigration{
		Pos:    x.Pos.ToProto(),
		Digest: string(x.Digest),
	}
}

func MetadataSQLMigrationFromProto(v *destpb.MetadataSQLMigration) (out *MetadataSQLMigration, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSQLMigration{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Digest = string(v.Digest)
	return out, nil
}

func (x *MetadataSQLQuery) ToProto() *destpb.MetadataSQLQuery {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSQLQuery{
		Pos:     x.Pos.ToProto(),
		Command: string(x.Command),
		Query:   string(x.Query),
	}
}

func MetadataSQLQueryFromProto(v *destpb.MetadataSQLQuery) (out *MetadataSQLQuery, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSQLQuery{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Command = string(v.Command)
	out.Query = string(v.Query)
	return out, nil
}

func (x *MetadataSecrets) ToProto() *destpb.MetadataSecrets {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSecrets{
		Pos:     x.Pos.ToProto(),
		Secrets: protoSlice[*destpb.Ref](x.Secrets),
	}
}

func MetadataSecretsFromProto(v *destpb.MetadataSecrets) (out *MetadataSecrets, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSecrets{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Secrets, err = sliceMapErr(v.Secrets, RefFromProto); err != nil {
		return nil, fmt.Errorf("Secrets: %w", err)
	}
	return out, nil
}

func (x *MetadataSubscriber) ToProto() *destpb.MetadataSubscriber {
	if x == nil {
		return nil
	}
	return &destpb.MetadataSubscriber{
		Pos:        x.Pos.ToProto(),
		Topic:      x.Topic.ToProto(),
		FromOffset: x.FromOffset.ToProto(),
		DeadLetter: bool(x.DeadLetter),
	}
}

func MetadataSubscriberFromProto(v *destpb.MetadataSubscriber) (out *MetadataSubscriber, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataSubscriber{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Topic, err = RefFromProto(v.Topic); err != nil {
		return nil, fmt.Errorf("Topic: %w", err)
	}
	if out.FromOffset, err = FromOffsetFromProto(v.FromOffset); err != nil {
		return nil, fmt.Errorf("FromOffset: %w", err)
	}
	out.DeadLetter = bool(v.DeadLetter)
	return out, nil
}

func (x *MetadataTypeMap) ToProto() *destpb.MetadataTypeMap {
	if x == nil {
		return nil
	}
	return &destpb.MetadataTypeMap{
		Pos:        x.Pos.ToProto(),
		Runtime:    string(x.Runtime),
		NativeName: string(x.NativeName),
	}
}

func MetadataTypeMapFromProto(v *destpb.MetadataTypeMap) (out *MetadataTypeMap, err error) {
	if v == nil {
		return nil, nil
	}

	out = &MetadataTypeMap{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Runtime = string(v.Runtime)
	out.NativeName = string(v.NativeName)
	return out, nil
}

func (x *Module) ToProto() *destpb.Module {
	if x == nil {
		return nil
	}
	return &destpb.Module{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Builtin:  bool(x.Builtin),
		Name:     string(x.Name),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
		Decls:    sliceMap(x.Decls, DeclToProto),
		Runtime:  x.Runtime.ToProto(),
	}
}

func ModuleFromProto(v *destpb.Module) (out *Module, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Module{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Builtin = bool(v.Builtin)
	out.Name = string(v.Name)
	if out.Metadata, err = sliceMapErr(v.Metadata, MetadataFromProto); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	if out.Decls, err = sliceMapErr(v.Decls, DeclFromProto); err != nil {
		return nil, fmt.Errorf("Decls: %w", err)
	}
	if out.Runtime, err = ModuleRuntimeFromProto(v.Runtime); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	return out, nil
}

func (x *ModuleRuntime) ToProto() *destpb.ModuleRuntime {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntime{
		Base:       x.Base.ToProto(),
		Scaling:    x.Scaling.ToProto(),
		Deployment: x.Deployment.ToProto(),
	}
}

func ModuleRuntimeFromProto(v *destpb.ModuleRuntime) (out *ModuleRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntime{}
	if fieldBase, err := ModuleRuntimeBaseFromProto(v.Base); err != nil {
		return nil, fmt.Errorf("Base: %w", err)
	} else {
		out.Base = fromPtr(fieldBase)
	}
	if out.Scaling, err = ModuleRuntimeScalingFromProto(v.Scaling); err != nil {
		return nil, fmt.Errorf("Scaling: %w", err)
	}
	if out.Deployment, err = ModuleRuntimeDeploymentFromProto(v.Deployment); err != nil {
		return nil, fmt.Errorf("Deployment: %w", err)
	}
	return out, nil
}

func (x *ModuleRuntimeBase) ToProto() *destpb.ModuleRuntimeBase {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeBase{
		CreateTime: timestamppb.New(x.CreateTime),
		Language:   string(x.Language),
		Os:         proto.String(string(x.OS)),
		Arch:       proto.String(string(x.Arch)),
		Image:      proto.String(string(x.Image)),
	}
}

func ModuleRuntimeBaseFromProto(v *destpb.ModuleRuntimeBase) (out *ModuleRuntimeBase, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntimeBase{}
	out.CreateTime = v.CreateTime.AsTime()
	out.Language = string(v.Language)
	out.OS = string(orZero(v.Os))
	out.Arch = string(orZero(v.Arch))
	out.Image = string(orZero(v.Image))
	return out, nil
}

func (x *ModuleRuntimeDeployment) ToProto() *destpb.ModuleRuntimeDeployment {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeDeployment{
		Endpoint:      string(x.Endpoint),
		DeploymentKey: string(protoMust(x.DeploymentKey.MarshalText())),
		CreatedAt:     timestamppb.New(x.CreatedAt),
		ActivatedAt:   timestamppb.New(x.ActivatedAt),
	}
}

func ModuleRuntimeDeploymentFromProto(v *destpb.ModuleRuntimeDeployment) (out *ModuleRuntimeDeployment, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntimeDeployment{}
	out.Endpoint = string(v.Endpoint)
	if err = out.DeploymentKey.UnmarshalText([]byte(v.DeploymentKey)); err != nil {
		return nil, fmt.Errorf("DeploymentKey: %w", err)
	}
	out.CreatedAt = v.CreatedAt.AsTime()
	out.ActivatedAt = v.ActivatedAt.AsTime()
	return out, nil
}

// ModuleRuntimeEventToProto converts a ModuleRuntimeEvent sum type to a protobuf message.
func ModuleRuntimeEventToProto(value ModuleRuntimeEvent) *destpb.ModuleRuntimeEvent {
	switch value := value.(type) {
	case nil:
		return nil
	case *ModuleRuntimeBase:
		return &destpb.ModuleRuntimeEvent{
			Value: &destpb.ModuleRuntimeEvent_ModuleRuntimeBase{value.ToProto()},
		}
	case *ModuleRuntimeDeployment:
		return &destpb.ModuleRuntimeEvent{
			Value: &destpb.ModuleRuntimeEvent_ModuleRuntimeDeployment{value.ToProto()},
		}
	case *ModuleRuntimeScaling:
		return &destpb.ModuleRuntimeEvent{
			Value: &destpb.ModuleRuntimeEvent_ModuleRuntimeScaling{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func ModuleRuntimeEventFromProto(v *destpb.ModuleRuntimeEvent) (ModuleRuntimeEvent, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.ModuleRuntimeEvent_ModuleRuntimeBase:
		return ModuleRuntimeBaseFromProto(v.GetModuleRuntimeBase())
	case *destpb.ModuleRuntimeEvent_ModuleRuntimeDeployment:
		return ModuleRuntimeDeploymentFromProto(v.GetModuleRuntimeDeployment())
	case *destpb.ModuleRuntimeEvent_ModuleRuntimeScaling:
		return ModuleRuntimeScalingFromProto(v.GetModuleRuntimeScaling())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *ModuleRuntimeScaling) ToProto() *destpb.ModuleRuntimeScaling {
	if x == nil {
		return nil
	}
	return &destpb.ModuleRuntimeScaling{
		MinReplicas: int32(x.MinReplicas),
	}
}

func ModuleRuntimeScalingFromProto(v *destpb.ModuleRuntimeScaling) (out *ModuleRuntimeScaling, err error) {
	if v == nil {
		return nil, nil
	}

	out = &ModuleRuntimeScaling{}
	out.MinReplicas = int32(v.MinReplicas)
	return out, nil
}

func (x *Optional) ToProto() *destpb.Optional {
	if x == nil {
		return nil
	}
	return &destpb.Optional{
		Pos:  x.Pos.ToProto(),
		Type: TypeToProto(x.Type),
	}
}

func OptionalFromProto(v *destpb.Optional) (out *Optional, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Optional{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Type, err = TypeFromProto(v.Type); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	return out, nil
}

func (x *Position) ToProto() *destpb.Position {
	if x == nil {
		return nil
	}
	return &destpb.Position{
		Filename: string(x.Filename),
		Line:     int64(x.Line),
		Column:   int64(x.Column),
	}
}

func PositionFromProto(v *destpb.Position) (out *Position, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Position{}
	out.Filename = string(v.Filename)
	out.Line = int(v.Line)
	out.Column = int(v.Column)
	return out, nil
}

func (x *Ref) ToProto() *destpb.Ref {
	if x == nil {
		return nil
	}
	return &destpb.Ref{
		Pos:            x.Pos.ToProto(),
		Module:         string(x.Module),
		Name:           string(x.Name),
		TypeParameters: sliceMap(x.TypeParameters, TypeToProto),
	}
}

func RefFromProto(v *destpb.Ref) (out *Ref, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Ref{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Module = string(v.Module)
	out.Name = string(v.Name)
	if out.TypeParameters, err = sliceMapErr(v.TypeParameters, TypeFromProto); err != nil {
		return nil, fmt.Errorf("TypeParameters: %w", err)
	}
	return out, nil
}

// RuntimeEventToProto converts a RuntimeEvent sum type to a protobuf message.
func RuntimeEventToProto(value RuntimeEvent) *destpb.RuntimeEvent {
	switch value := value.(type) {
	case nil:
		return nil
	case *DatabaseRuntimeEvent:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_DatabaseRuntimeEvent{value.ToProto()},
		}
	case *ModuleRuntimeBase:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_ModuleRuntimeBase{value.ToProto()},
		}
	case *ModuleRuntimeDeployment:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_ModuleRuntimeDeployment{value.ToProto()},
		}
	case *ModuleRuntimeScaling:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_ModuleRuntimeScaling{value.ToProto()},
		}
	case *TopicRuntimeEvent:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_TopicRuntimeEvent{value.ToProto()},
		}
	case *VerbRuntimeEvent:
		return &destpb.RuntimeEvent{
			Value: &destpb.RuntimeEvent_VerbRuntimeEvent{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func RuntimeEventFromProto(v *destpb.RuntimeEvent) (RuntimeEvent, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.RuntimeEvent_DatabaseRuntimeEvent:
		return DatabaseRuntimeEventFromProto(v.GetDatabaseRuntimeEvent())
	case *destpb.RuntimeEvent_ModuleRuntimeBase:
		return ModuleRuntimeBaseFromProto(v.GetModuleRuntimeBase())
	case *destpb.RuntimeEvent_ModuleRuntimeDeployment:
		return ModuleRuntimeDeploymentFromProto(v.GetModuleRuntimeDeployment())
	case *destpb.RuntimeEvent_ModuleRuntimeScaling:
		return ModuleRuntimeScalingFromProto(v.GetModuleRuntimeScaling())
	case *destpb.RuntimeEvent_TopicRuntimeEvent:
		return TopicRuntimeEventFromProto(v.GetTopicRuntimeEvent())
	case *destpb.RuntimeEvent_VerbRuntimeEvent:
		return VerbRuntimeEventFromProto(v.GetVerbRuntimeEvent())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Schema) ToProto() *destpb.Schema {
	if x == nil {
		return nil
	}
	return &destpb.Schema{
		Pos:     x.Pos.ToProto(),
		Modules: protoSlice[*destpb.Module](x.Modules),
	}
}

func SchemaFromProto(v *destpb.Schema) (out *Schema, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Schema{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Modules, err = sliceMapErr(v.Modules, ModuleFromProto); err != nil {
		return nil, fmt.Errorf("Modules: %w", err)
	}
	return out, nil
}

func (x *Secret) ToProto() *destpb.Secret {
	if x == nil {
		return nil
	}
	return &destpb.Secret{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Name:     string(x.Name),
		Type:     TypeToProto(x.Type),
	}
}

func SecretFromProto(v *destpb.Secret) (out *Secret, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Secret{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Name = string(v.Name)
	if out.Type, err = TypeFromProto(v.Type); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	return out, nil
}

func (x *String) ToProto() *destpb.String {
	if x == nil {
		return nil
	}
	return &destpb.String{
		Pos: x.Pos.ToProto(),
	}
}

func StringFromProto(v *destpb.String) (out *String, err error) {
	if v == nil {
		return nil, nil
	}

	out = &String{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	return out, nil
}

func (x *StringValue) ToProto() *destpb.StringValue {
	if x == nil {
		return nil
	}
	return &destpb.StringValue{
		Pos:   x.Pos.ToProto(),
		Value: string(x.Value),
	}
}

func StringValueFromProto(v *destpb.StringValue) (out *StringValue, err error) {
	if v == nil {
		return nil, nil
	}

	out = &StringValue{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Value = string(v.Value)
	return out, nil
}

func (x *Time) ToProto() *destpb.Time {
	if x == nil {
		return nil
	}
	return &destpb.Time{
		Pos: x.Pos.ToProto(),
	}
}

func TimeFromProto(v *destpb.Time) (out *Time, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Time{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	return out, nil
}

func (x *Topic) ToProto() *destpb.Topic {
	if x == nil {
		return nil
	}
	return &destpb.Topic{
		Pos:      x.Pos.ToProto(),
		Runtime:  x.Runtime.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Export:   bool(x.Export),
		Name:     string(x.Name),
		Event:    TypeToProto(x.Event),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
	}
}

func TopicFromProto(v *destpb.Topic) (out *Topic, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Topic{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Runtime, err = TopicRuntimeFromProto(v.Runtime); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Export = bool(v.Export)
	out.Name = string(v.Name)
	if out.Event, err = TypeFromProto(v.Event); err != nil {
		return nil, fmt.Errorf("Event: %w", err)
	}
	if out.Metadata, err = sliceMapErr(v.Metadata, MetadataFromProto); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *TopicRuntime) ToProto() *destpb.TopicRuntime {
	if x == nil {
		return nil
	}
	return &destpb.TopicRuntime{
		KafkaBrokers: sliceMap(x.KafkaBrokers, func(v string) string { return string(v) }),
		TopicId:      string(x.TopicID),
	}
}

func TopicRuntimeFromProto(v *destpb.TopicRuntime) (out *TopicRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TopicRuntime{}
	out.KafkaBrokers = sliceMap(v.KafkaBrokers, func(v string) string { return string(v) })
	out.TopicID = string(v.TopicId)
	return out, nil
}

func (x *TopicRuntimeEvent) ToProto() *destpb.TopicRuntimeEvent {
	if x == nil {
		return nil
	}
	return &destpb.TopicRuntimeEvent{
		Id:      string(x.ID),
		Payload: x.Payload.ToProto(),
	}
}

func TopicRuntimeEventFromProto(v *destpb.TopicRuntimeEvent) (out *TopicRuntimeEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TopicRuntimeEvent{}
	out.ID = string(v.Id)
	if out.Payload, err = TopicRuntimeFromProto(v.Payload); err != nil {
		return nil, fmt.Errorf("Payload: %w", err)
	}
	return out, nil
}

// TypeToProto converts a Type sum type to a protobuf message.
func TypeToProto(value Type) *destpb.Type {
	switch value := value.(type) {
	case nil:
		return nil
	case *Any:
		return &destpb.Type{
			Value: &destpb.Type_Any{value.ToProto()},
		}
	case *Array:
		return &destpb.Type{
			Value: &destpb.Type_Array{value.ToProto()},
		}
	case *Bool:
		return &destpb.Type{
			Value: &destpb.Type_Bool{value.ToProto()},
		}
	case *Bytes:
		return &destpb.Type{
			Value: &destpb.Type_Bytes{value.ToProto()},
		}
	case *Float:
		return &destpb.Type{
			Value: &destpb.Type_Float{value.ToProto()},
		}
	case *Int:
		return &destpb.Type{
			Value: &destpb.Type_Int{value.ToProto()},
		}
	case *Map:
		return &destpb.Type{
			Value: &destpb.Type_Map{value.ToProto()},
		}
	case *Optional:
		return &destpb.Type{
			Value: &destpb.Type_Optional{value.ToProto()},
		}
	case *Ref:
		return &destpb.Type{
			Value: &destpb.Type_Ref{value.ToProto()},
		}
	case *String:
		return &destpb.Type{
			Value: &destpb.Type_String_{value.ToProto()},
		}
	case *Time:
		return &destpb.Type{
			Value: &destpb.Type_Time{value.ToProto()},
		}
	case *Unit:
		return &destpb.Type{
			Value: &destpb.Type_Unit{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func TypeFromProto(v *destpb.Type) (Type, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Type_Any:
		return AnyFromProto(v.GetAny())
	case *destpb.Type_Array:
		return ArrayFromProto(v.GetArray())
	case *destpb.Type_Bool:
		return BoolFromProto(v.GetBool())
	case *destpb.Type_Bytes:
		return BytesFromProto(v.GetBytes())
	case *destpb.Type_Float:
		return FloatFromProto(v.GetFloat())
	case *destpb.Type_Int:
		return IntFromProto(v.GetInt())
	case *destpb.Type_Map:
		return MapFromProto(v.GetMap())
	case *destpb.Type_Optional:
		return OptionalFromProto(v.GetOptional())
	case *destpb.Type_Ref:
		return RefFromProto(v.GetRef())
	case *destpb.Type_String_:
		return StringFromProto(v.GetString_())
	case *destpb.Type_Time:
		return TimeFromProto(v.GetTime())
	case *destpb.Type_Unit:
		return UnitFromProto(v.GetUnit())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *TypeAlias) ToProto() *destpb.TypeAlias {
	if x == nil {
		return nil
	}
	return &destpb.TypeAlias{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Export:   bool(x.Export),
		Name:     string(x.Name),
		Type:     TypeToProto(x.Type),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
	}
}

func TypeAliasFromProto(v *destpb.TypeAlias) (out *TypeAlias, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TypeAlias{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Export = bool(v.Export)
	out.Name = string(v.Name)
	if out.Type, err = TypeFromProto(v.Type); err != nil {
		return nil, fmt.Errorf("Type: %w", err)
	}
	if out.Metadata, err = sliceMapErr(v.Metadata, MetadataFromProto); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	return out, nil
}

func (x *TypeParameter) ToProto() *destpb.TypeParameter {
	if x == nil {
		return nil
	}
	return &destpb.TypeParameter{
		Pos:  x.Pos.ToProto(),
		Name: string(x.Name),
	}
}

func TypeParameterFromProto(v *destpb.TypeParameter) (out *TypeParameter, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TypeParameter{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Name = string(v.Name)
	return out, nil
}

func (x *TypeValue) ToProto() *destpb.TypeValue {
	if x == nil {
		return nil
	}
	return &destpb.TypeValue{
		Pos:   x.Pos.ToProto(),
		Value: TypeToProto(x.Value),
	}
}

func TypeValueFromProto(v *destpb.TypeValue) (out *TypeValue, err error) {
	if v == nil {
		return nil, nil
	}

	out = &TypeValue{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	if out.Value, err = TypeFromProto(v.Value); err != nil {
		return nil, fmt.Errorf("Value: %w", err)
	}
	return out, nil
}

func (x *Unit) ToProto() *destpb.Unit {
	if x == nil {
		return nil
	}
	return &destpb.Unit{
		Pos: x.Pos.ToProto(),
	}
}

func UnitFromProto(v *destpb.Unit) (out *Unit, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Unit{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	return out, nil
}

// ValueToProto converts a Value sum type to a protobuf message.
func ValueToProto(value Value) *destpb.Value {
	switch value := value.(type) {
	case nil:
		return nil
	case *IntValue:
		return &destpb.Value{
			Value: &destpb.Value_IntValue{value.ToProto()},
		}
	case *StringValue:
		return &destpb.Value{
			Value: &destpb.Value_StringValue{value.ToProto()},
		}
	case *TypeValue:
		return &destpb.Value{
			Value: &destpb.Value_TypeValue{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func ValueFromProto(v *destpb.Value) (Value, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.Value_IntValue:
		return IntValueFromProto(v.GetIntValue())
	case *destpb.Value_StringValue:
		return StringValueFromProto(v.GetStringValue())
	case *destpb.Value_TypeValue:
		return TypeValueFromProto(v.GetTypeValue())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *Verb) ToProto() *destpb.Verb {
	if x == nil {
		return nil
	}
	return &destpb.Verb{
		Pos:      x.Pos.ToProto(),
		Comments: sliceMap(x.Comments, func(v string) string { return string(v) }),
		Export:   bool(x.Export),
		Name:     string(x.Name),
		Request:  TypeToProto(x.Request),
		Response: TypeToProto(x.Response),
		Metadata: sliceMap(x.Metadata, MetadataToProto),
		Runtime:  x.Runtime.ToProto(),
	}
}

func VerbFromProto(v *destpb.Verb) (out *Verb, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Verb{}
	if fieldPos, err := PositionFromProto(v.Pos); err != nil {
		return nil, fmt.Errorf("Pos: %w", err)
	} else {
		out.Pos = fromPtr(fieldPos)
	}
	out.Comments = sliceMap(v.Comments, func(v string) string { return string(v) })
	out.Export = bool(v.Export)
	out.Name = string(v.Name)
	if out.Request, err = TypeFromProto(v.Request); err != nil {
		return nil, fmt.Errorf("Request: %w", err)
	}
	if out.Response, err = TypeFromProto(v.Response); err != nil {
		return nil, fmt.Errorf("Response: %w", err)
	}
	if out.Metadata, err = sliceMapErr(v.Metadata, MetadataFromProto); err != nil {
		return nil, fmt.Errorf("Metadata: %w", err)
	}
	if out.Runtime, err = VerbRuntimeFromProto(v.Runtime); err != nil {
		return nil, fmt.Errorf("Runtime: %w", err)
	}
	return out, nil
}

func (x *VerbRuntime) ToProto() *destpb.VerbRuntime {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntime{
		Base:         x.Base.ToProto(),
		Subscription: x.Subscription.ToProto(),
	}
}

func VerbRuntimeFromProto(v *destpb.VerbRuntime) (out *VerbRuntime, err error) {
	if v == nil {
		return nil, nil
	}

	out = &VerbRuntime{}
	if fieldBase, err := VerbRuntimeBaseFromProto(v.Base); err != nil {
		return nil, fmt.Errorf("Base: %w", err)
	} else {
		out.Base = fromPtr(fieldBase)
	}
	if out.Subscription, err = VerbRuntimeSubscriptionFromProto(v.Subscription); err != nil {
		return nil, fmt.Errorf("Subscription: %w", err)
	}
	return out, nil
}

func (x *VerbRuntimeBase) ToProto() *destpb.VerbRuntimeBase {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntimeBase{
		CreateTime: timestamppb.New(x.CreateTime),
		StartTime:  timestamppb.New(x.StartTime),
	}
}

func VerbRuntimeBaseFromProto(v *destpb.VerbRuntimeBase) (out *VerbRuntimeBase, err error) {
	if v == nil {
		return nil, nil
	}

	out = &VerbRuntimeBase{}
	out.CreateTime = v.CreateTime.AsTime()
	out.StartTime = v.StartTime.AsTime()
	return out, nil
}

func (x *VerbRuntimeEvent) ToProto() *destpb.VerbRuntimeEvent {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntimeEvent{
		Id:      string(x.ID),
		Payload: VerbRuntimePayloadToProto(x.Payload),
	}
}

func VerbRuntimeEventFromProto(v *destpb.VerbRuntimeEvent) (out *VerbRuntimeEvent, err error) {
	if v == nil {
		return nil, nil
	}

	out = &VerbRuntimeEvent{}
	out.ID = string(v.Id)
	if out.Payload, err = VerbRuntimePayloadFromProto(v.Payload); err != nil {
		return nil, fmt.Errorf("Payload: %w", err)
	}
	return out, nil
}

// VerbRuntimePayloadToProto converts a VerbRuntimePayload sum type to a protobuf message.
func VerbRuntimePayloadToProto(value VerbRuntimePayload) *destpb.VerbRuntimePayload {
	switch value := value.(type) {
	case nil:
		return nil
	case *VerbRuntimeBase:
		return &destpb.VerbRuntimePayload{
			Value: &destpb.VerbRuntimePayload_VerbRuntimeBase{value.ToProto()},
		}
	case *VerbRuntimeSubscription:
		return &destpb.VerbRuntimePayload{
			Value: &destpb.VerbRuntimePayload_VerbRuntimeSubscription{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func VerbRuntimePayloadFromProto(v *destpb.VerbRuntimePayload) (VerbRuntimePayload, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.VerbRuntimePayload_VerbRuntimeBase:
		return VerbRuntimeBaseFromProto(v.GetVerbRuntimeBase())
	case *destpb.VerbRuntimePayload_VerbRuntimeSubscription:
		return VerbRuntimeSubscriptionFromProto(v.GetVerbRuntimeSubscription())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *VerbRuntimeSubscription) ToProto() *destpb.VerbRuntimeSubscription {
	if x == nil {
		return nil
	}
	return &destpb.VerbRuntimeSubscription{
		KafkaBrokers: sliceMap(x.KafkaBrokers, func(v string) string { return string(v) }),
	}
}

func VerbRuntimeSubscriptionFromProto(v *destpb.VerbRuntimeSubscription) (out *VerbRuntimeSubscription, err error) {
	if v == nil {
		return nil, nil
	}

	out = &VerbRuntimeSubscription{}
	out.KafkaBrokers = sliceMap(v.KafkaBrokers, func(v string) string { return string(v) })
	return out, nil
}
