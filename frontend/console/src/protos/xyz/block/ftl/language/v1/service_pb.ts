// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file xyz/block/ftl/language/v1/service.proto (package xyz.block.ftl.language.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct } from "@bufbuild/protobuf";
import { Module, Schema } from "../../schema/v1/schema_pb.js";

/**
 * ModuleConfig contains the configuration for a module, found in the module's ftl.toml file.
 *
 * @generated from message xyz.block.ftl.language.v1.ModuleConfig
 */
export class ModuleConfig extends Message<ModuleConfig> {
  /**
   * Name of the module
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Absolute path to the module's directory
   *
   * @generated from field: string dir = 2;
   */
  dir = "";

  /**
   * The language of the module
   *
   * @generated from field: string language = 3;
   */
  language = "";

  /**
   * Absolute path to the directory containing all of this module's build artifacts for deployments
   *
   * @generated from field: string deploy_dir = 4;
   */
  deployDir = "";

  /**
   * Build is the command to build the module.
   *
   * @generated from field: optional string build = 5;
   */
  build?: string;

  /**
   * DevModeBuild is the command to build the module in dev mode.
   *
   * @generated from field: optional string dev_mode_build = 6;
   */
  devModeBuild?: string;

  /**
   * Build lock path to prevent concurrent builds
   *
   * @generated from field: string build_lock = 7;
   */
  buildLock = "";

  /**
   * Patterns to watch for file changes
   *
   * @generated from field: repeated string watch = 9;
   */
  watch: string[] = [];

  /**
   * LanguageConfig contains any metadata specific to a specific language.
   * These are stored in the ftl.toml file under the same key as the language (eg: "go", "java")
   *
   * @generated from field: google.protobuf.Struct language_config = 10;
   */
  languageConfig?: Struct;

  /**
   * The root directory containing the SQL files, relative to the module directory.
   *
   * @generated from field: string sql_root_dir = 11;
   */
  sqlRootDir = "";

  /**
   * The realm of the module
   *
   * @generated from field: string realm = 12;
   */
  realm = "";

  constructor(data?: PartialMessage<ModuleConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.ModuleConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dir", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "deploy_dir", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "build", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "dev_mode_build", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "build_lock", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "watch", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "language_config", kind: "message", T: Struct },
    { no: 11, name: "sql_root_dir", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "realm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleConfig {
    return new ModuleConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleConfig {
    return new ModuleConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleConfig {
    return new ModuleConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleConfig | PlainMessage<ModuleConfig> | undefined, b: ModuleConfig | PlainMessage<ModuleConfig> | undefined): boolean {
    return proto3.util.equals(ModuleConfig, a, b);
  }
}

/**
 * ProjectConfig contains a subset of the configuration for a project.
 *
 * @generated from message xyz.block.ftl.language.v1.ProjectConfig
 */
export class ProjectConfig extends Message<ProjectConfig> {
  /**
   * @generated from field: string root = 1;
   */
  root = "";

  /**
   * @generated from field: string realm = 2;
   */
  realm = "";

  /**
   * @generated from field: bool git = 3;
   */
  git = false;

  /**
   * @generated from field: bool hermit = 4;
   */
  hermit = false;

  constructor(data?: PartialMessage<ProjectConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.ProjectConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "realm", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "git", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "hermit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectConfig {
    return new ProjectConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectConfig {
    return new ProjectConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectConfig {
    return new ProjectConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectConfig | PlainMessage<ProjectConfig> | undefined, b: ProjectConfig | PlainMessage<ProjectConfig> | undefined): boolean {
    return proto3.util.equals(ProjectConfig, a, b);
  }
}

/**
 * @generated from message xyz.block.ftl.language.v1.GetDependenciesRequest
 */
export class GetDependenciesRequest extends Message<GetDependenciesRequest> {
  /**
   * @generated from field: xyz.block.ftl.language.v1.ModuleConfig module_config = 1;
   */
  moduleConfig?: ModuleConfig;

  constructor(data?: PartialMessage<GetDependenciesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.GetDependenciesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "module_config", kind: "message", T: ModuleConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDependenciesRequest {
    return new GetDependenciesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDependenciesRequest {
    return new GetDependenciesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDependenciesRequest {
    return new GetDependenciesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDependenciesRequest | PlainMessage<GetDependenciesRequest> | undefined, b: GetDependenciesRequest | PlainMessage<GetDependenciesRequest> | undefined): boolean {
    return proto3.util.equals(GetDependenciesRequest, a, b);
  }
}

/**
 * @generated from message xyz.block.ftl.language.v1.GetDependenciesResponse
 */
export class GetDependenciesResponse extends Message<GetDependenciesResponse> {
  /**
   * @generated from field: repeated string modules = 1;
   */
  modules: string[] = [];

  constructor(data?: PartialMessage<GetDependenciesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.GetDependenciesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "modules", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDependenciesResponse {
    return new GetDependenciesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDependenciesResponse {
    return new GetDependenciesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDependenciesResponse {
    return new GetDependenciesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetDependenciesResponse | PlainMessage<GetDependenciesResponse> | undefined, b: GetDependenciesResponse | PlainMessage<GetDependenciesResponse> | undefined): boolean {
    return proto3.util.equals(GetDependenciesResponse, a, b);
  }
}

/**
 * BuildContext contains contextual information needed to build.
 *
 * Plugins must include the build context's id when a build succeeds or fails.
 * For automatic rebuilds, plugins must use the most recent build context they have received.
 *
 * @generated from message xyz.block.ftl.language.v1.BuildContext
 */
export class BuildContext extends Message<BuildContext> {
  /**
   * The configuration for the module
   *
   * @generated from field: xyz.block.ftl.language.v1.ModuleConfig module_config = 1;
   */
  moduleConfig?: ModuleConfig;

  /**
   * The FTL schema including all dependencies
   *
   * @generated from field: xyz.block.ftl.schema.v1.Schema schema = 2;
   */
  schema?: Schema;

  /**
   * The dependencies for the module
   *
   * @generated from field: repeated string dependencies = 3;
   */
  dependencies: string[] = [];

  /**
   * Build environment provides environment variables to be set for the build command
   *
   * @generated from field: repeated string build_env = 4;
   */
  buildEnv: string[] = [];

  /**
   * @generated from field: string os = 5;
   */
  os = "";

  /**
   * @generated from field: string arch = 6;
   */
  arch = "";

  constructor(data?: PartialMessage<BuildContext>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.BuildContext";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "module_config", kind: "message", T: ModuleConfig },
    { no: 2, name: "schema", kind: "message", T: Schema },
    { no: 3, name: "dependencies", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "build_env", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "os", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "arch", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildContext {
    return new BuildContext().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildContext {
    return new BuildContext().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildContext {
    return new BuildContext().fromJsonString(jsonString, options);
  }

  static equals(a: BuildContext | PlainMessage<BuildContext> | undefined, b: BuildContext | PlainMessage<BuildContext> | undefined): boolean {
    return proto3.util.equals(BuildContext, a, b);
  }
}

/**
 * @generated from message xyz.block.ftl.language.v1.BuildContextUpdatedRequest
 */
export class BuildContextUpdatedRequest extends Message<BuildContextUpdatedRequest> {
  /**
   * @generated from field: xyz.block.ftl.language.v1.BuildContext build_context = 1;
   */
  buildContext?: BuildContext;

  constructor(data?: PartialMessage<BuildContextUpdatedRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.BuildContextUpdatedRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "build_context", kind: "message", T: BuildContext },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildContextUpdatedRequest {
    return new BuildContextUpdatedRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildContextUpdatedRequest {
    return new BuildContextUpdatedRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildContextUpdatedRequest {
    return new BuildContextUpdatedRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BuildContextUpdatedRequest | PlainMessage<BuildContextUpdatedRequest> | undefined, b: BuildContextUpdatedRequest | PlainMessage<BuildContextUpdatedRequest> | undefined): boolean {
    return proto3.util.equals(BuildContextUpdatedRequest, a, b);
  }
}

/**
 * @generated from message xyz.block.ftl.language.v1.BuildContextUpdatedResponse
 */
export class BuildContextUpdatedResponse extends Message<BuildContextUpdatedResponse> {
  constructor(data?: PartialMessage<BuildContextUpdatedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.BuildContextUpdatedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildContextUpdatedResponse {
    return new BuildContextUpdatedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildContextUpdatedResponse {
    return new BuildContextUpdatedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildContextUpdatedResponse {
    return new BuildContextUpdatedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BuildContextUpdatedResponse | PlainMessage<BuildContextUpdatedResponse> | undefined, b: BuildContextUpdatedResponse | PlainMessage<BuildContextUpdatedResponse> | undefined): boolean {
    return proto3.util.equals(BuildContextUpdatedResponse, a, b);
  }
}

/**
 * Error contains information about an error that occurred during a build.
 * Errors do not always cause a build failure. Use lesser levels to help guide the user.
 *
 * @generated from message xyz.block.ftl.language.v1.Error
 */
export class Error extends Message<Error> {
  /**
   * @generated from field: string msg = 1;
   */
  msg = "";

  /**
   * @generated from field: xyz.block.ftl.language.v1.Error.ErrorLevel level = 4;
   */
  level = Error_ErrorLevel.UNSPECIFIED;

  /**
   * @generated from field: optional xyz.block.ftl.language.v1.Position pos = 5;
   */
  pos?: Position;

  /**
   * @generated from field: xyz.block.ftl.language.v1.Error.ErrorType type = 6;
   */
  type = Error_ErrorType.UNSPECIFIED;

  constructor(data?: PartialMessage<Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "msg", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "level", kind: "enum", T: proto3.getEnumType(Error_ErrorLevel) },
    { no: 5, name: "pos", kind: "message", T: Position, opt: true },
    { no: 6, name: "type", kind: "enum", T: proto3.getEnumType(Error_ErrorType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Error {
    return new Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJsonString(jsonString, options);
  }

  static equals(a: Error | PlainMessage<Error> | undefined, b: Error | PlainMessage<Error> | undefined): boolean {
    return proto3.util.equals(Error, a, b);
  }
}

/**
 * @generated from enum xyz.block.ftl.language.v1.Error.ErrorLevel
 */
export enum Error_ErrorLevel {
  /**
   * @generated from enum value: ERROR_LEVEL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ERROR_LEVEL_INFO = 1;
   */
  INFO = 1,

  /**
   * @generated from enum value: ERROR_LEVEL_WARN = 2;
   */
  WARN = 2,

  /**
   * @generated from enum value: ERROR_LEVEL_ERROR = 3;
   */
  ERROR = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Error_ErrorLevel)
proto3.util.setEnumType(Error_ErrorLevel, "xyz.block.ftl.language.v1.Error.ErrorLevel", [
  { no: 0, name: "ERROR_LEVEL_UNSPECIFIED" },
  { no: 1, name: "ERROR_LEVEL_INFO" },
  { no: 2, name: "ERROR_LEVEL_WARN" },
  { no: 3, name: "ERROR_LEVEL_ERROR" },
]);

/**
 * @generated from enum xyz.block.ftl.language.v1.Error.ErrorType
 */
export enum Error_ErrorType {
  /**
   * @generated from enum value: ERROR_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ERROR_TYPE_FTL = 1;
   */
  FTL = 1,

  /**
   * Compiler errors are errors that are from the compiler. This is useful to avoid duplicate errors
   * being shown to the user when combining errors from multiple sources (eg: an IDE showing compiler
   * errors and FTL errors via LSP).
   *
   * @generated from enum value: ERROR_TYPE_COMPILER = 2;
   */
  COMPILER = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Error_ErrorType)
proto3.util.setEnumType(Error_ErrorType, "xyz.block.ftl.language.v1.Error.ErrorType", [
  { no: 0, name: "ERROR_TYPE_UNSPECIFIED" },
  { no: 1, name: "ERROR_TYPE_FTL" },
  { no: 2, name: "ERROR_TYPE_COMPILER" },
]);

/**
 * @generated from message xyz.block.ftl.language.v1.Position
 */
export class Position extends Message<Position> {
  /**
   * @generated from field: string filename = 1;
   */
  filename = "";

  /**
   * @generated from field: int64 line = 2;
   */
  line = protoInt64.zero;

  /**
   * @generated from field: int64 start_column = 3;
   */
  startColumn = protoInt64.zero;

  /**
   * @generated from field: int64 end_column = 4;
   */
  endColumn = protoInt64.zero;

  constructor(data?: PartialMessage<Position>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.Position";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filename", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "line", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "start_column", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "end_column", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Position {
    return new Position().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJsonString(jsonString, options);
  }

  static equals(a: Position | PlainMessage<Position> | undefined, b: Position | PlainMessage<Position> | undefined): boolean {
    return proto3.util.equals(Position, a, b);
  }
}

/**
 * @generated from message xyz.block.ftl.language.v1.ErrorList
 */
export class ErrorList extends Message<ErrorList> {
  /**
   * @generated from field: repeated xyz.block.ftl.language.v1.Error errors = 1;
   */
  errors: Error[] = [];

  constructor(data?: PartialMessage<ErrorList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.ErrorList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "errors", kind: "message", T: Error, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorList {
    return new ErrorList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorList {
    return new ErrorList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorList {
    return new ErrorList().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorList | PlainMessage<ErrorList> | undefined, b: ErrorList | PlainMessage<ErrorList> | undefined): boolean {
    return proto3.util.equals(ErrorList, a, b);
  }
}

/**
 * Request to build a module.
 *
 * @generated from message xyz.block.ftl.language.v1.BuildRequest
 */
export class BuildRequest extends Message<BuildRequest> {
  /**
   * @generated from field: xyz.block.ftl.language.v1.ProjectConfig project_config = 1;
   */
  projectConfig?: ProjectConfig;

  /**
   * The path to the directory containing all module stubs. Each module stub is in a subdirectory.
   *
   * @generated from field: string stubs_root = 2;
   */
  stubsRoot = "";

  /**
   * Indicates whether to watch for file changes and automatically rebuild
   *
   * @generated from field: bool dev_mode_build = 3;
   */
  devModeBuild = false;

  /**
   * @generated from field: xyz.block.ftl.language.v1.BuildContext build_context = 4;
   */
  buildContext?: BuildContext;

  constructor(data?: PartialMessage<BuildRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.BuildRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_config", kind: "message", T: ProjectConfig },
    { no: 2, name: "stubs_root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "dev_mode_build", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "build_context", kind: "message", T: BuildContext },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildRequest {
    return new BuildRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildRequest {
    return new BuildRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildRequest {
    return new BuildRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BuildRequest | PlainMessage<BuildRequest> | undefined, b: BuildRequest | PlainMessage<BuildRequest> | undefined): boolean {
    return proto3.util.equals(BuildRequest, a, b);
  }
}

/**
 * BuildSuccess should be sent when a build succeeds.
 *
 * FTL may ignore this event if it does not match FTL's current build context and state.
 *
 * @generated from message xyz.block.ftl.language.v1.BuildSuccess
 */
export class BuildSuccess extends Message<BuildSuccess> {
  /**
   * Module schema for the built module
   *
   * @generated from field: xyz.block.ftl.schema.v1.Module module = 1;
   */
  module?: Module;

  /**
   * Paths for files/directories to be deployed
   *
   * @generated from field: repeated string deploy = 2;
   */
  deploy: string[] = [];

  /**
   * Name of the docker image to use for the runner
   *
   * @generated from field: string docker_image = 3;
   */
  dockerImage = "";

  /**
   * Errors contains any errors that occurred during the build
   * No errors can have a level of ERROR, instead a BuildFailure should be sent
   * Instead this is useful for INFO and WARN level errors.
   *
   * @generated from field: xyz.block.ftl.language.v1.ErrorList errors = 4;
   */
  errors?: ErrorList;

  /**
   * Dev mode endpoint URI. If this is set then rather than trying to deploy the module, FTL will start a runner that
   * connects to this endpoint.
   *
   * @generated from field: optional string dev_endpoint = 5;
   */
  devEndpoint?: string;

  /**
   * Dev mode debug port
   *
   * @generated from field: optional int32 debug_port = 6;
   */
  debugPort?: number;

  /**
   * Dev mode hot reload endpoint, this is used to allow the runner to communicate info back to the running process
   *
   * @generated from field: optional string dev_hot_reload_endpoint = 7;
   */
  devHotReloadEndpoint?: string;

  /**
   * @generated from field: optional int64 dev_hot_reload_version = 8;
   */
  devHotReloadVersion?: bigint;

  /**
   * Files modified during the build, relative to the build dir
   *
   * @generated from field: repeated string modified_files = 9;
   */
  modifiedFiles: string[] = [];

  /**
   * If there have been no structural changes it is possible that no further action is required
   *
   * @generated from field: bool redeploy_not_required = 10;
   */
  redeployNotRequired = false;

  constructor(data?: PartialMessage<BuildSuccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.BuildSuccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "module", kind: "message", T: Module },
    { no: 2, name: "deploy", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "docker_image", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "errors", kind: "message", T: ErrorList },
    { no: 5, name: "dev_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "debug_port", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: "dev_hot_reload_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "dev_hot_reload_version", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 9, name: "modified_files", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "redeploy_not_required", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildSuccess {
    return new BuildSuccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildSuccess {
    return new BuildSuccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildSuccess {
    return new BuildSuccess().fromJsonString(jsonString, options);
  }

  static equals(a: BuildSuccess | PlainMessage<BuildSuccess> | undefined, b: BuildSuccess | PlainMessage<BuildSuccess> | undefined): boolean {
    return proto3.util.equals(BuildSuccess, a, b);
  }
}

/**
 * BuildFailure should be sent when a build fails.
 *
 * FTL may ignore this event if it does not match FTL's current build context and state.
 *
 * @generated from message xyz.block.ftl.language.v1.BuildFailure
 */
export class BuildFailure extends Message<BuildFailure> {
  /**
   * Errors contains any errors that occurred during the build
   *
   * @generated from field: xyz.block.ftl.language.v1.ErrorList errors = 1;
   */
  errors?: ErrorList;

  /**
   * Indicates the plugin determined that the dependencies in the BuildContext are out of date.
   * If a Build stream is being kept open for automatic rebuilds, FTL will call GetDependencies, followed by
   * BuildContextUpdated.
   *
   * @generated from field: bool invalidate_dependencies = 2;
   */
  invalidateDependencies = false;

  /**
   * Files modified during the build, relative to the build dir
   *
   * @generated from field: repeated string modified_files = 9;
   */
  modifiedFiles: string[] = [];

  constructor(data?: PartialMessage<BuildFailure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.BuildFailure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "errors", kind: "message", T: ErrorList },
    { no: 2, name: "invalidate_dependencies", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "modified_files", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildFailure {
    return new BuildFailure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildFailure {
    return new BuildFailure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildFailure {
    return new BuildFailure().fromJsonString(jsonString, options);
  }

  static equals(a: BuildFailure | PlainMessage<BuildFailure> | undefined, b: BuildFailure | PlainMessage<BuildFailure> | undefined): boolean {
    return proto3.util.equals(BuildFailure, a, b);
  }
}

/**
 * Every type of message that can be streamed from the language plugin for a build.
 *
 * @generated from message xyz.block.ftl.language.v1.BuildResponse
 */
export class BuildResponse extends Message<BuildResponse> {
  /**
   * @generated from oneof xyz.block.ftl.language.v1.BuildResponse.event
   */
  event: {
    /**
     * @generated from field: xyz.block.ftl.language.v1.BuildSuccess build_success = 1;
     */
    value: BuildSuccess;
    case: "buildSuccess";
  } | {
    /**
     * @generated from field: xyz.block.ftl.language.v1.BuildFailure build_failure = 2;
     */
    value: BuildFailure;
    case: "buildFailure";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BuildResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.BuildResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "build_success", kind: "message", T: BuildSuccess, oneof: "event" },
    { no: 2, name: "build_failure", kind: "message", T: BuildFailure, oneof: "event" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuildResponse {
    return new BuildResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuildResponse {
    return new BuildResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuildResponse {
    return new BuildResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BuildResponse | PlainMessage<BuildResponse> | undefined, b: BuildResponse | PlainMessage<BuildResponse> | undefined): boolean {
    return proto3.util.equals(BuildResponse, a, b);
  }
}

/**
 * @generated from message xyz.block.ftl.language.v1.GenerateStubsRequest
 */
export class GenerateStubsRequest extends Message<GenerateStubsRequest> {
  /**
   * The directory path to generate stubs into
   *
   * @generated from field: string dir = 1;
   */
  dir = "";

  /**
   * The schema of the module to generate stubs for
   *
   * @generated from field: xyz.block.ftl.schema.v1.Module module = 2;
   */
  module?: Module;

  /**
   * The module's configuration to generate stubs for
   *
   * @generated from field: xyz.block.ftl.language.v1.ModuleConfig module_config = 3;
   */
  moduleConfig?: ModuleConfig;

  /**
   * Native module configuration is the configuration for a module that uses the plugin's language, if
   * the main moduleConfig provided is of a different language. It is provided as a mechanism to derive
   * language specific information. For example, the language version.
   *
   * @generated from field: optional xyz.block.ftl.language.v1.ModuleConfig native_module_config = 4;
   */
  nativeModuleConfig?: ModuleConfig;

  constructor(data?: PartialMessage<GenerateStubsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.GenerateStubsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dir", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "module", kind: "message", T: Module },
    { no: 3, name: "module_config", kind: "message", T: ModuleConfig },
    { no: 4, name: "native_module_config", kind: "message", T: ModuleConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateStubsRequest {
    return new GenerateStubsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateStubsRequest {
    return new GenerateStubsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateStubsRequest {
    return new GenerateStubsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateStubsRequest | PlainMessage<GenerateStubsRequest> | undefined, b: GenerateStubsRequest | PlainMessage<GenerateStubsRequest> | undefined): boolean {
    return proto3.util.equals(GenerateStubsRequest, a, b);
  }
}

/**
 * @generated from message xyz.block.ftl.language.v1.GenerateStubsResponse
 */
export class GenerateStubsResponse extends Message<GenerateStubsResponse> {
  constructor(data?: PartialMessage<GenerateStubsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.GenerateStubsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateStubsResponse {
    return new GenerateStubsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateStubsResponse {
    return new GenerateStubsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateStubsResponse {
    return new GenerateStubsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateStubsResponse | PlainMessage<GenerateStubsResponse> | undefined, b: GenerateStubsResponse | PlainMessage<GenerateStubsResponse> | undefined): boolean {
    return proto3.util.equals(GenerateStubsResponse, a, b);
  }
}

/**
 * @generated from message xyz.block.ftl.language.v1.SyncStubReferencesRequest
 */
export class SyncStubReferencesRequest extends Message<SyncStubReferencesRequest> {
  /**
   * @generated from field: xyz.block.ftl.language.v1.ModuleConfig module_config = 1;
   */
  moduleConfig?: ModuleConfig;

  /**
   * The path of the directory containing all module stubs. Each module is in a subdirectory
   *
   * @generated from field: string stubs_root = 2;
   */
  stubsRoot = "";

  /**
   * The names of all modules that have had stubs generated
   *
   * @generated from field: repeated string modules = 3;
   */
  modules: string[] = [];

  /**
   * The complete FTL schema
   *
   * @generated from field: xyz.block.ftl.schema.v1.Schema schema = 4;
   */
  schema?: Schema;

  constructor(data?: PartialMessage<SyncStubReferencesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.SyncStubReferencesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "module_config", kind: "message", T: ModuleConfig },
    { no: 2, name: "stubs_root", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "modules", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "schema", kind: "message", T: Schema },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncStubReferencesRequest {
    return new SyncStubReferencesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncStubReferencesRequest {
    return new SyncStubReferencesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncStubReferencesRequest {
    return new SyncStubReferencesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SyncStubReferencesRequest | PlainMessage<SyncStubReferencesRequest> | undefined, b: SyncStubReferencesRequest | PlainMessage<SyncStubReferencesRequest> | undefined): boolean {
    return proto3.util.equals(SyncStubReferencesRequest, a, b);
  }
}

/**
 * @generated from message xyz.block.ftl.language.v1.SyncStubReferencesResponse
 */
export class SyncStubReferencesResponse extends Message<SyncStubReferencesResponse> {
  constructor(data?: PartialMessage<SyncStubReferencesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "xyz.block.ftl.language.v1.SyncStubReferencesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncStubReferencesResponse {
    return new SyncStubReferencesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncStubReferencesResponse {
    return new SyncStubReferencesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncStubReferencesResponse {
    return new SyncStubReferencesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SyncStubReferencesResponse | PlainMessage<SyncStubReferencesResponse> | undefined, b: SyncStubReferencesResponse | PlainMessage<SyncStubReferencesResponse> | undefined): boolean {
    return proto3.util.equals(SyncStubReferencesResponse, a, b);
  }
}

