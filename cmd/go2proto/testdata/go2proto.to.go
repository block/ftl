// Code generated by go2proto. DO NOT EDIT.

package testdata

import "fmt"
import "encoding"
import destpb "github.com/block/ftl/cmd/go2proto/testdata/testdatapb"
import "google.golang.org/protobuf/types/known/timestamppb"
import "google.golang.org/protobuf/types/known/durationpb"
import "github.com/alecthomas/types/optional"
import "github.com/alecthomas/types/result"

var _ fmt.Stringer
var _ = timestamppb.Timestamp{}
var _ = durationpb.Duration{}

// protoSlice converts a slice of values to a slice of protobuf values.
func protoSlice[P any, T interface{ ToProto() P }](values []T) []P {
	out := make([]P, len(values))
	for i, v := range values {
		out[i] = v.ToProto()
	}
	return out
}

func protoMust[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func sliceMap[T any, U any](values []T, f func(T) U) []U {
	out := make([]U, len(values))
	for i, v := range values {
		out[i] = f(v)
	}
	return out
}

func sliceMapR[T any, U any](values []T, f func(T) result.Result[U]) result.Result[[]U] {
	out := make([]U, len(values))
	for i, v := range values {
		r := f(v)
		if r.Err() != nil {
			return result.Err[[]U](r.Err())
		}
		out[i], _ = r.Get()
	}
	return result.Ok[[]U](out)
}

func orZero[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func orZeroR[T any](v result.Result[*T]) result.Result[T] {
	if v.Err() != nil {
		return result.Err[T](v.Err())
	}
	r, _ := v.Get()
	return result.Ok[T](orZero(r))
}

func optionalOrNil[T any](v optional.Option[T]) *T {
	if v.Ok() {
		r := v.MustGet()
		return &r
	}
	return nil
}

func ptr[T any](o T) *T {
	return &o
}

func ptrR[T any](o result.Result[T]) result.Result[*T] {
	if o.Err() != nil {
		return result.Err[*T](o.Err())
	}
	r, _ := o.Get()
	return result.Ok[*T](ptr(r))
}

func fromPtr[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func fromPtrR[T any](v result.Result[*T]) result.Result[T] {
	if v.Err() != nil {
		return result.Err[T](v.Err())
	}
	r, _ := v.Get()
	return result.Ok[T](fromPtr(r))
}

func optionalR[T any](r result.Result[*T]) result.Result[optional.Option[T]] {
	if r.Err() != nil {
		return result.Err[optional.Option[T]](r.Err())
	}
	v, _ := r.Get()
	return result.Ok[optional.Option[T]](optional.Ptr(v))
}

func setNil[T, O any](v *T, o *O) *T {
	if o == nil {
		return nil
	}
	return v
}

func setNilR[T, O any](v result.Result[*T], o *O) result.Result[*T] {
	if v.Err() != nil {
		return v
	}
	r, _ := v.Get()
	return result.Ok[*T](setNil(r, o))
}

type binaryUnmarshallable[T any] interface {
	*T
	encoding.BinaryUnmarshaler
}

type textUnmarshallable[T any] interface {
	*T
	encoding.TextUnmarshaler
}

func unmarshallBinary[T any, TPtr binaryUnmarshallable[T]](v []byte, f TPtr) result.Result[*T] {
	var to T
	toptr := (TPtr)(&to)

	err := toptr.UnmarshalBinary(v)
	if err != nil {
		return result.Err[*T](err)
	}
	return result.Ok[*T](&to)
}

func unmarshallText[T any, TPtr textUnmarshallable[T]](v []byte, f TPtr) result.Result[*T] {
	var to T
	toptr := (TPtr)(&to)

	err := toptr.UnmarshalText(v)
	if err != nil {
		return result.Err[*T](err)
	}
	return result.Ok[*T](&to)
}

func (x Enum) ToProto() destpb.Enum {
	return destpb.Enum(x)
}

func EnumFromProto(v destpb.Enum) (Enum, error) {
	// TODO: Check if the value is valid.
	return Enum(v), nil
}

func (x *Message) ToProto() *destpb.Message {
	if x == nil {
		return nil
	}
	return &destpb.Message{
		Time:           timestamppb.New(x.Time),
		OptTime:        timestamppb.New(x.OptTime),
		Duration:       durationpb.New(x.Duration),
		Invalid:        orZero(ptr(bool(x.Invalid))),
		Nested:         x.Nested.ToProto(),
		RepeatedNested: sliceMap(x.RepeatedNested, func(v Nested) *destpb.Nested { return v.ToProto() }),
	}
}

func MessageFromProto(v *destpb.Message) (out *Message, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Message{}
	if out.Time, err = orZeroR(result.From(setNil(ptr(v.Time.AsTime()), v.Time), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Time: %w", err)
	}
	if out.OptTime, err = orZeroR(result.From(setNil(ptr(v.OptTime.AsTime()), v.OptTime), nil)).Result(); err != nil {
		return nil, fmt.Errorf("OptTime: %w", err)
	}
	if out.Duration, err = orZeroR(result.From(setNil(ptr(v.Duration.AsDuration()), v.Duration), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Duration: %w", err)
	}
	if out.Invalid, err = orZeroR(result.From(ptr(bool(v.Invalid)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Invalid: %w", err)
	}
	if out.Nested, err = orZeroR(result.From(NestedFromProto(v.Nested))).Result(); err != nil {
		return nil, fmt.Errorf("Nested: %w", err)
	}
	if out.RepeatedNested, err = sliceMapR(v.RepeatedNested, func(v *destpb.Nested) result.Result[Nested] { return orZeroR(result.From(NestedFromProto(v))) }).Result(); err != nil {
		return nil, fmt.Errorf("RepeatedNested: %w", err)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *Nested) ToProto() *destpb.Nested {
	if x == nil {
		return nil
	}
	return &destpb.Nested{
		Nested: orZero(ptr(string(x.Nested))),
	}
}

func NestedFromProto(v *destpb.Nested) (out *Nested, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Nested{}
	if out.Nested, err = orZeroR(result.From(ptr(string(v.Nested)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Nested: %w", err)
	}
	return out, nil
}

func (x *Root) ToProto() *destpb.Root {
	if x == nil {
		return nil
	}
	return &destpb.Root{
		Int:             orZero(ptr(int64(x.Int))),
		String_:         orZero(ptr(string(x.String))),
		MessagePtr:      x.MessagePtr.ToProto(),
		Enum:            orZero(ptr(x.Enum.ToProto())),
		SumType:         SumTypeToProto(x.SumType),
		OptionalInt:     ptr(int64(x.OptionalInt)),
		OptionalIntPtr:  setNil(ptr(int64(orZero(x.OptionalIntPtr))), x.OptionalIntPtr),
		OptionalMsg:     x.OptionalMsg.ToProto(),
		RepeatedInt:     sliceMap(x.RepeatedInt, func(v int) int64 { return orZero(ptr(int64(v))) }),
		RepeatedMsg:     sliceMap(x.RepeatedMsg, func(v *Message) *destpb.Message { return v.ToProto() }),
		Url:             orZero(ptr(protoMust(x.URL.MarshalBinary()))),
		OptionalWrapper: setNil(ptr(string(orZero(optionalOrNil(x.OptionalWrapper)))), optionalOrNil(x.OptionalWrapper)),
		ExternalRoot:    orZero(ptr(string(protoMust(x.ExternalRoot.MarshalText())))),
		Key:             orZero(ptr(string(protoMust(x.Key.MarshalText())))),
		OptionalTime:    setNil(timestamppb.New(orZero(optionalOrNil(x.OptionalTime))), optionalOrNil(x.OptionalTime)),
		OptionalMessage: optionalOrNil(x.OptionalMessage).ToProto(),
	}
}

func RootFromProto(v *destpb.Root) (out *Root, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Root{}
	if out.Int, err = orZeroR(result.From(ptr(int(v.Int)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("Int: %w", err)
	}
	if out.String, err = orZeroR(result.From(ptr(string(v.String_)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("String: %w", err)
	}
	if out.MessagePtr, err = result.From(MessageFromProto(v.MessagePtr)).Result(); err != nil {
		return nil, fmt.Errorf("MessagePtr: %w", err)
	}
	if out.Enum, err = orZeroR(ptrR(result.From(EnumFromProto(v.Enum)))).Result(); err != nil {
		return nil, fmt.Errorf("Enum: %w", err)
	}
	if out.SumType, err = orZeroR(ptrR(result.From(SumTypeFromProto(v.SumType)))).Result(); err != nil {
		return nil, fmt.Errorf("SumType: %w", err)
	}
	if out.OptionalInt, err = orZeroR(result.From(setNil(ptr(int(orZero(v.OptionalInt))), v.OptionalInt), nil)).Result(); err != nil {
		return nil, fmt.Errorf("OptionalInt: %w", err)
	}
	if out.OptionalIntPtr, err = result.From(setNil(ptr(int(orZero(v.OptionalIntPtr))), v.OptionalIntPtr), nil).Result(); err != nil {
		return nil, fmt.Errorf("OptionalIntPtr: %w", err)
	}
	if out.OptionalMsg, err = result.From(MessageFromProto(v.OptionalMsg)).Result(); err != nil {
		return nil, fmt.Errorf("OptionalMsg: %w", err)
	}
	if out.RepeatedInt, err = sliceMapR(v.RepeatedInt, func(v int64) result.Result[int] { return orZeroR(result.From(ptr(int(v)), nil)) }).Result(); err != nil {
		return nil, fmt.Errorf("RepeatedInt: %w", err)
	}
	if out.RepeatedMsg, err = sliceMapR(v.RepeatedMsg, func(v *destpb.Message) result.Result[*Message] { return result.From(MessageFromProto(v)) }).Result(); err != nil {
		return nil, fmt.Errorf("RepeatedMsg: %w", err)
	}
	if out.URL, err = unmarshallBinary(v.Url, out.URL).Result(); err != nil {
		return nil, fmt.Errorf("URL: %w", err)
	}
	if out.OptionalWrapper, err = optionalR(result.From(setNil(ptr(string(orZero(v.OptionalWrapper))), v.OptionalWrapper), nil)).Result(); err != nil {
		return nil, fmt.Errorf("OptionalWrapper: %w", err)
	}
	if out.ExternalRoot, err = orZeroR(unmarshallText([]byte(v.ExternalRoot), &out.ExternalRoot)).Result(); err != nil {
		return nil, fmt.Errorf("ExternalRoot: %w", err)
	}
	if out.Key, err = orZeroR(unmarshallText([]byte(v.Key), &out.Key)).Result(); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if out.OptionalTime, err = optionalR(result.From(setNil(ptr(v.OptionalTime.AsTime()), v.OptionalTime), nil)).Result(); err != nil {
		return nil, fmt.Errorf("OptionalTime: %w", err)
	}
	if out.OptionalMessage, err = optionalR(result.From(MessageFromProto(v.OptionalMessage))).Result(); err != nil {
		return nil, fmt.Errorf("OptionalMessage: %w", err)
	}
	return out, nil
}

// SubSumTypeToProto converts a SubSumType sum type to a protobuf message.
func SubSumTypeToProto(value SubSumType) *destpb.SubSumType {
	switch value := value.(type) {
	case nil:
		return nil
	case *SubSumTypeA:
		return &destpb.SubSumType{
			Value: &destpb.SubSumType_A{value.ToProto()},
		}
	case *SubSumTypeB:
		return &destpb.SubSumType{
			Value: &destpb.SubSumType_B{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func SubSumTypeFromProto(v *destpb.SubSumType) (SubSumType, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.SubSumType_A:
		return SubSumTypeAFromProto(v.GetA())
	case *destpb.SubSumType_B:
		return SubSumTypeBFromProto(v.GetB())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *SubSumTypeA) ToProto() *destpb.SubSumTypeA {
	if x == nil {
		return nil
	}
	return &destpb.SubSumTypeA{
		A: orZero(ptr(string(x.A))),
	}
}

func SubSumTypeAFromProto(v *destpb.SubSumTypeA) (out *SubSumTypeA, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SubSumTypeA{}
	if out.A, err = orZeroR(result.From(ptr(string(v.A)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("A: %w", err)
	}
	return out, nil
}

func (x *SubSumTypeB) ToProto() *destpb.SubSumTypeB {
	if x == nil {
		return nil
	}
	return &destpb.SubSumTypeB{
		A: orZero(ptr(string(x.A))),
	}
}

func SubSumTypeBFromProto(v *destpb.SubSumTypeB) (out *SubSumTypeB, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SubSumTypeB{}
	if out.A, err = orZeroR(result.From(ptr(string(v.A)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("A: %w", err)
	}
	return out, nil
}

// SumTypeToProto converts a SumType sum type to a protobuf message.
func SumTypeToProto(value SumType) *destpb.SumType {
	switch value := value.(type) {
	case nil:
		return nil
	case *SubSumTypeA:
		return &destpb.SumType{
			Value: &destpb.SumType_SubSumTypeA{value.ToProto()},
		}
	case *SubSumTypeB:
		return &destpb.SumType{
			Value: &destpb.SumType_SubSumTypeB{value.ToProto()},
		}
	case *SumTypeA:
		return &destpb.SumType{
			Value: &destpb.SumType_A{value.ToProto()},
		}
	case *SumTypeB:
		return &destpb.SumType{
			Value: &destpb.SumType_B{value.ToProto()},
		}
	case *SumTypeC:
		return &destpb.SumType{
			Value: &destpb.SumType_C{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func SumTypeFromProto(v *destpb.SumType) (SumType, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.SumType_SubSumTypeA:
		return SubSumTypeAFromProto(v.GetSubSumTypeA())
	case *destpb.SumType_SubSumTypeB:
		return SubSumTypeBFromProto(v.GetSubSumTypeB())
	case *destpb.SumType_A:
		return SumTypeAFromProto(v.GetA())
	case *destpb.SumType_B:
		return SumTypeBFromProto(v.GetB())
	case *destpb.SumType_C:
		return SumTypeCFromProto(v.GetC())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *SumTypeA) ToProto() *destpb.SumTypeA {
	if x == nil {
		return nil
	}
	return &destpb.SumTypeA{
		A: orZero(ptr(string(x.A))),
	}
}

func SumTypeAFromProto(v *destpb.SumTypeA) (out *SumTypeA, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SumTypeA{}
	if out.A, err = orZeroR(result.From(ptr(string(v.A)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("A: %w", err)
	}
	return out, nil
}

func (x *SumTypeB) ToProto() *destpb.SumTypeB {
	if x == nil {
		return nil
	}
	return &destpb.SumTypeB{
		B: orZero(ptr(int64(x.B))),
	}
}

func SumTypeBFromProto(v *destpb.SumTypeB) (out *SumTypeB, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SumTypeB{}
	if out.B, err = orZeroR(result.From(ptr(int(v.B)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("B: %w", err)
	}
	return out, nil
}

func (x *SumTypeC) ToProto() *destpb.SumTypeC {
	if x == nil {
		return nil
	}
	return &destpb.SumTypeC{
		C: orZero(ptr(float64(x.C))),
	}
}

func SumTypeCFromProto(v *destpb.SumTypeC) (out *SumTypeC, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SumTypeC{}
	if out.C, err = orZeroR(result.From(ptr(float64(v.C)), nil)).Result(); err != nil {
		return nil, fmt.Errorf("C: %w", err)
	}
	return out, nil
}
