// Code generated by go2proto. DO NOT EDIT.

package testdata

import "fmt"
import destpb "github.com/block/ftl/cmd/go2proto/testdata/testdatapb"
import "google.golang.org/protobuf/proto"
import "google.golang.org/protobuf/types/known/timestamppb"
import "google.golang.org/protobuf/types/known/durationpb"

import "net/url"

var _ fmt.Stringer
var _ = timestamppb.Timestamp{}
var _ = durationpb.Duration{}

// protoSlice converts a slice of values to a slice of protobuf values.
func protoSlice[P any, T interface{ ToProto() P }](values []T) []P {
	out := make([]P, len(values))
	for i, v := range values {
		out[i] = v.ToProto()
	}
	return out
}

func protoMust[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func sliceMap[T any, U any](values []T, f func(T) U) []U {
	out := make([]U, len(values))
	for i, v := range values {
		out[i] = f(v)
	}
	return out
}

func sliceMapErr[T any, U any](values []T, f func(T) (U, error)) ([]U, error) {
	var err error
	out := make([]U, len(values))
	for i, v := range values {
		if out[i], err = f(v); err != nil {
			return nil, err
		}
	}
	return out, nil
}

func orZero[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func ptr[T any, O any](v *O, o T) *T {
	if v == nil {
		return nil
	}
	return &o
}

func fromPtr[T any](v *T) T {
	if v == nil {
		return *new(T)
	}
	return *v
}

func (x Enum) ToProto() destpb.Enum {
	return destpb.Enum(x)
}

func EnumFromProto(v destpb.Enum) (Enum, error) {
	// TODO: Check if the value is valid.
	return Enum(v), nil
}

func (x *Message) ToProto() *destpb.Message {
	if x == nil {
		return nil
	}
	return &destpb.Message{
		Time:     timestamppb.New(x.Time),
		Duration: durationpb.New(x.Duration),
		Invalid:  bool(x.Invalid),
		Nested:   x.Nested.ToProto(),
	}
}

func MessageFromProto(v *destpb.Message) (out *Message, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Message{}
	out.Time = v.Time.AsTime()
	out.Duration = v.Duration.AsDuration()
	out.Invalid = bool(v.Invalid)
	if fieldNested, err := NestedFromProto(v.Nested); err != nil {
		return nil, fmt.Errorf("Nested: %w", err)
	} else {
		out.Nested = fromPtr(fieldNested)
	}
	if err := out.Validate(); err != nil {
		return nil, err
	}
	return out, nil
}

func (x *Nested) ToProto() *destpb.Nested {
	if x == nil {
		return nil
	}
	return &destpb.Nested{
		Nested: string(x.Nested),
	}
}

func NestedFromProto(v *destpb.Nested) (out *Nested, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Nested{}
	out.Nested = string(v.Nested)
	return out, nil
}

func (x *Root) ToProto() *destpb.Root {
	if x == nil {
		return nil
	}
	return &destpb.Root{
		Int:            int64(x.Int),
		String_:        string(x.String),
		MessagePtr:     x.MessagePtr.ToProto(),
		Enum:           x.Enum.ToProto(),
		SumType:        SumTypeToProto(x.SumType),
		OptionalInt:    proto.Int64(int64(x.OptionalInt)),
		OptionalIntPtr: proto.Int64(int64(*x.OptionalIntPtr)),
		OptionalMsg:    x.OptionalMsg.ToProto(),
		RepeatedInt:    sliceMap(x.RepeatedInt, func(v int) int64 { return int64(v) }),
		RepeatedMsg:    protoSlice[*destpb.Message](x.RepeatedMsg),
		Url:            protoMust(x.URL.MarshalBinary()),
		Key:            string(protoMust(x.Key.MarshalText())),
		ExternalRoot:   string(protoMust(x.ExternalRoot.MarshalText())),
	}
}

func RootFromProto(v *destpb.Root) (out *Root, err error) {
	if v == nil {
		return nil, nil
	}

	out = &Root{}
	out.Int = int(v.Int)
	out.String = string(v.String_)
	if out.MessagePtr, err = MessageFromProto(v.MessagePtr); err != nil {
		return nil, fmt.Errorf("MessagePtr: %w", err)
	}
	if out.Enum, err = EnumFromProto(v.Enum); err != nil {
		return nil, fmt.Errorf("Enum: %w", err)
	}
	if out.SumType, err = SumTypeFromProto(v.SumType); err != nil {
		return nil, fmt.Errorf("SumType: %w", err)
	}
	out.OptionalInt = int(orZero(v.OptionalInt))
	out.OptionalIntPtr = ptr(v.OptionalIntPtr, int(orZero(v.OptionalIntPtr)))
	if out.OptionalMsg, err = MessageFromProto(v.OptionalMsg); err != nil {
		return nil, fmt.Errorf("OptionalMsg: %w", err)
	}
	out.RepeatedInt = sliceMap(v.RepeatedInt, func(v int64) int { return int(v) })
	if out.RepeatedMsg, err = sliceMapErr(v.RepeatedMsg, MessageFromProto); err != nil {
		return nil, fmt.Errorf("RepeatedMsg: %w", err)
	}
	out.URL = new(url.URL)
	if err = out.URL.UnmarshalBinary(v.Url); err != nil {
		return nil, fmt.Errorf("URL: %w", err)
	}
	if err = out.Key.UnmarshalText([]byte(v.Key)); err != nil {
		return nil, fmt.Errorf("Key: %w", err)
	}
	if err = out.ExternalRoot.UnmarshalText([]byte(v.ExternalRoot)); err != nil {
		return nil, fmt.Errorf("ExternalRoot: %w", err)
	}
	return out, nil
}

// SubSumTypeToProto converts a SubSumType sum type to a protobuf message.
func SubSumTypeToProto(value SubSumType) *destpb.SubSumType {
	switch value := value.(type) {
	case nil:
		return nil
	case *SubSumTypeA:
		return &destpb.SubSumType{
			Value: &destpb.SubSumType_A{value.ToProto()},
		}
	case *SubSumTypeB:
		return &destpb.SubSumType{
			Value: &destpb.SubSumType_B{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func SubSumTypeFromProto(v *destpb.SubSumType) (SubSumType, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.SubSumType_A:
		return SubSumTypeAFromProto(v.GetA())
	case *destpb.SubSumType_B:
		return SubSumTypeBFromProto(v.GetB())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *SubSumTypeA) ToProto() *destpb.SubSumTypeA {
	if x == nil {
		return nil
	}
	return &destpb.SubSumTypeA{
		A: string(x.A),
	}
}

func SubSumTypeAFromProto(v *destpb.SubSumTypeA) (out *SubSumTypeA, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SubSumTypeA{}
	out.A = string(v.A)
	return out, nil
}

func (x *SubSumTypeB) ToProto() *destpb.SubSumTypeB {
	if x == nil {
		return nil
	}
	return &destpb.SubSumTypeB{
		A: string(x.A),
	}
}

func SubSumTypeBFromProto(v *destpb.SubSumTypeB) (out *SubSumTypeB, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SubSumTypeB{}
	out.A = string(v.A)
	return out, nil
}

// SumTypeToProto converts a SumType sum type to a protobuf message.
func SumTypeToProto(value SumType) *destpb.SumType {
	switch value := value.(type) {
	case nil:
		return nil
	case *SubSumTypeA:
		return &destpb.SumType{
			Value: &destpb.SumType_SubSumTypeA{value.ToProto()},
		}
	case *SubSumTypeB:
		return &destpb.SumType{
			Value: &destpb.SumType_SubSumTypeB{value.ToProto()},
		}
	case *SumTypeA:
		return &destpb.SumType{
			Value: &destpb.SumType_A{value.ToProto()},
		}
	case *SumTypeB:
		return &destpb.SumType{
			Value: &destpb.SumType_B{value.ToProto()},
		}
	case *SumTypeC:
		return &destpb.SumType{
			Value: &destpb.SumType_C{value.ToProto()},
		}
	default:
		panic(fmt.Sprintf("unknown variant: %T", value))
	}
}

func SumTypeFromProto(v *destpb.SumType) (SumType, error) {
	if v == nil {
		return nil, nil
	}
	switch v.Value.(type) {
	case *destpb.SumType_SubSumTypeA:
		return SubSumTypeAFromProto(v.GetSubSumTypeA())
	case *destpb.SumType_SubSumTypeB:
		return SubSumTypeBFromProto(v.GetSubSumTypeB())
	case *destpb.SumType_A:
		return SumTypeAFromProto(v.GetA())
	case *destpb.SumType_B:
		return SumTypeBFromProto(v.GetB())
	case *destpb.SumType_C:
		return SumTypeCFromProto(v.GetC())
	default:
		panic(fmt.Sprintf("unknown variant: %T", v.Value))
	}
}

func (x *SumTypeA) ToProto() *destpb.SumTypeA {
	if x == nil {
		return nil
	}
	return &destpb.SumTypeA{
		A: string(x.A),
	}
}

func SumTypeAFromProto(v *destpb.SumTypeA) (out *SumTypeA, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SumTypeA{}
	out.A = string(v.A)
	return out, nil
}

func (x *SumTypeB) ToProto() *destpb.SumTypeB {
	if x == nil {
		return nil
	}
	return &destpb.SumTypeB{
		B: int64(x.B),
	}
}

func SumTypeBFromProto(v *destpb.SumTypeB) (out *SumTypeB, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SumTypeB{}
	out.B = int(v.B)
	return out, nil
}

func (x *SumTypeC) ToProto() *destpb.SumTypeC {
	if x == nil {
		return nil
	}
	return &destpb.SumTypeC{
		C: float64(x.C),
	}
}

func SumTypeCFromProto(v *destpb.SumTypeC) (out *SumTypeC, err error) {
	if v == nil {
		return nil, nil
	}

	out = &SumTypeC{}
	out.C = float64(v.C)
	return out, nil
}
