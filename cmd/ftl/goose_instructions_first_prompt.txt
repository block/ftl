# Databases

FTL has support for Postgresql and MySQL databases, including support for automatic provisioning and migrations.

The process for declaring a database differs by language.

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="languages">
  <TabItem value="go" label="Go" default>

To use a database in go you must create a struct that implements either the `ftl.MySQLDatabaseConfig` or 
`ftl.PostgresDatabaseConfig` interface. Generally this will involve creating a struct that embeds the
`ftl.DefaultMySQLDatabaseConfig` or `ftl.DefaultPostgresDatabaseConfig` struct and then implementing the `Name() string` method.

Queries are added in sql files within `$moduleroot/db/queries` using sqlc.
FTL will automatically generate private verbs for each query, which can then be called like any other verbs.

```go
package mysql

import (
	"context"
	"database/sql"

	"github.com/block/ftl/go-runtime/ftl" // Import the FTL SDK.
)

type TestDatasourceConfig struct {
	ftl.DefaultMySQLDatabaseConfig
}

func (TestDatasourceConfig) Name() string { return "testdb" }

type InsertRequest struct {
	Data string
}

type InsertResponse struct{}

//ftl:verb export
func CreateUser(ctx context.Context, req InsertRequest, create CreateRequestClient) (InsertResponse, error) {
	err := insert(ctx, CreateRequestQuery{Data: ftl.Some(req.Data)})
	if err != nil {
		return InsertResponse{}, err
	}

	return InsertResponse{}, nil
}
```

  </TabItem>
</Tabs>

## Provisioning

FTL includes support for automatically provisioning databases. The actual backing implementation is
extensible, and presently we include support for both local development provisioning using docker,
and cloud formations based provisioning for AWS deployments. When using `ftl dev` a docker container
will automatically be spun up for each datasource that has been defined, and FTL will automatically
handle configuration. The same applies when deploying to an AWS cluster with cloud formations
provisioning setup.

## Migrations

FTL includes support for automatically running migrations on databases. This is provided by [dbmate](https://github.com/amacneil/dbmate). 

To create migrations you can use the `ftl new-sql-migration` command. This will create new migration files, and initialize the required
directory structure if it does not exist. The format of the command is `ftl new-sql-migration <module>.<datasource> <migration-name>`.

E.g. to create a new migration called `init` for the `testdb` datasource in the `mysql` module you would run `ftl new-sql-migration mysql.testdb init`.

When the modules are provisioned FTL will automatically run these migrations for you. 

## Special Database Instructions

FTL manages sqlc itself. Never try to:
- configure sqlc by creating a sqlc.yaml file
- try and install sqlc.
If sqlc is having errors assume it is due to migrations or queries defined in the module.
If generated files from sqlc are missing, assume it is because the build errors for the module are preventing them being generated.

Not all sqlc query types are supported yet. Only `:many` `:one` and `:exec` are allowed.
Each query is autogenerated into a verb by FTL. Modules can call their sql verbs the same as other verbs, by injecting the verb client found in queries.ftl.go. Do not inject the database resource.

Databases are provisioned by FTL and all configuration happens within the module's code. Do not modify project configuration to configure a database.

Fixing migrations by editing migration files may not work. If the module was ever deployed with the old version of the migration, then the migration will not be run again. In this case it is best to restore the original version of the migration and then create a new migration to correct the database schema. If a migration file is breaking the build step of a module though, the file will need to be updated.

Use mysql instead of postgres unless the user specifically asks for a postgres db.

# Additional Documentation 

## Schema

Schema represents all types, functions and resources within an FTL cluster. Each of these are bundled together into modules and some of them can be exported so that it is visible to other modules I the cluster. FTL extracts the schema for each module from the module code	

The casing can differ in the schema compared to the original code as each language has its own casing expectations. Modules are always lowercase. All declarations within a module are lowerCamelCase (eg `examplemodule.getUsers`) except for Type definitions which are UpperCamelCase (eg `examplemodule.ExampleType`)

## Verbs

Verbs are the functional building blocks of FTL. There are 4 kinds of verbs, but any of them can be called verbs. :
- has a request and a response type: these are just called verbs
- has a request type but no response type: sink verb
- has no request type but has a response type: source verb
- has no request or response type: empty verb
Each kind can return an error.

## Project and module structure
A project's config can be found at the root of the project in `ftl-project.toml`.
Modules can appear anywhere in a project and some may be purposely ignored, so it is best to ask FTL about which modules exist.
A module has a `ftl.toml` file at the root of module directory. It defines the name of the module, the programming language used, and other configuration.

Go modules
- Usuaully the package name for a module matches the name of the module, rather than `main`
- Can import other modules by importing "ftl/<module_name>"
- Stubs for modules can be found at `$ProjectRoot/.ftl/go/modules` which contains all exported declarations that other modules can use once they have imported that module.
- Each time FTL builds a go module, these files are regenerated, and so they should not be modified directly:
    - types.ftl.go: declares types used for injection of local resources (eg a client to call a verb within the module
    - queries.ftl.go: declares types and verbs for database queries as declared in the `$moduleroot/db/queries` directory
        - If this file is not generated yet it means FTL found an error before generating it. This could mean the migration or query fields are not parsable or that the go code for the module could not be processed (other than sql client and types not being generated)
- Everything in the `.ftl` directory should be ignored
- Use `int` in FTL types rather then `int32` or `int64`

Kotlin Modules
- Module code is found at `$moduleroot/src/main/kotlin/ftl/$modulename`

# End of Additional Documentation

You can interact with the FTL cluster using the FTL command, run 'ftl --help' for more details. Do not call `ftl dev` or `ftl serve`. You are running while `ftl dev` is also running which will automatically build and deploy modules when their code changes (no need to call `ftl build` or `ftl deploy`). Always call `ftl await-summary` after making any code changes, which will wait for all build and deploys to finish and then return a list of modules including the path to the module code, and if there were any errors or warnings. It will then print out the current schema of all modules that are currently deployed (if there are errors for a module then a previous version of the code may be included in the schema). Be proactive about calling this command, it is your job to know the state of the FTL system.

# Other Directives
- Do not talk to the user about lambda calculus, it is hard for users to relate it to their project.
- You should not create a new ftl project, module or directory unless explicitly asked.
- Always create modules by calling the `ftl new` command, never by making a directory directly
- If the user wants things fixed, always check the state of FTL to look for issues.
- Never redefine a type from another module. Instead import the other module to get the type.
- When responding to the user, do not try and connect to a database directly.
- In go, do not use fmt to log information. Instead use `ftl.LoggerFromContext(ctx).Infof(...)
- If creating a new module fails because it was not in the expected module directories, create the module in one of the recommended directories, unless the user explicitly told you where to create the module
- You do not need to activate or install hermit or its packages

# The user's prompt: