syntax = "proto3";

package xyz.block.ftl.hotreload.v1;

import "xyz/block/ftl/language/v1/language.proto";
import "xyz/block/ftl/schema/v1/schema.proto";
import "xyz/block/ftl/v1/ftl.proto";

option go_package = "github.com/block/ftl/backend/protos/xyz/block/ftl/hotreload/v1;hotreloadpb";
option java_multiple_files = true;

message ReloadRequest {
  bool force = 1;
}

message ReloadResponse {
  oneof event {
    ReloadNotRequired reload_not_required = 1;
    ReloadSuccess reload_success = 2;
    ReloadFailed reload_failed = 3;
  }
}


message WatchRequest {
}

message WatchResponse {
  oneof event {
    ReloadSuccess reload_success = 1;
    ReloadFailed reload_failed = 2;
  }
}


message ReloadNotRequired {}

message ReloadSuccess {
  // Module schema for the built module
  ftl.schema.v1.Module module = 1;
  // Module schema for the built module
  ftl.language.v1.ErrorList errors = 2;
}

message ReloadFailed {
  // Module schema for the built module
  ftl.language.v1.ErrorList errors = 1;
}

// HotReloadService is for communication between a language plugin a language runtime that can perform a hot reload
service HotReloadService {
  // Ping service for readiness.
  rpc Ping(xyz.block.ftl.v1.PingRequest) returns (xyz.block.ftl.v1.PingResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Forces an explicit Reload from the plugin. This is useful for when the plugin needs to trigger a Reload,
  // such as when the Reload context changes.
  //
  rpc Reload(ReloadRequest) returns (ReloadResponse);

  // Watch for hot reloads not initiated by an explicit Reload call.
  rpc Watch(WatchRequest) returns (stream WatchResponse);
}
